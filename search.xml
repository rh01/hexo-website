<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[支持向量机算法]]></title>
      <url>%2F2017%2F12%2F24%2F2017-12-23-svm%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[隐马尔可夫模型]]></title>
      <url>%2F2017%2F12%2F23%2F2017-12-23-hmm%2F</url>
      <content type="text"><![CDATA[\noindent 很早就想写一篇关于隐马尔可夫模型的文章了，这次刻意的将模型及其有关算法复习了一下，才有了这个信心去写了这篇文章。这篇文章主要参考了李航老师的《统计机器学习^[https://www.amazon.cn/dp/B007TSFMTA/ref=sr_1_1?ie=UTF8&amp;qid=1514031854&amp;sr=8-1&amp;keywords=%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95]》 部分内容和徐亦达老师在油管上的教程^[https://www.youtube.com/watch?v=Ji6KbkyNmk8&amp;list=PLyAft-JyjIYoc9LN241WKqLPuggfSBBpt]。并且这里的隐马尔可夫模型主要是指**离散形式的动态模型**。 隐马尔可夫模型主要是一种可用于标注问题的统计学习模型，描述由隐藏的马尔可夫链随机生成观测序列的过程，属于生成模型。近些年来主要用于语音信号处理，自然语言处理，生物信息，金融分析等领域，该教程涉及很多概率计算问题，所以希望读者能够有概率背景的情况下，阅读更佳。 本部分主要介绍一下几个部分： HMM现象 马尔可夫过程/链 算法 直接计算法 前向-后向算法 前向算法 后向算法 学习算法 总结 HMM现象\begin{figure}[htbp]\begin{center} \includegraphics[width=0.6\textwidth]{hmm4.png} \caption{HMM现象}\label{figure:hmm}\end{center}\end{figure} 玩股票的朋友都知道，图\ref{figure:hmm}右，在市场规则下，股民只知道股票的涨停和不变这三种表面现象，而人们并不希望仅仅知道市场的涨停，而是想知道市场隐藏的信息，比如现在股票市场是熊市还是牛市，因为知道这些隐藏的信息之后，我们可以利用这些信息去长期跟进还是及时退出，以防市场大变。在这里我们称这种人们表面上能观察出来的现象为观测（observation），而那些隐藏的变量被称作状态。 有了上面比较直观的介绍以后，我们就可以定义什么是隐马尔可夫模型了。 定义10.1（隐马尔可夫模型） 隐马尔可夫模型是关于时序的概率模型，描述由一个隐藏的马尔可夫链随机生成不可观测的状态随机序列，再由各个状态生成一个观测而产生观测随机序列的过程。隐藏的马尔可夫链随机生成的状态的序列，称为状态序列（state sequence）；每个状态生成一个观测，而由此产生的观测的随机序列，称为观测序列（observation sequence）。序列的每一个位置又可以看作是一个时刻。 比如：上图的Bull-&gt;Bear-&gt;Event就是其中一个状态序列，而其产生的观测形成的序列up-&gt;down-&gt;unchange被称作观测序列，而这些序列在一定假设下，具有非常好的概率性质。 马尔可夫链\begin{figure}[htbp]\begin{center} \includegraphics[width=0.6\textwidth]{markov.png} \caption{HMM的概率图模型}\label{figure:markov}\end{center}\end{figure} 上图\ref{figure:markov}是隐马尔可夫的概率图模型，概率图反应了事件的依赖和独立关系。 首先我们要说明q表示状态，不可观测。y表示可观测的现象。假设状态与状态之间、状态与观测现象之间均满足马尔可夫过程，其中该过程要求具备“无记忆”的性质（马尔可夫性质）：下一状态的概率分布只能由当前状态决定，在时间序列中前面的事件均与之无关。 用数学语言表示为： $$\Pr(XNaN=x\mid X{1}=x{1},X{2}=x{2},\ldots ,X{n}=x{n})=\Pr(XNaN=x\mid X{n}=x{n})$$ 那么根据概率图模型，我们得出了两个重要的公式： 离散状态转移概率：$$p(q_t |q1, . . . , q{t−1}, y1, . . . , y{t−1}) = p(qt |q{t−1})$$ 离散/连续观测概率：$$p(y_t |q1, . . . , q{t−1}, y1, . . . , y{t−1}) = p(y_t |q_t )$$ 那么有了这个公式我们可以计算出图\ref{figure:markov}的转移概率矩阵，计算过程见图\ref{figure:hmm2}\begin{figure}[htbp]\begin{center} \includegraphics[width=0.6\textwidth]{hmm2.png} \caption{状态转移概率计算}\label{figure:hmm2}\end{center}\end{figure} $A$是状态转移概率矩阵,$A$描述了状态之间转换关系及其分布。 其中$a{ij}=P(i{t+1}=qj|i{t}=q_i),\; \; i=1,2,…,N;j=1,2,…,N;$， 是在时刻$t$处于状态$q_i$的条件下在时刻$t+1$转移到状态$q_j$ 的概率。 同样地，我们可以计算出观测概率矩阵，具体计算过程见\ref{figure:hmm3}\begin{figure}[htbp]\begin{center} \includegraphics[width=0.6\textwidth]{hmm3.png} \caption{观测概率的计算}\label{figure:hmm3}\end{center}\end{figure} $B$是观测概率矩阵, 其中$bj(k)=P(o{t}=vk|i{t}=q_j)\; \; k=1,2,…,M;j=1,2,…,N;$， 是在时刻$t$处于状态$q_j$的条件下生成观测$v_k$的概率。 有了这些性质之后我们就可以计算观测序列的概率了。比如利用图\ref{figure:hmm2}和图\ref{figure:hmm3}计算$Pr(y_1=up, y_2 = up, y_3=down)$的概率. \begin{align}P(y_1,y_2,y3) &amp;= \sum{q1=1}^{k} \sum{q2=1}^{k} \sum{q_3=1}^{k} P(y_1,y_2,y_3,q_1,q_2,q3) \&amp;= \sum{q1=1}^{k} \sum{q2=1}^{k} \sum{q_3=1}^{k} P(y_3|y_1,y_2,q_1,q_2,q_3)P(y_1,y_2,q_1,q_2,q3) \&amp;= \sum{q1=1}^{k} \sum{q2=1}^{k} \sum{q_3=1}^{k} P(y_3|q_3)P(y_1,y_2,q_1,q_2,q3) \&amp;= \sum{q1=1}^{k} \sum{q2=1}^{k} \sum{q_3=1}^{k} P(y_3|q_3)P(q_3|y_1,y_2,q_1,q_2)P(y_1,y_2,q_1,q2) \&amp;= \sum{q1=1}^{k} \sum{q2=1}^{k} \sum{q_3=1}^{k} P(y_3|q_3)P(q_3|q_2)P(y_1,y_2,q_1,q2) \&amp;= \sum{q1=1}^{k} \sum{q2=1}^{k} \sum{q_3=1}^{k} P(y_3|q_3)P(q_3|q_2)P(y_2|y_1,q_1,q_2)P(y_1,q_1,q2) \&amp;= \sum{q1=1}^{k} \sum{q2=1}^{k} \sum{q_3=1}^{k} P(y_3|q_3)P(q_3|q_2)P(y_2|q_2)P(y_1,q_1,q2) \&amp;= \sum{q1=1}^{k} \sum{q2=1}^{k} \sum{q_3=1}^{k} P(y_3|q_3)P(q_3|q_2)P(y_2|q_2)P(q_2|q_1)P(y_1|q_1)P(q_1)\end{align} 但是发现除了A和B我们已知，还无法计算$P(y_1,y_2,y_3)$，还需要知道$P(q_1)$的分布情况，所以在这里引出了另外一个条件，$P(q_1)$的分布。也就是初始状态概率。为了符号化，这里$\pi$是初始状态概率向量$\pi = (\pi_i)$： 其中$\pi_i = P(i_1 = q_i)$， 是时刻t＝1处于状态$q_i$ 的概率。 总结：隐马尔可夫模型由初始状态概率向量$\pi$、状态转移概率矩阵$A$和观测概率矩阵$B$决定。$\pi$和$A$决定状态序列，$B$决定观测序列。因此，隐马尔可夫模型$\lambda$可以用三元符号表示，即$$\lambda=(A,B,\pi)$$$A$,$B$,$\pi$称为隐马尔可夫模型的三要素。 算法HMM的三个基本计算问题：\begin{align} &amp;\text{Evaluate} \; \; p(Y|\lambda) \ &amp;\lambda{MLE} = \text{argmax}{\lambda}p(Y|\lambda) \ &amp;\text{argmax}_Q p(Y|Q,\lambda)\end{align} 直接计算法首先解决第一个问题，$\text{Evaluate} \; \; p(Y|\lambda)$, \begin{align}P(Y|\lambda) &amp;= \sum{Q}[p(Y,Q|\lambda)] =\sum{q1=1}^{k} …, \sum{q_T=1}^{k} [p(y_1,…,y_T,q_1,…,qT|\lambda)] \&amp;=\sum{q1=1}^{k} …, \sum{q_T=1}^{k} [p(y_1,…,y_T,q_1,…,qT|\lambda)] \&amp;= \sum{q1=1}^{k} …,\sum{q_3=1}^{k} p(q_1)p(y_1|q_1)p(q_2|q_1)…p(qt|q{t-1}p(y_t|qt))\&amp;= \sum{q1=1}^{k} …,\sum{q_3=1}^{k} \pi(p1)\amalg{t=2}^{T}a{q{t-1},qt}b{q_t}(y_t)\end{align} 其中:\begin{align}p(qt = j|q{t−1} = i) &amp;\equiv a_{i,j} \p(y_t |q_t = j) &amp;\equiv bj (y_t)\end{align}但是，利用上面公式计算量很大，是$O(TN^T)$阶的，这种算法不可行。 前向-后向算法前向算法定义10.2（前向概率） 给定隐马尔可夫模型，定义到时刻t部分观测序列为$o_1,o_2,…,o_t$且状态为$q_i$的概率为前向概率，记作$$\alpha_t(i)=P(o_1,o_2,…,o_t,i_t=q_t|\lambda)$$ 下面是前向算法的概率图模型。 \begin{figure}[htbp]\begin{center} \includegraphics[width=0.6\textwidth]{forward.png} \caption{前向算法的概率图模型}\label{figure:forward}\end{center}\end{figure} 前向过程：$$\alpha_t(i)=P(o_1,o_2,…,o_t,i_t=qt|\lambda) \Longrightarrow p(Y|\lambda) = \sum{i=1}^{k} \alpha_i(T)$$ 递推:对$t＝1,2,…，T-1$， \begin{align}\alpha_i(1) &amp;= p(y_1,q_1=i|\lambda) = p(q_1)p(y_1|q_1)=\pi_i b_i(y_1) \\alpha_j(2) &amp;= p(y_1,y_2,q2=j|\lambda) = \sum{i=1}^{k}p(q_1=i)p(y1|q_1=i)p(q_2 = i | q_1 = i)p(y_2 | q2 = j) \&amp;= [\sum{i=1}^k \alphai(1)\alpha{i,j}]b_j(y_2) = p(q_1)p(y_1|q_1)=\pi_ib_i(y_1) \&amp;… \\alphaj(t+1) &amp;=[\sum{i=1}^k \alphai(t)\alpha{i,j}]bj(y{t+1}) \&amp;… \\alphaj(T) &amp;=[\sum{i=1}^k \alphai(T-1)\alpha{i,j}]bj(y{T})\end{align} 后向算法定义10.3（后向概率） 给定隐马尔可夫模型，定义在时刻t状态为$qi$的条件下，从t+1到T的部分观测序列为$o{t+1}$,$o_{t+2}$,…,$o_T$的概率为后向概率，记作$$\betat(i)=P(o{t+1},o{t+2},o{t+3},…,o_T|i_t=q_i,\lambda)$$ 可以用递推的方法求得后向概率$\beta_t(i)$及观测序列概率$P(O|\lambda)$。$$\betai (t) = p(y{t+1}, . . . , y_T |q_t = i, \lambda)$$下面是后向算法的概率图模型。 \begin{figure}[htbp]\begin{center} \includegraphics[width=0.6\textwidth]{backward.png} \caption{后向算法的概率图模型}\label{figure:backward}\end{center}\end{figure} 后向过程：$$\betai (t) = p(y{t+1}, . . . , y_T |qt = i, \lambda) \Longrightarrow \sum{i=1}^k \beta_i(1)\pi_ib_i(y_1)=p(Y|\lambda)$$ 迭代过程： \begin{align}\beta_i(T) &amp;= 1 \\beta_i(T-1) &amp;= p(yT|q{T-1} = i) = \sum_{j=1}^kp(qT=j|q{T-1}=i)p(y_T|qT=j)=\sum{j=1}^{k}a_{i,j}b_j(T) \\beta_i(T-2) &amp;= p(yT,y{T-1}|q{T-2} = i) \&amp;= \sum{j=1}^k \sum_{l=1}^k p(qT=l|q{T-1}=j)p(y_T|qT=l) p(q{T-1}=j|q{T-2}=i)p(y{T-1}|q{T-1}=j)\&amp;=\sum{j=1}^{k}a_{i,j}bj(y{T-1})\beta_j(T-1) \&amp;…\\betai(t) &amp;=\sum{j=1}^k\alpha_{i,j}b_j(y_t+1)\beta_j(t + 1) \&amp;…\\betai(1)&amp;=\sum{j=1}^k\alpha_{i,j}b_j(y_2)\beta_j(2)\end{align} 在时刻t处位于序列$Y$状态$q_i$时的概率： $$p(q_t = i|Y,\lambda) = \frac{p(Y, q_t = i|\lambda)}{p(Y|\lambda)}=\frac{p(Y, qt = i|\lambda)}{\sum{j=1}^{k}p(Y, q_t =j|\lambda)}= \frac{\alpha_i(t)\betai{t}}{\sum{j=1}^{k}\alpha_j(t)\beta_j(t)}$$ \begin{align}p(Y, q_t = i|\lambda) &amp;= p(Y|q_t = i)p(q_t = i)\&amp;= p(y_1, . . . y_t |qt = i)p(y{t+1},… y_T |q_t = i)p(q_t = i) \&amp;= p(y_1, . . . y_t , qt = i)p(y{t+1},… y_T |q_t = i) \&amp;= \alpha_i(t)\beta_i(t)\end{align} 学习算法后期更新，主要讲解学习算法之EM算法，利用EM算法来学习未知参数。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[机器学习简介]]></title>
      <url>%2F2017%2F12%2F21%2F2017-12-21-introduction-machine-learning%2F</url>
      <content type="text"><![CDATA[\noindent 该笔记是来自 Andrew Ng 的 Machine Learning 课程的第一周的课堂记录，主要讲解了以下几个内容: 机器学习的定义 机器学习的分类 第一类：监督学习 第二类：学习理论 第三类：非监督学习 第四类：强化学习 什么是机器学习？非正式定义1959年， Arthur Samuel^[发明了西洋棋程序]非正式地定义了机器学习：“在不直接针对问题进行编程的情况下，赋予计算机学习能力的一个研究领域”。 西洋棋就是一个例子，西洋棋自己和自己下棋。由于计算机程序的处理速度非常快，所以Arthur Samuel让计算机与计算机自己下了成千上万盘棋，逐渐地，西洋棋意识到了怎样的局势能使自己胜利，什么样的局势导致自己失败，它会反复地自我学习：“如果让对手占据这些地方时，那么我输的概率可能比较大”，或者“如果我占据这些地方时，我胜利的概率比较大”。在1959年，奇迹出现，他的西洋棋程序的棋艺远远超过西洋棋程序的作者！ 过去人们的看法是计算机除了做程序明确让其做的事情，除外它什么都不能做，但是Arthur Samuel做到了！ 现代化的定义Tom Mitchell在1998年提出现代化的机器学习的定义：“一个合理的学习问题应该是这样定义的：对于一个计算机程序来说，给它一个任务$T$和一个性能评测方法$P$，如果在经验$E$的影响下，$P$对$T$的测量结果得到了改进，那么就说明程序从中学习到了经验$E$. 比如对于西洋棋那个例子来说： $E$ - 程序成千上万次的自我练习 $T$ - 下棋 $P$ - 它与人类棋手对奕的概率 监督学习回归问题下面是给予一组房屋大小与对应的房屋价格的数据进行拟合的例子： \begin{figure}[htbp]\begin{center} \includegraphics[width=0.8\textwidth]{price_prediction.png} \caption{房屋价格预测模型}\label{figure:price_prediction}\end{center}\end{figure} 通过学习来预测房屋价格的问题是监督学习问题的一个例子，之所以成为监督学习，是因为我们这个算法提供了一组房屋的大小($size$)和一组某种程度上可以堪称正确答案的房屋价格$Price$的数据。比如(1000, 30)等。 监督问题的学习，给算法提供了一组”正确“的输入和”标准“答案，之后，我们希望算法能够去学习标准输入和标准答案之间的联系，以尝试对于我们提供的其他输入来给我们提供更为标准的答案。 分类问题分类问题是监督学习问题中的另一类问题，它与回归问题最大的区别在于，此时的数据是离散的我而不是连续的. 下面是给予肿瘤的大小和对应的肿瘤是否是恶性（1）或者良性（0），来进行拟合学习最佳的分类决策线。其中 数据是一组关于乳腺癌的数据，$X$代表肿瘤的大小，$Y$代表肿瘤的是否为恶性 目标是让一个算法学会预测一个肿瘤是否是恶性或良性 很显然，这是一个2分类问题。具体如图2所示：\begin{figure}[htbp]\begin{center} \includegraphics[width=0.8\textwidth]{tumor_classifict.png} \caption{肿瘤恶性/良性分类模型}\label{tumor_classifict}\end{center}\end{figure} 下面考虑一组多个输入变量（多个特征）的数据，下面以两个特征进行举例说明。其中$X$表示肿瘤的大小，$Y$表示患者的年龄，对于图中的样本数据的表示进行说明：’o’表示良性，’x’表示为恶性，目标是找出最佳的分类决策边界。如图3所示：\begin{figure}[htbp]\begin{center} \includegraphics[width=0.5\textwidth]{tumor_classifict_2.png} \caption{多特征的肿瘤恶性/良性分类模型}\label{tumor_classifict_2}\end{center}\end{figure} 如果你的数据不能在二维，三维甚至任何有限维空间表示出来，如果你觉得数据实际上存在于无线维空间中该怎么办？ solution:支持向量机算法^[kernel method]，可以将数据映射到无限维空间，所以他不仅能处理像之前例子中的两个特征所表示的数据，而且还可以处理无限种特征. 学习理论学习理论主要主要试图了解一下什么算法能够很好地近似不同的函数，并且试图了解一些诸如需要多少训练集数据，测试集数据这样的问题，还比如算法优化，欠拟合和过拟合等问题。 无监督学习\begin{figure}[htbp]\centering %居中\subfigure[一些样本数据]{ %第一张子图\begin{minipage}{7cm}\centering %子图居中\includegraphics[scale=0.3]{unsupervised_1.png} %以pic.jpg的0.5倍大小输出\end{minipage}}\subfigure[聚类之后]{ %第二张子图\begin{minipage}{7cm}\centering %子图居中\includegraphics[scale=0.3]{unsupervised_2.png} %以pic.jpg的0.5倍大小输出\end{minipage}}\caption{你能在这组数据中寻找一些有趣的结构吗？} % %大图名称\label{figure:unsupervised} %图片引用标记\end{figure} 一个算法会寻找这样的结构（如图\ref{figure:unsupervised}）,它会将里面的数据聚成两类，”聚类问题“就是无监督学习的一个典型问题。主要应用： 无监督学习尝试理解基因数据，会按照基因在实验中体现出的形状的规律，来对单独的基因数据进行分类。 google news尝试对新闻进行聚类。 聚类算法处理图像问题 特定的无监督学习算法，它会学习对这些像素进行聚类，就是说，这些像素可能是在一起的，那些像素可能是在一起的。对像素进行的分组，他们对于计算机视觉和图像处理领域都很有用。 \begin{figure}[htbp]\centering %居中\subfigure[对单独的基因进行分类]{ %第一张子图\begin{minipage}{7cm}\centering %子图居中\includegraphics[scale=0.3]{gene.png} %以pic.jpg的0.5倍大小输出\end{minipage}}\subfigure[google news对新闻数据进行聚类]{ %第二张子图\begin{minipage}{7cm}\centering %子图居中\includegraphics[scale=0.25]{google_news.png} %以pic.jpg的0.5倍大小输出\end{minipage}}\caption{应用} % %大图名称\label{figure:cluster} %图片引用标记\end{figure} 还有一些例子，比如计算机集群，社会网络分析，市场划分，航天数据分析等等都会用到无监督学习。另外还有在语音识别方面的经典问题鸡尾酒会问题. 强化学习他可以用在一些你不需要进行一次决策的情形中，比如，利用监督学习对癌症进行预测的例子中，对于一个病人，你要预测他的肿瘤是否为恶性，那么你的预测将会决定病人的生死，也就是说，你的决策要么对要么错。那么对于强化学习来说，他主要使用了一种叫做回报函数的概念来进行决策，不像监督学习那样一次性决策，它是探索性算法它常常用于机器人领域，网页爬取等领域。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[单变量线性回归]]></title>
      <url>%2F2017%2F12%2F21%2F2017-12-21-single-variable-linear-regression%2F</url>
      <content type="text"><![CDATA[\noindent 该笔记是来自 Andrew Ng 的 Machine Learning 课程的第二周:单变量线性回归的课堂记录，主要讲解了以下几个内容: 代价函数 梯度下降算法 模型表达还是上一个关于房屋价格预测的例子，给你一组房屋的大小和对应房屋的价格的数据，让你对数据进行建模，使得对于其他的房屋的大小更好的拟合出更准确的价格出来。如图1所示。\begin{figure}[htbp]\begin{center} \includegraphics[width=0.5\textwidth]{single_ex_1.png} \caption{房屋价格预测模型}\label{figure:single_ex_1}\end{center}\end{figure} 图 1: 房屋价格预测模型 题外话：首先数据是一组关于标准输入与标准答案的数据集，那么对该数据进行建模，是属于监督学习任务。又因为数据只含有一个变量（$size$）即一个特征，且找到一条直线来拟合数据集，所以该问题又被称为单变量线性回归问题。 图2是部分的样本数据，其中$X$表示房屋的大小，$Y$表示对应房屋的价格。\begin{figure}[htbp]\begin{center} \includegraphics[width=0.5\textwidth]{s_data.png} \caption{数据}\label{figure:s_data}\end{center}\end{figure} 图 2: 数据为了后面更好的描述，所以对一些符号进行声明：- $m$ 训练集中实例的数量- $x’s$ 输入变量或者特征- $y’s$ 输出变量或目标变量- $(x,y)$ 一个训练样本- $(x^{(i)},y^{(i)})$ 第$i$个训练样本\end{itemize}有了数据之后，可以用下图就可以描述房屋价格预测问题建模的过程。\begin{figure}[htbp]\begin{center} \includegraphics[width=0.5\textwidth]{procedure.png} \caption{建模的过程}\label{figure:precedure}\end{center}\end{figure}图 3: 建模的过程图片描述：因而解决房屋价格预测问题，实际上就是要将训练集”喂给“我们的学习算法，进而学习到一个假设$h$，然后将要预测的房屋尺寸作为输入变量输入给$h$，预测出该房屋的交易价格作为输出结果。其实$h$就是一个我们要学习的函数。我们如何表示函数呢？对于单变量线性回归问题来说，$h{\theta}(x) = \theta{0} + \theta{1} x$.# 代价函数## 引入代价函数有了训练数据，也有了模型的表示$h$，但是问题是如何选择 $\theta{0}$ 和 $\theta{1}$ ?基本想法是选择$\theta{0}$，$\theta{1}$以使得在训练集上$h{\theta}(x)$接近$y$.用数学表达式表示出来，如下：$$minimize{\theta{0},\theta{1}}\frac{1}{2m}\sum{i=1}^{m}(h{\theta}(x^{(i)})- y^{(i)})^{2}$$注意： 在学习的时候，有一个区别，$loss function$描述的是单个样本误差，而$cost$ $function$描述整个训练集的误差。同样地，为了更好的下文描述，将其简化：$$J(\theta{0},\theta{1}) = \frac{1}{2m}\sum{i=1}^{m}(h{\theta}(x^{(i)})- y^{(i)})^{2}$$Goals: $$ minimize_{\theta{0},\theta{1}}J(\theta_{0}, \theta_{1})$$其中$J(\theta{0}, \theta{1})$是平方误差（代价）函数，它是解决回归问题常用的手段。## 代价函数$J$的工作原理- 假说函数: $h{\theta}(x) = \theta{0} + \theta{1}x$- 参数：$\theta{0}, \theta{1}$- 代价函数：$J(\theta{0},\theta{1}) = frac{1}{2m}\sum{i=1}^{m}(h{\theta}(x^{(i)})- y^{(i)})^{2}$- 目标：$minimize{\theta{0},\theta{1}}J(\theta{0}, \theta{1})$简化来讲，就是找到使得误差最小的那一对参数（$\theta{0}, \theta{1}$).\begin{figure}[htbp] \begin{center} \includegraphics[width=0.8\textwidth]{cost.png} \caption{代价函数工作原理}\label{figure:cost} \end{center}\end{figure}图 4: 代价函数工作原理## 代价函数的直观理解引入一种表示方法：轮廓图。我们在三维空间来表示（$\theta{0}, \theta{1}, J(\theta{0}, \theta{1})$)，如图\ref{figure:contour}\begin{figure}[htbp] \begin{center} \includegraphics[width=0.5\textwidth]{contour.png} \caption{轮廓图}\label{figure:contour} \end{center}\end{figure}图 5: 轮廓图可以直观地得到以下结论：在曲面的最低的那个点对应的代价误差最小，对应的（$\theta{0}, \theta{1}$)是我们要找的参数组合。还有一种表示方法：等高线图，他的工作原理是，每一圈上的值都是相等的，即对应的代价误差是相同的。从外到里，代价不断减小，最里面的是最小的代价误差，也是我们算法要最终学习到的点。如图\ref{figure:contour_2}\begin{figure}[htbp] \begin{center} \includegraphics[width=0.5\textwidth]{contour_2.png} \caption{等高线图}\label{figure:contour2} \end{center}\end{figure}图 6: 等高线图# 梯度下降算法## 算法描述我们很迫切想求得最佳拟合参数（$\theta{0}, \theta{1}$），但是有不想通过枚举的方式求得，因此需要一个算法能够自动求出使得代价函数$J(\theta{0}, \theta{1})$取得最小值的参数$\theta{0}, \theta_{1}$.所以在这里引入梯度下降算法。主要思想是想象你在一个山丘上，怎么样以最快的速度从山上到山脚下？在这里就引入了梯度的概念，即下降速度最快的方向，所以人没走一步就检查一下，当前是否为下降最快的方向？若不是则将重新求梯度，按照梯度指示的方向走，则为最快的方式！将这种思想应用到求使得代价误差函数最小，也是这么做的。但是这样往往带来几个问题？1. 以多大的脚步往下走，因为如果脚步过大，则会造成错过最佳的下山路线。（学习速率选择问题）2. 由于不一定你的目标函数是凸函数，所以每次走可能走到不同”的山脚“。（局部最小值，凸优化问题）如图\ref{figure:gradient}这些问题将会在后面一一解决！\begin{figure}[htbp]\centering %居中\subfigure[梯度下降]{ %第一张子图\begin{minipage}{7cm}\centering %子图居中\includegraphics[scale=0.3]{gradient_intu.png} %以pic.jpg的0.5倍大小输出\end{minipage}}\subfigure[走到局部最低点]{ %第二张子图\begin{minipage}{7cm}\centering %子图居中\includegraphics[scale=0.3]{gradient_intu2.png} %以pic.jpg的0.5倍大小输出\end{minipage}}\caption{梯度下降算法} % %大图名称\label{figure:gradient} %图片引用标记\end{figure}下面是梯度下降算法的为伪代码。\begin{algorithm}[h] \caption{梯度下降算法简化版} \label{alg::Gradient Descent Simple} \begin{algorithmic}[1] \Require $\alpha$ 学习率; $\theta{0} \in R, \theta{1}\in R$ 参数; $J$ 代价误差函数; $:=$ 赋值; \Repeat \State $\theta{j} := \theta{j} - \alpha\frac{\partial}{\partial{j}}J(\theta{0}, \theta{1})$ for $j = 0 $和$j = 1 $; \State (向量版本)$\theta := \theta - \alpha\nabla J(\theta{0}, \theta{1})$; \Until{收敛} \end{algorithmic}\end{algorithm} 下图\ref{figure:gradient_change_theta} 直观的描述$\theta$是如何变化的.这里$\alpha &gt; 0$. \begin{figure}[htbp]\centering %居中\subfigure[$\frac{\partial}{\partial{\theta{1}}}J(\theta{0}, \theta{1}) &gt; 0$时，$\theta_{1}$往右移动]{ %第一张子图\begin{minipage}{7cm}\centering %子图居中\includegraphics[scale=0.5]{gradient_changetheta.png} %以pic.jpg的0.5倍大小输出\end{minipage}}\subfigure[$\frac{\partial}{\partial{\theta{1}}}J(\theta{0}, \theta{1}) &lt; 0$时，$\theta{1}$往左移动]{ %第二张子图\begin{minipage}{7cm}\centering %子图居中\includegraphics[scale=0.5]{gradient_change_theta_1.png} %以pic.jpg的0.5倍大小输出\end{minipage}}\caption{代价误差不断接近最低处} % %大图名称\label{figure:gradient_change_theta} %图片引用标记\end{figure} 学习率$\alpha$学习率在算法迭代时起着很大的作用。\begin{enumerate}\setlength{\itemsep}{1pt}\setlength{\parsep}{0pt}\setlength{\parskip}{0pt} 如果$\alpha$过小，将会导致算法的收敛速度很慢，算法的效率低; 如果$\alpha$过大，在梯度下降过程中，很容易掠过最小值，可能会无法收敛甚至发散。如图\ref{figure:alpha}.\end{enumerate} \begin{figure}[htbp]\centering %居中\subfigure[$\alpha$过小，导致收敛速度很慢]{ %第一张子图\begin{minipage}{7cm}\centering %子图居中\includegraphics[scale=0.5]{alpha_low.png} %以pic.jpg的0.5倍大小输出\end{minipage}}\subfigure[$\alpha$过大，导致无法到达最低点]{ %第二张子图\begin{minipage}{7cm}\centering %子图居中\includegraphics[scale=0.5]{alpha_high.png} %以pic.jpg的0.5倍大小输出\end{minipage}}\caption{不同的$\alpha$对算法收敛的影响} % %大图名称\label{figure:alpha} %图片引用标记\end{figure} 虽然选择的是合适的$alpha$，但是算法还是会掉到局部最小值，对于局部最小值的描述如图\ref{figure:local_minimize} \begin{figure}[htbp] \begin{center} \includegraphics[width=0.6\textwidth]{local_minimize.png} \caption{局部最小值}\label{figure:local_minimize} \end{center}\end{figure} 在算法迭代时，随着逐渐接近最小值，步子会慢慢地变小，直到接近最小值。所以在算法的迭代过程中不需要对$\alpha$改变。 \subsubsection{算法详细版} 假说函数: $h{\theta}(x) = \theta{0} + \theta_{1}x$ 参数：$\theta{0}, \theta{1}$ 代价函数：$J(\theta{0},\theta{1}) = \frac{1}{2m}\sum{i=1}^{m}(h{\theta}(x^{(i)})- y^{(i)})^{2}$ 目标：$minimize{\theta{0},\theta{1}}J(\theta{0}, \theta_{1})$ 求解：$\theta{j} := \theta{j} - \alpha \frac{\partial}{\partial{\theta{j}}} J(\theta{0}, \theta{1})$ for $j=0$ 和 $j=1$ 结合上面的公式可以求得$$ \theta{0} := \theta{0} - \alpha \frac{1}{m} \sum{i=1}^{m}(h{\theta}(x^{(i)}) - y^{(i)})$$$$ \theta{1} := \theta{1} - \alpha \frac{1}{m} \sum{i=1}^{m}(h{\theta}(x^{(i)}) - y^{(i)})x^{(i)}$$ 算法的伪代码如下： \begin{algorithm}[h] \caption{梯度下降算法简化版} \label{alg::Gradient Descent Simple} \begin{algorithmic}[1] \Require $\alpha$ 学习率; $\theta{0} \in R, \theta{1}\in R$ 参数; $:=$ 赋值; \Repeat \State $\theta{0} := \theta{0} - \alpha \frac{1}{m} \sum{i=1}^{m}(h{\theta}(x^{(i)}) - y^{(i)})$; \State $\theta{1} := \theta{1} - \alpha \frac{1}{m} \sum{i=1}^{m}(h{\theta}(x^{(i)}) - y^{(i)})x^{(i)}$; \Until{收敛} \end{algorithmic}\end{algorithm} 由于代价误差函数是二次函数，二次项为负所以图像为“弓（拱）”形，所以是凸函数，所以算法总能收敛到全局最小值. 由于训练的过程中，将全部的训练数据喂给我们的模型，所以该过程又称“批量训练过程”.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[过拟合和正则化]]></title>
      <url>%2F2017%2F12%2F21%2F2017-12-21-overfitting%2F</url>
      <content type="text"><![CDATA[\noindent 该笔记是来自 Andrew Ng 的 Machine Learning 课程的第三周:多分类和过拟合技术的课堂记录，过拟合是机器学习优化的部分，主要讲解了以下几个内容: 多类别的分类问题 过/欠拟合问题 解决过拟合的方法 正则化方法 多类别的分类问题在现实生活中多类别的问题更常见，比如： Email:邮件的自动分类，e.g. work,friends,family,hobby 医疗诊断：Notil,Cold,Flu 天气预测：Sunny,Cloudy,Rain,Snow 在涉及到多分类问题，我们往往采取一种“One VS All”算法！在二分类问题上$Y = {0,1}$，在多分类上，我们将扩大$Y$的定义，即$Y = {0,1,…,n}$。多分类的任务转化为$n + 1$个（+ 1因为索引从0开始）二分类问题；在每一个二分类任务，预测的“$Y$”是一个类概率。 \begin{align}&amp; y \in \lbrace0, 1 … n\rbrace \&amp; h\theta^{(0)}(x) = P(y = 0 | x ; \theta) \&amp; h\theta^{(1)}(x) = P(y = 1 | x ; \theta) \&amp; \cdots \&amp; h_\theta^{(n)}(x) = P(y = n | x ; \theta) \&amp; \mathrm{prediction} = \maxi( h\theta ^{(i)}(x) )\end{align} 我们基本上是选择其中一个类别的数据作为positive，然后将所有其他的类别数据为negative，这样将问题转化为一个二分类问题，反复这样做，对每一种情况应用二元logistic回归，然后将所有情况中预测的最高的那个类作为我们的预测。下图\ref{figure:onevsall} 显示了如何将3个类进行分类： 对于每一个类训练一个二元逻辑回归分类器来预测$y=1$的概率. 对于一个新的测试样本x，选择$h_{\theta}$最大的那一个类. 过/欠拟合问题机器学习的目的不仅仅对训练集的拟合效果好，在测试集上我也要达到一样好！所以往往在机器学习建模时往往出现过拟合问题，就是对训练数据的预测达到100\%，但是在测试集上的效果很差！还有一种情况就是在训练集上的效果低，这叫欠拟合问题，如图所示 考虑$x \in \mathbb{R}$预测$y$的问题。上图\ref{figure:overfit}的最左边的图显示了$y = \theta_{0} + \theta_1 x$拟合数据集$\mathrm{X}$的结果。我们看到数据不是真的在直线上，所以拟合程度不是很好。相反，如果我们添加了一个额外的特征$x^2$，用$y = \theta_0 + \theta_1x + \theta2x^2$来拟合$y$,那么我们获得一个稍微更好的数据拟合（见中图）。看起来添加的特征越多越好，然而，增加太多特征也有一个危险：最右边的图是拟合5阶多项式$y = \sum{j=0} ^5 \theta_j x^j$的结果，可以看到即使曲线完美地拟合了所有数据，但是也不会是个很好的模型。左边的图片是一个欠拟合的例子，而右侧的图就是过拟合的例子。 欠拟合（高偏差，低方差），它通常是由于假说函数过于简单或使用的特征太少而造成的。另一个极端，过拟合(低偏差，高方差)，它通常是由一个复杂的假说函数或者特征太太多引起的，而导致模型不能很好的泛化^[泛化指一个假设模型能够应用到新的样本数据的能力]。 解决过拟合问题两个主要策略： 减少特征数量 人工检查变量的数目，决定哪些变量重要，哪些变量不重要. 模型选择算法 正则化 当我们有很多特征变量时，其中每一个变量都能对预测产生一点影响. 保留所有特性，但减少参数$\theta_j$的大小 修改代价函数如果模型（假设/说函数）出现过拟合，我们可以减轻部分权重$\theta_j$，进而增加他们的代价。比如说，我们想让下面的函数看起来更加像二次方程 \begin{align}&amp;\theta_0 + \theta_1x + \theta_2x^2 + \theta_3x^3 + \theta_4x^4\end{align} 所以我们减弱$\theta_3x^3$和$\theta4x^4$的影响.实际上, 如果不去掉这些特征或者改变假设函数$h{\theta}(x)$的形式, 我们可以改变我们的代价函数： \begin{align}&amp;min\theta\ \dfrac{1}{2m}\sum{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})^2 + 1000\cdot\theta_3^2 + 1000\cdot\theta_4^2\end{align} 在公式后面增加了两项用来增加$\theta_3$和$\theta_4$的代价，为了使得我们的代价函数接近0,所以不得不将$\theta_3$和$\theta_4$的值接近于0。在假说函数中，将大大降低$\theta_3x^3$和$\theta_4x^4$的值。因此,可以看到新的假设 (由粉红色曲线描述) 看起来更像一个二次函数,并且也更好的拟合我们训练数据。 我们还可以将所有的$\theta$参数求和来进行正则化处理,在代价函数最后增加一个正则项 $\lambda \sum_{j=1}^n \thetaj^2$，其中$\lambda$是一个正则化参数（超参数）.如下所示.\begin{align*}&amp;min\theta\ \dfrac{1}{2m}\ \sum{i=1}^m (h\theta(x^{(i)}) - y^{(i)})^2 + \lambda\ \sum_{j=1}^n \theta_j^2\end{align*} 给线性回归模型增加正则项Gradient Descent For Fixed Linear Regression\begin{align}&amp; \text{Repeat}\ \lbrace \&amp; \ \ \ \ \theta_0 := \theta0 - \alpha\ \frac{1}{m}\ \sum{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})x_0^{(i)} \&amp; \ \ \ \ \theta_j := \thetaj - \alpha\ \left[ \left( \frac{1}{m}\ \sum{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})x_j^{(i)} \right) + \frac{\lambda}{m}\theta_j \right] &amp;\ \ \ \ \ \ \ \ \ \ j \in \lbrace 1,2…n\rbrace\&amp; \rbrace\end{align} 其中上面的$\theta_j$的更新公式也可以这样写：$$\theta_j := \thetaj(1 - \alpha\frac{\lambda}{m}) - \alpha\frac{1}{m}\sum{i=1}^m(h_\theta(x^{(i)}) - y^{(i)})x_j^{(i)}$$. Normal Equation\begin{align}&amp; \theta = \left( X^TX + \lambda \cdot L \right)^{-1} X^Ty, \; \text{where}\ \ L = \begin{bmatrix} 0 &amp; &amp; &amp; &amp; \ &amp; 1 &amp; &amp; &amp; \ &amp; &amp; 1 &amp; &amp; \ &amp; &amp; &amp; \ddots &amp; \ &amp; &amp; &amp; &amp; 1 \\end{bmatrix}_{(n+1)×(n+1)}\end{align} 前面提到过,如果 $m &lt; n$, 那么 $X^TX$ 是不可逆矩阵。然而, 当我们添加$\lambda L$后 $X^TX$变得可逆了。 给逻辑回归模型增加正则项Cost Function\begin{align}J(\theta) &amp;= - \frac{1}{m} \sum{i=1}^m \large[ y^{(i)}\ \log (h\theta (x^{(i)})) + (1 - y^{(i)})\ \log (1 - h\theta(x^{(i)})) \large]\\rightarrow J(\theta) &amp;= - \frac{1}{m} \sum{i=1}^m \large[ y^{(i)}\ \log (h\theta (x^{(i)})) + (1 - y^{(i)})\ \log (1 - h\theta(x^{(i)}))\large] + \frac{\lambda}{2m}\sum_{j=1}^n \theta_j^2\end{align} 公式(2)的第二个sum项$\sum_{j=1}^n \theta_j^2$中的$\theta_j$不包括$\theta_0$! Gradient Descent For Fixed Logistic Regression}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多项式回归]]></title>
      <url>%2F2017%2F12%2F21%2F2017-12-21-polynomial-regression%2F</url>
      <content type="text"><![CDATA[\noindent 该笔记是来自 Andrew Ng 的 Machine Learning 课程的第二周:多项式回归的课堂记录，有了合适的特征之后，我们发现线性回归并不适用于所有数据，有时我们需要曲线来适应我们的数据，因此引出多项式回归模型，主要讲解了以下几个内容: 将多项式回归模型转换为线性模型 正规方程 将多项式回归模型转换为线性模型什么是多项式模型？比如一个二次模型$$h{\theta} = \theta{0} + \theta{1}x + \theta{2}x^2$$,三次模型$$h{\theta} = \theta{0} + \theta{1}x + \theta{2}x^2 + \theta_{3}x^3$$ 通常情况下，在模型进行选择时，首先要观察数据，然后再决定准备尝试什么样的模型，比如下面图\ref{figure:polynomial} 中的数据分布，我们可以通过观察可以看到，数据的分布用线性模型并不能达到很好的效果，所以在这里尝试用一个多项式模型来拟合我们的训练数据。 \begin{figure}[htbp]\begin{center} \includegraphics[width=0.6\textwidth]{polynomial.png} \caption{多项式拟合}\label{figure:polynomial}\end{center}\end{figure} 可以尝试多项式函数表示我们的模型： $$h{\theta} = \theta{0} + \theta{1}x + \theta{2}x^2$$ 或者 $$h{\theta} = \theta{0} + \theta{1}x + \theta{2}x^2 + \theta_{3}x^3$$ 或者 $$h{\theta} = \theta{0} + \theta{1}x + \theta{2}x^{\frac{1}{2}}$$ 有趣的是，如果我们对这些高次项进行替换，比如在$h{\theta} = \theta{0} + \theta{1}x + \theta{2}x^2$中，将$$x{2} := x^{2}$$将可以转换为$h{\theta} = \theta{0} + \theta{1}x + \theta{2}x{2}$，这样转换为多变量线性回归模型了。 注意：在采用多项式回归模型，运行梯度下降算法前，特征缩放非常有必要！ 正规方程目前为止，都在利用梯度下降算法进行优化我们的代价函数，但对于某些的现性回归问题，正规方程是更好的解决方案。不像梯度算法那样，求解出参数$\theta$需要进行很多次迭代才能求出，而正规方程直接一次性求出参数！其实正规方程的背后就是借助于\textbf{微积分}来做的，即通过求解下面的方程找出使得代价函数最小的参数. $$\frac{\partial}{\partial{j}}J(\theta{j}) = 0 $$ 比如：$J(\theta) = a\theta^{2} + b\theta + c$，那么通过$\frac{d}{d_{\theta}}J(\theta) = … = 0$可以求解出$\theta$来. 经验： 使用正规方程^[最小二乘解]解出向量$$\theta = (x^{T}x)^{-1}x^{T}y$$ 利用正规方程求解的例子给你一组训练数据，$m$ = 4, $n$ = 4，则$X \in \mathbb{R}^{4*5}$, $y \in \mathbb{R}^{4}$，数据如图\ref{figure:data} \begin{figure}[htbp]\begin{center} \includegraphics[width=0.6\textwidth]{data.png} \caption{数据}\label{figure:data}\end{center}\end{figure} 用矩阵可以表示为：$$X = \left[\begin{matrix}1&amp;2104&amp;5 &amp;1&amp;45\1&amp;1416&amp; 3&amp; 2&amp; 40\1&amp;1534&amp; 3 &amp;2&amp; 30 \1&amp;852&amp; 2&amp; 1&amp; 36\end{matrix}\right],y = \left[\begin{matrix}460\232\315\178\end{matrix}\right]$$ 那么就可以使用经验公式$\theta = (x^{T}x)^{-1}x^{T}y$求解了！ 警告： 往往在使用公式求解时，存在不可逆矩阵，导致求逆矩阵失败，主要原因为，特征之间不独立，如同时包含英尺为单位的尺寸和米为单位的尺寸两个特征，也有可能特征数量大于训练集大于训练集数量，正规方程方法不能用！ 梯度下降算法与正规方程的比较梯度下降算法： 不需要选择$\alpha$ 需要很多次迭代 当特征数量$n$比较大时，也能很好的适应 适应各种类型的数据 正规方程： 不需要选择$\alpha$ 一次计算即可得出结果，不需要很多次迭代 需要计算$(x^{T}x)^{-1}$运算代价大，时间效率为$O(n^3)$，但是如果n&lt;10000时可以接受！ 只适应于现行模型，不适用与逻辑回归等其他类型 不需要归一化特征变量]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在树莓派上配置AP]]></title>
      <url>%2F2017%2F12%2F21%2F2017-12-21-aphot-rpi%2F</url>
      <content type="text"><![CDATA[有了一个新的树莓派之后，如果不将它配置成AP热点，你就失去了他的其中的一个优势，如果你的家里面没有无限路由器或者你的家里信号不能遍及，树莓派是你最好的选择，利用流量包转发的优势，大大地节约了成本，并且他支持多种转发机制，这是很重要的特点，是你的网络随时处于移动状态，不像传统的路由器，如果固定到某个地方之后就不能动了，而树莓派是一个可以移动的热点。稳定是最主要的特点。 本文参考^[http://www.shenhengheng.xyz/blog/raspberry-self-driving-car-configuration-first.html]。 必需的包 hostapd dnsmasq 1sudo apt-get install dnsmasq hostapd 配置网卡将wlan1（购买的网卡）配置一个静态IP地址, 首先告诉树莓派DHCP获取IP时忽略WLAN1 1sudo nano /etc/dhcpcd.conf 在文件的最后添加： 1denyinterfaces wlan1 配置静态IP 1sudo nano /etc/network/interfaces 文件内容如下： 1234567allow-hotplug wlan1 iface wlan1 inet static address 172.24.1.1 netmask 255.255.255.0 network 172.24.1.0 broadcast 172.24.1.255# wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf 重启DHCP服务。 12sudo apt-get install dhcpcd5 #如果没有这个服务sudo service dhcpcd restart 然后重启WLAN1设备以适应配置 1sudo ifdown wlan1; sudo ifup wlan1 配置HOSTAPD文件1sudo nano /etc/hostapd/hostapd.conf 内容是： 1234567891011121314151617181920212223242526272829303132333435363738394041424344# This is the name of the WiFi interface we configured aboveinterface=wlan1# Use the nl80211 driver with the brcmfmac driverdriver=nl80211# This is the name of the networkssid=Pi3-AP# Use the 2.4GHz bandhw_mode=g# Use channel 6channel=6# Enable 802.11nieee80211n=1# Enable WMMwmm_enabled=1# Enable 40MHz channels with 20ns guard intervalht_capab=[HT40][SHORT-GI-20][DSSS_CCK-40]# Accept all MAC addressesmacaddr_acl=0# Use WPA authenticationauth_algs=1# Require clients to know the network nameignore_broadcast_ssid=0# Use WPA2wpa=2# Use a pre-shared keywpa_key_mgmt=WPA-PSK# The network passphrasewpa_passphrase=123456789# Use AES, instead of TKIPrsn_pairwise=CCMP 检查配置是否起作用： 1sudo /usr/sbin/hostapd /etc/hostapd/hostapd.conf 如果成功，则会在你的移动设备上（智能手机）上检测到Pi3-AP的路由。如果你尝试连接，则不会成功分配地址，因为还没有做完！ 因为我们还需要告诉hostapd在启动时启动时查找配置文件。使用 1sudo nano /etc/default/hostapd 打开默认配置文件，找到该行 1#DAEMON_CONF="" 并且用下面这行替换掉 1DAEMON_CONF="/etc/hostapd/hostapd.conf". 配置DNSMASQ12sudo mv /etc/dnsmasq.conf /etc/dnsmasq.conf.orig sudo nano /etc/dnsmasq.conf 将下面的内容粘贴上去： 1234567interface=wlan1 # Use interface wlan0 listen-address=172.24.1.1 # Explicitly specify the address to listen on bind-interfaces # Bind to the interface to make sure we aren't sending things elsewhere server=8.8.8.8 # Forward DNS requests to Google DNS domain-needed # Don't forward short names bogus-priv # Never forward addresses in the non-routed address spaces. dhcp-range=172.24.1.50,172.24.1.150,12h # Assign IP addresses between 172.24.1.50 and 172.24.1.150 with a 12 hour lease time 建立IPV4 转发1sudo nano /etc/sysctl.conf 去掉 1#net.ipv4.ip_forward=1 前面的# 1sudo sh -c "echo 1 &gt; /proc/sys/net/ipv4/ip_forward" 上面这条命令是立即激活转发！ 还需要通过在wlan0接口和wlan1接口之间配置NAT来分享Pi的互联网连接到我们通过WiFi连接的设备。可以使用以下命令来执行此操作： 123sudo iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE sudo iptables -A FORWARD -i wlan0 -o wlan1 -m state --state RELATED,ESTABLISHED -j ACCEPT sudo iptables -A FORWARD -i wlan1 -o wlan0 -j ACCEPT 但是，我们需要在每次重新启动Pi时应用这些规则，运行下面的命令 1sudo sh -c "iptables-save &gt; /etc/iptables.ipv4.nat" 为了避免每次重启都需要运行该命令，打开 1sudo nano /etc/rc.local 在exit 0前添加一行 1iptables-restore &lt; /etc/iptables.ipv4.nat 我们已经完成了12sudo service hostapd start sudo service dnsmasq start 注意事项 树莓派3和树莓派2的配置过程是不一样的，上面的配置过程仅适用于树莓派3. 上面的配置是WLAN1做AP，WLAN0将数据流转发给WLAN1的，那么转发也可以做以太网和wlan0转发，以太网和wlan1转发。过程类似。 为了激活，必须重启！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[朴素贝叶斯算法]]></title>
      <url>%2F2017%2F12%2F21%2F2017-12-21-bayesian-learning%2F</url>
      <content type="text"><![CDATA[\noindent 本节主要讲解三个基本算法的之一：朴素贝叶斯算法，该算法主要是依据贝叶斯规则/公式/推理，它的主要作用在于，它和其他将要讲述的$k$近邻算法，感知机算法都一样，你的算法设计出来之后，至少你的算法的performance要比这三类算法的效果要好！另外贝叶斯学习算法基于一些统计上的假设而成立的，因此贝叶斯学习算法又称为统计学习的算法必须学习的算法.本节主要有以下部分内容： Bayes’ Rule Applying Baye’s Rule to Classification The Posterior Probability :$\mathrm{P}(C|x) = \frac{\mathrm{P}(C)\mathrm{P}(x|C)}{\mathrm{P}(x)}$ Extend to Multi-class classification Naive Bayes for Classification Zero-frequency Problem 贝叶斯定理/公式/规则假设${B_1,B_2,…,B_k}$是$S$集合的划分且对于$i=0,1,…,k$有$\mathrm{P}(B_i) &gt; 0$，那么$$\mathrm{P}(B_j|A) = \frac{\mathrm{P}(A|B_j)\mathrm{P}(Bj)}{\sum{i=1}^k \mathrm{P}(A|B_i)\mathrm{P}(B_i)}$$ 在分类问题上应用贝叶斯分类器例子：信用卡评估：高风险/低风险信用卡评估是这样的一个过程，银行通过对用户的历史交易信息来进行选择的，如果该用户在过去的交易中按时缴纳了本金和利息，并且银行从中获益，那么这些用户是属于低风险的，如果他们没有按时缴纳本金和利息或者拒绝还款的话，这类用户比银行定义为高风险的用户. 我们现在的任务就是来学习如何对用户进行分类\textbf{高风险} vs 低风险.那么我们现在有以下用户的每年的收入信息和消费信息，我们们用两个随机变量 $X_1$ 和 $X_2$ 来表示.用户的信用度可以用伯努利随机变量$\mathrm{C} = 1$ 和 $\mathrm{C} = 0$ 来表示。其中$C=0$表示这是一个低风险的用户，$C=0$表示这是一个高风险的用户。 当一个新的用户来进行贷款时，他提供他的每年的收入和消费，即$X_1 = x_1$ 和 $X_2 = x_2$.如果我们知道信用度C的概率受限于观测值$X = [x_1, x_2]$，并且有\begin{align}&amp;\mathrm{if} \; \; \mathrm{P}(C = 1|[x_1 , x_2 ]) &gt; 0.5, \; then \; \mathrm{C}=1 \&amp;\mathrm{if} \; \; \mathrm{P}(C = 1|[x_1 , x_2 ]) \leq 0.5, \; then \; \mathrm{C} = 0\end{align} 我们估计的误差建立在$1 − max{\mathrm{P}(C = 1|[x_1 , x_2 ]),\mathrm{P}(C = 0|[x_1 , x_2 ])} &lt; 0.5$，一般地，有$P(\mathrm{C} = 1|[x_1 , x_2 ]) +\mathrm{P}(C = 0|[x_1 , x_2 ]) = 1$。 后验概率$\mathrm{P}(C|x) = \frac{\mathrm{P}(C)\mathrm{P}(x|C)}{\mathrm{P}(x)}$其中，对于标题的概率公式又叫做贝叶斯公式，它主要思想是利用先验来估计后验，即$P(C = 1)$ 叫做C=1的先验概率，比如信用卡评估问题上，我们已经有了大量的历史客户数据，$P(C = 1)$表示在这些数据中高风险的人占总人数的比例，肯定地，这是我们知道的！所以被称作先验概率。 $P(x|C )$被称作类的似然，它是条件概率，意思为一个事件在已知属于C类的情况下，事件x发生的概率, $P(x)$表示事件x发生的概率，不管它是正类还是负类, $P(C=0|x) + P(C=1|x) = 1$，来源于事件的划分。 另外还有以下性质： $P(X 1 , X 2 )$表示随机变量$X_1$和$X_2$的联合概率 在假设前提下，两个随机变量是条件概率独立，有$P(X 1 , X 2 |C ) = P(X 1 |C )P(X 2 |C )$，这是贝叶斯规则重要的假设。尽管假非常简单，但是在实际应用中十分关键。 现在我们将问题扩展到多类分类问题上，即$C_i ,\; i = 1, 2, . . . , K$.比如，在数字识别问题上，输入是一个2值化的图像，目标总共有10类，即0-9，我们可以认为这K类看作是输入空间的一个划分。那么贝叶斯分类器是将最高的后验概率的类看作是目标类，也就是$\mathrm{P}(C_i |x) = \mathrm{max}_k \mathrm{P}(C_k |x)$.同样地，对于多类分类问题，我们可以将所有的属性/特征看作是一个随机变量，那么对于贝叶斯分类器将该样本分为No.1类的概率为$Pr (y = 1|x) = Pr (y = 1|\mathbf{X}_1 = x_1 , \mathbf{X}_2 = x_2 , . . . , \mathbf{X}_n = x_n )$. 但是朴素贝叶斯分类七有两个不合理的假设： 每个属性/特征的重要性是一样的 所有属性/特征都是条件概率独立的，有$$Pr (y = 1|x) = \frac{1}{Pr(\mathbf{X} = x)} \Pi_{i=1}^{n} Pr (\mathbf{X}_i = x_i |y = 1)$$ 天气数据的例子]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多变量线性回归]]></title>
      <url>%2F2017%2F12%2F21%2F2017-12-21-multi-variable-linear-regression%2F</url>
      <content type="text"><![CDATA[\noindent 该笔记是来自 Andrew Ng 的 Machine Learning 课程的第二周:多变量线性回归的课堂记录，其实就是将单变量线性回归推广到多变量中去，主要讲解了以下几个内容: 模型的表示 梯度下降算法 运算中的实用技巧 特征缩放 学习率$\alpha$ 模型表达在单变量线性回归的房屋预测模型例子中，我们忽略了一个显示，往往购房者不仅仅考虑一个因素，因此多变量（特征）的引入是必需的，比如房屋的价格往往和卧室的数量（numbers of bedrooms），有多少个楼层(numbers of floors)，房屋的年龄(age of home)等等，我们选取这些特征来预测价格，实例数据如图\ref{figure:multi_features}\begin{figure}[htbp]\begin{center} \includegraphics[width=0.8\textwidth]{multi_feature.png} \caption{房屋价格预测模型-多变量}\label{figure:multi_features}\end{center}\end{figure} 为了后面描述的方便，特别对符号作出声明： $n$ 特征的数目 $m$ 训练集中实例的数量 $x’s$ 输入变量或者特征 $y’s$ 输出变量或目标变量 $x^{(i)}$ 第$i$个训练样本的输入特征 $x^{(i)}_{j}$ 第$i$个训练样本的第$j$个特征 $x_{j}$ 样本数据的第$j$个特征 如图\ref{figure:multifeatures}中，第一个训练样本为$x^{(1)}=\left[\begin{matrix}2104 &amp;5 &amp;1&amp; 45 &amp;460\end{matrix}\right]$则第一个训练样本的第一个特征为$x^{(1)}{1} = 21040$样本数据的第一个特征$x_{1}=\left[\begin{matrix}2104 \1416 \1534\852\end{matrix}\right]$ 同样地，支持多变量的假说函数表示为$$h{\theta}(x) = \theta{0} + \theta{1}x{1} + \theta{2}x{2} + \theta{3}x{3} + …$$ 为了更方便的表示，令define $x{0}$ = 1$$ X = \left[\begin{matrix}x{0}\x{1}\x{2}\x{3}\… \x{n}\end{matrix}\right] \in \mathbb{R}^{n+1}, \theta = \left[\begin{matrix}\theta{0} \\theta{1} \\theta{2} \\theta{3} \…\\theta_{n}\end{matrix}\right]$$ 所以假说函数$h{\theta}$可以表示为$$h{\theta}(x) = \theta{0} + \theta{1}x{1} + \theta{2}x{2} + \theta{3}x_{3} + …= \theta^{T}X$$ 梯度下降算法本节主要讲解如何设定该假设的参数，特别地，讲解如何使用梯度下降算法处理多元线性回归模型。现在我们已经知道： 假说函数：$h{\theta}(x) = \theta{0} + \theta{1}x{1} + \theta{2}x{2} + \theta{3}x{3} + …= \theta^{T}X$ 参数： $\theta \in \mathbb{R}^{n+1}$ 代价误差函数：$J(\mathbb{\theta}) = \frac{1}{2m}\sum{i=1}^{m}(h{\theta}(x^{(i)})- y^{(i)})^{2}$ Goals：$minimize_{\mathbb{\theta}}J(\mathbb{\theta})$ 梯度下降算法伪代码： \begin{algorithm}[h] \caption{梯度下降算法多变量线性回归版本} \label{alg::Gradient Descent Simple} \begin{algorithmic}[1] \Require $\alpha$ 学习率; $\theta \in \mathbb{R}$ 参数; $J$ 代价误差函数; $:=$ 赋值; \Repeat \quad $for$ $j$ = $0,…,n$ \State $\theta{j} := \theta{j} - \alpha\frac{1}{m} \sum{i=1}^{m}(h{\theta}(x^{(i)})-y^{(i)})x_{j}^{(i)}$; \Until{收敛} \end{algorithmic}\end{algorithm} 运算中的适用技巧特征缩放^[特征归一化]特征缩放（feature scaling）可以把特征缩放到一个相近的范围内，是一种能使得梯度下降算法快速收敛的一个技巧。 例子：图\ref{figure:scale}中，$\theta{2}$表示房屋的大小（$0～2000$ $feets$）， $\theta{2}$表示卧室的数量($0~5$)，从图\ref{figure:scale}(a)可以看出等高线很扁，如果不进行特征的缩放，梯度下降算法需要经过很多次迭代才能到达最小值点。经过缩放后，收敛到最小值速度比不缩放的快。 \begin{figure}[htbp]\centering %居中\subfigure[没有经过特征缩放处理，算法的收敛情况]{ %第一张子图\begin{minipage}{7cm}\centering %子图居中\includegraphics[scale=0.35]{large_diff.png} %以pic.jpg的0.5倍大小输出\end{minipage}}\subfigure[经过特征缩放处理后，算法的收敛情况]{ %第二张子图\begin{minipage}{7cm}\centering %子图居中\includegraphics[scale=0.55]{small_diff.png} %以pic.jpg的0.5倍大小输出\end{minipage}}\caption{特征缩放对算法收敛的影响} % %大图名称\label{figure:scale} %图片引用标记\end{figure} 为了实现特征缩放将会使用到一种叫做均值归一化的技术，使得$\theta{1}$,$\theta{2}$的范围在[-1,1]之间。主要的转换公式为：$$X{i} = \frac{X{i} - \mu{n}}{\mathbb{S}{n}}$$ 其中$\mu{n}$表示$X$的均值，$\mathbb{S}{n}$表示$X$的范围，即$max - min$. 比如$\theta{1}$归一化的结果为$\theta{1} = \frac{\theta_{1} - 1000}{2000}$ 学习率$\alpha$复习：梯度下降算法的迭代公式如下. $$\theta{j} := \theta{j} - \alpha\frac{\partial}{\partial{\theta{j}}}J(\theta)$$ 通过上面的公式，我们可以绘制出迭代次数与代价函数$J(\theta)$的关系曲线.通过曲线观测算发在何时起开始收敛。也有一些自动测试是否收敛的方法，例如将代价函数的变化与某个阈值（例如0.01）进行比较，通常图\ref{figure:J_theta}能直观的表示出$J(\theta)$的变化情况。 \begin{figure}[htbp]\begin{center} \includegraphics[width=0.5\textwidth]{J_theta.png} \caption{$J(\theta)$与迭代次数的关系}\label{figure:J_theta}\end{center}\end{figure} 那么上面的例子与学习率有什么关系？关系就是如果学习率$\alpha$选择不合适将会导致梯度算法不能工作，即不能到达最小值或者将会使得梯度下降算法运行效率低迟迟不能收敛！ 总结： 如果$\alpha$过小，将会导致算法的收敛速度慢; 如果$\alpha$过大，在梯度下降过程中，很容易掠过局部最小值，导致无法收敛甚至发散。如图\ref{figure:alpha}. 技巧： 可以尝试下面的学习率：$$\alpha = 0.001,0.003,0.01,0.03,0.1,0.3,1$$]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[逻辑回归]]></title>
      <url>%2F2017%2F12%2F21%2F2017-12-21-logistic-regression%2F</url>
      <content type="text"><![CDATA[\noindent 该笔记是来自 Andrew Ng 的 Machine Learning 课程的第三周:逻辑回归的课堂记录，逻辑回归是机器学习分类算法的地一个算法，涵盖信息论的相关内容.主要讲解了以下几个内容:\begin{itemize}\setlength{\itemsep}{1pt}\setlength{\parskip}{0pt}\setlength{\parsep}{0pt} 分类算法的应用 二元分类问题 边界函数 代价函数 梯度下降算法\end{itemize} 分类算法的应用分类的场景在现实社会中无处不在，比如 Email:垃圾邮件分类 金融交易是否存在欺诈 肿瘤是恶性/良性 分类问题和回归问题一样，只是现在要预测的值只占一小部分离散值。现在，将重点讨论二分类问题，其中$Y$只能接受两个值，0和1。（也可以推广到多个类），例如，如果我们试图为电子邮件构建一个垃圾邮件分类器，那么$X^{(i)}$可能是一封电子邮件的一些特征，如果它是一封垃圾邮件，$y$是1，否则为0。因此，$Y \in {0,1}$。0也被称为否定类，1是正类，它们有时也用符号“-”和“+”表示。 二分类问题医疗诊断是机器学习在医学方面其中的一个应用，本小节主要借助乳腺癌诊断这个例子引出.给出一组数据，其中数据特征为肿瘤的大小，标记$y$是0或者1， 其中0表示恶性，1表示良性，将这些样本数据做图如下： \begin{figure}[htbp]\begin{center} \includegraphics[width=0.7\textwidth]{tumor_logistic.png} \caption{乳腺癌数据}\label{figure:tumor_logistic}\end{center}\end{figure} 我们可以尝试使用线性回归加上一个合适的\textbf{“阈值”}来实现分类问题，如图\ref{figure:tumorlogistic}所示，$h{\theta}(x) = \theta^{T}x$，则基于阈值0.5的分类器算法如下：\begin{align}&amp; h\theta(x) \geq 0.5 \rightarrow y = 1 \&amp; h\theta(x) &lt; 0.5 \rightarrow y = 0\end{align} 但是这将存在一个很大问题，该算法并不具有鲁棒性，即假设我们有观测到了一个非常大的尺寸的恶性肿瘤，将其作为实例加入到我们的训练集中，这样将会我们之前的假说$h$发生很大变化，如图\ref{figure:tumor_logistic}中最右侧的那个点加入到训练集中，将对$h(x)$影响很大，这时将0.5作为阈值来预测肿瘤是否为恶性就不再合适了。虽然很容易构造出模型来，但用原来的线性回归模型解决分类问题的这种方法表现很差。直观地说，也没有任何道理，通过图\ref{figure:tumorlogistic}很容易看出，存在$h{\theta}(x)&gt;1$或者$h{\theta}(x)&lt;0$，但，$Y \in {0,1}$。为了解决这个问题，我们改变$h{\theta}(x)$的形式，使得输出变量$0 \leq h_{\theta}(x) \leq 1$.我们将使用$Sigmoid$来表示假说函数，也叫为逻辑函数，又因为逻辑函数的输入为$\theta^{T}x$，所以我们的模型又叫做逻辑回归模型. 逻辑回归模型为：\begin{align}&amp; h_\theta (x) = g ( \theta^T x )\&amp; z = \theta^T x \&amp;g(z) = \dfrac{1}{1 + e^{-z}}\end{align} $g(z)$函数图像如图\ref{figure:sigmoid}所示. \begin{figure}[htbp]\begin{center} \includegraphics[width=0.7\textwidth]{sigmoid.png} \caption{Sigmoid函数图像}\label{figure:sigmoid}\end{center}\end{figure}另外 ，对于给定的数据X，根据选择的参数，$h{\theta}(x)$表示$y=1$发生的可能性。即$h{\theta}(x) = {P}(y=1 | x,\theta)$,例如，$h{\theta}(x)= 0.7$告诉我们$y=1$的概率为$70\%$，那么根据概率基本知识，$y=0$的概率为$30\%$.基本的概率公式：\begin{align*}&amp; h\theta(x) = P(y=1 | x ; \theta) = 1 - P(y=0 | x ; \theta) \&amp; P(y = 0 | x;\theta) + P(y = 1 | x ; \theta) = 1\end{align}# 边界函数## 线性决策边界根据图\ref{figure:sigmoid}和上面的公式，有以下结论.\begin{align}&amp;z=0, e^{0}=1 \Rightarrow g(z)=1/2 \&amp; z \to \infty, e^{-\infty} \to 0 \Rightarrow g(z)=1 \&amp;z \to -\infty, e^{\infty}\to \infty \Rightarrow g(z)=0 \&amp; \theta^{T}x \geq 0 \rightarrow h\theta(x) \geq 0.5 \rightarrow y = 1 \&amp; \theta^{T}x &lt; 0 \rightarrow h\theta(x) &lt; 0.5 \rightarrow y = 0\end{align}假设有一个模型，模型表示如下\begin{align}&amp; \theta =\begin{bmatrix}-3 \1 \1 \end{bmatrix}\&amp; y = 1 \; if \; -3 + 1 x_1 + 1 x_2 \geq 0\&amp; y = 1 \; if \; x_1 + x_2 \geq 3\end{align*}画出边界，如下图\ref{figure:example}所示.\begin{figure}[htbp]\begin{center} \includegraphics[width=0.5\textwidth]{example_log.png} \caption{线性决策边界}\label{figure:example}\end{center}\end{figure} 非线性决策边界往往在实际的数据中，数据往往是线性不可分的！所以在此基础之上，引申出非线性决策边界的概念。如图所示，这个边界是一个圆$z = \theta_0 + \theta_1 x_1^2 +\theta_2 x_2^2$或者一个其他的形状将$y = 0$的区域和$y = 1$的区域分开.\begin{figure}[htbp]\begin{center} \includegraphics[width=0.5\textwidth]{unlinear.png} \caption{非线性决策边界}\label{figure:unlinear}\end{center}\end{figure} 图\ref{figure:unlinear}，模型描述为：\begin{align}h{\theta}(x) &amp;= g(\theta{0} + \theta{1}x{1} + \theta{2}x{2} + \theta{3}x{1}^2 + \theta{4}x{2}^2)\h{\theta}(x) &amp;= g(-1 + 0 x{1} + 0 x{2} + 1 x{1}^2 + 1 x{2}^2)\y &amp;= 1 \; if \; 1 x{1}^2 + 1 x_{2}^2 \geq 1\end{align} 我们也可以使用比较复杂的模型来适应非常复杂形状的边界.$h_{\theta}(x) = g(\theta_0 + \theta_1 x_1 +\theta_2 x_2 + \theta_3 x_1^2 + \theta_4 x_2^2 + \theta_5 x_1x_2 +…)$ 代价函数在定义逻辑回归模型的代价函数中，我们不能使用线性回归模型定义的成本函数，因为$logistic$函数会导致$y$出现震荡，从而出现许多局部的最优解，此时定义的代价函数不是一个凸函数。 逻辑回归模型的代价函数为\begin{align} J(\theta) &amp;= \dfrac{1}{m} \sum{i=1}^m \mathrm{Cost}(h\theta(x^{(i)}),y^{(i)})\end{align}$$\left{ \begin{aligned} \mathrm{Cost}(h\theta(x),y) &amp;= -\log(h\theta(x)) \; &amp; \text{if y = 1} \ \mathrm{Cost}(h\theta(x),y) &amp;= -\log(1-h\theta(x)) \; &amp; \text{if y = 0} \end{aligned}\right.$$ 当$y=1$和$y=0$时，分别画出 $J(\theta) = \mathrm{Cost}(h_{\theta}(x), y)$的图像，如图\ref{figure:y} \begin{figure}[htbp]\centering %居中\subfigure[当y=1时]{ %第一张子图\begin{minipage}{7cm}\centering %子图居中\includegraphics[scale=0.75]{y1.png} %以pic.jpg的0.5倍大小输出\end{minipage}}\subfigure[当y=0时]{ %第二张子图\begin{minipage}{7cm}\centering %子图居中\includegraphics[scale=0.65]{y0.png} %以pic.jpg的0.5倍大小输出\end{minipage}}\caption{$J(\theta)$ vs $h_{\theta}$} % %大图名称\label{figure:y} %图片引用标记\end{figure} $\mathrm{Cost}(h{\theta}(x),y)$的特点为：\begin{align*}&amp; \mathrm{Cost}(h\theta(x),y) = 0 \text{ if } h\theta(x) = y \ &amp; \mathrm{Cost}(h\theta(x),y) \rightarrow \infty \text{ if } y = 0 \; \mathrm{and} \; h\theta(x) \rightarrow 1 \&amp; \mathrm{Cost}(h\theta(x),y) \rightarrow \infty \text{ if } y = 1 \; \mathrm{and} \; h_\theta(x) \rightarrow 0\end{align*} 公式反映了一个事实：如果$h_{\theta} = 0$，即$\mathrm{P}(y=1 | \theta,x)=0$，但是$\mathrm{y}=1$，则我们将会以一个很大的代价（$\infty$）惩罚学习算法！ 上面的话简单点: 你预测对了，没事！（$\mathrm{OK} \rightarrow \mathrm{Cost} = 0$），但是你如果预测错了，抱歉，狠狠教训一顿！（$\mathrm{Sorry}, \mathrm{Cost} \rightarrow \infty$），其实这是信息论中熵的应用，信息增益！ 这样写过之后，就保证了代价函数是凸函数！ 简化代价函数形式和梯度下降算法我们可以将$$ \mathrm{Cost}(h\theta(x),y) =\left{ \begin{aligned} &amp; -\log(h\theta(x)) \; &amp; \text{if y = 1} \ &amp; -\log(1-h_\theta(x)) \; &amp; \text{if y = 0} \end{aligned}\right.$$ 简化为$$\mathrm{Cost}(h\theta(x),y) = - y \; \log(h\theta(x)) - (1 - y) \log(1 - h_\theta(x))$$ 代入代价函数得到：\begin{align}J(\theta) &amp;= - \frac{1}{m} \displaystyle \sum{i=1}^m \mathrm{Cost}(h{\theta}(x^{(i)}) - y^{(i)}) \ &amp;= - \frac{1}{m} \displaystyle \sum{i=1}^m [y^{(i)}\log (h\theta (x^{(i)})) + (1 - y^{(i)})\log (1 - h_\theta(x^{(i)}))]\end{align} 向量化之后： \begin{align}&amp; h = g(X\theta)\&amp; J(\theta) = \frac{1}{m} \cdot \left(-y^{T}\log(h)-(1-y)^{T}\log(1-h)\right)\end{align}在得到这样的一个代价函数之后，就可以使用梯度下降算法求出使得代价函数最小的参数$\theta$. 梯度下降算法框架如下：\begin{align}&amp; Repeat \; \lbrace \&amp; \; \theta_j := \theta_j - \alpha \dfrac{\partial}{\partial \theta_j}J(\theta) \ &amp; \rbrace\end{align} 将$J(\theta)$代入得 \begin{align} &amp; Repeat \; \lbrace \&amp; \; \theta_j := \thetaj - \frac{\alpha}{m} \sum{i=1}^m (h_\theta(x^{(i)}) - y^{(i)}) x_j^{(i)} \&amp; \rbrace \end{align} 向量化：$$\theta := \theta - \frac{\alpha}{m} X^{T} (g(X \theta ) - \vec{y})$$ 注意： 表面上看起来和线性回归的梯度下降一样，但是这里的$h_{\theta}(x)=g(\theta^{T}x)$与线性回归不同，所以实际上是不一样的。另外在运行梯度下降算法之前，进行特征缩放是非常必要的。 高级优化“共轭梯度”、“BFGS”-局部优化法、和“L-BFGS”-有限内存局部优化，使用更成熟，更快的方法来优化$\theta$，它们可以用来代替梯度下降。不建议自己编写这些复杂的算法，而是使用库，因为它们已经经过测试并高度优化。Octave提供它们！\begin{align}&amp;\mathrm{Given} \; \theta\&amp; \rightarrow J(\theta) \&amp; \rightarrow \frac{\partial}{\partial{\theta{j}}}J(\theta) \; \mathrm{for} \;{j} = 0,1,2,3,…\end{align} \lstset{language=Matlab} 代码实现： \begin{lstlisting}function [jVal, gradient] = costFunction(theta) jVal = […code to compute J(theta)…]; gradient = […code to compute derivative of J(theta)…];end\end{lstlisting}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在树莓派上搭建OpenCV环境]]></title>
      <url>%2F2017%2F12%2F20%2F2017-12-20-opencv-rpi%2F</url>
      <content type="text"><![CDATA[本文主要介绍如何在树莓派上配置和安装OpenCV，本文原文出处^[www.pyimagesearch.com/2016/04/18/install-guide-raspberry-pi-3-raspbian-jessie-opencv- 3/]. 扩大文件系统由于编译安装OpenCV需要的空间很大，所以应该做的第一件事是扩展文件系统，以包括micro-SD卡上的所有可用空间： 1sudo raspi-config echo=FALSE, fig.height=3, fig.margin=TRUE, warning=FALSE,eval=TRUE,background="#f5f5d5", cache=FALSE, fig.align='center'&#125;123456library(png)par(bg = &quot;#f5f5d5&quot;)ima &lt;- readPNG(&quot;C:\\Users\\Shine\\Desktop\\readailib\\themes\\hugo-lithium-theme\\static\\images\\6380903.png&quot;)grid::grid.raster(ima) fig-margin, echo=FALSE, fig.cap="扩展文件系统",fig.align='center', fig.height=3, fig.margin=TRUE, warning=FALSE,eval=TRUE,background="#f5f5d5", cache=FALSE&#125;12345678910library(png)par(bg = &quot;#f5f5d5&quot;)ima &lt;- readPNG(&quot;C:\\Users\\Shine\\Desktop\\readailib\\themes\\hugo-lithium-theme\\static\\images\\6380903.png&quot;)grid::grid.raster(ima)imb &lt;- readPNG(&quot;C:\\Users\\Shine\\Desktop\\readailib\\themes\\hugo-lithium-theme\\static\\images\\85376892.png&quot;)grid::grid.raster(imb) 安装依赖12345678sudo apt-get install build-essential cmake pkg-config -ysudo apt-get install libjpeg-dev libtiff5-dev libjasper-dev libpng12-dev -ysudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev -y sudo apt-get install libxvidcore-dev libx264-dev -ysudo apt-get install libgtk2.0-dev -ysudo apt-get install libatlas-base-dev gfortran -y sudo apt-get install python2.7-dev python3-dev -y 下载OpenCV源代码123cd ~wget -O opencv.zip https://github.com/Itseez/opencv/archive/3.1.0.zipunzip opencv.zip OpenCV 3.1.0 地址：https://github.com/Itseez/opencv_contrib/archive/3.1.0.zip 12wget -O opencv_contrib.zip https://github.com/Itseez/opencv_contrib/archive/3.1.0.zipunzip opencv_contrib.zip Python2.7还是Python3.5 pip包管理器 123456789101112131415wget https://bootstrap.pypa.io/get-pip.pysudo python get-pip.pysudo pip install virtualenv virtualenvwrappersudo rm -rf ~/.cache/pip# virtualenv and virtualenvwrapperexport WORKON_HOME=$HOME/.virtualenvssource /usr/local/bin/virtualenvwrapper.shecho -e "\n# virtualenv and virtualenvwrapper" &gt;&gt; ~/.profileecho "export WORKON_HOME=$HOME/.virtualenvs" &gt;&gt; ~/.profileecho "source /usr/local/bin/virtualenvwrapper.sh" &gt;&gt; ~/.profilesource ~/.profile 安装Numpy1pip install numpy 如果正在为Python 2.7编译OpenCV 3，请确保Python 2部分包含Interpreter ，Libraries ，numpy和packages path ： 编译安装OpenCV1234567891011cd ~/opencv-3.1.0/mkdir buildcd buildcmake -D CMAKE_BUILD_TYPE=RELEASE \ -D CMAKE_INSTALL_PREFIX=/usr/local \ -D INSTALL_PYTHON_EXAMPLES=ON \ -D OPENCV_EXTRA_MODULES_PATH=~/opencv_contrib-3.1.0/modules \ -D BUILD_EXAMPLES=ON ..make -j4 很容易出错，因为树莓派不一定CPU的资源不一定够用，使用 12345make cleanmakesudo make installsudo ldconfig 然后检查是否存在层cv2.so或者cv2.cpython-34m.so： 对于Python27说， 1ls -l /usr/local/lib/python2.7/site-packages/ 如果存在，则说明在python2的环境下能够使用OpenCV。 对于Python3.4说： 1ls -l /usr/local/lib/python3.4/site-packages/ 如果存在，则表明在Python3的环境下能够使用OpenCV 但是对于Python3说需要将cv2.cpython-34m.so重命名为cv2.so才能使用。 安装完成后，需要将编译生成的文件和解压后的文件删除。 1rm -rf opencv-3.1.0 opencv_contrib-3.1.0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在树莓派上搭建邮件服务器]]></title>
      <url>%2F2017%2F12%2F20%2F2017-12-20-mail-server-rpi%2F</url>
      <content type="text"><![CDATA[上篇文章介绍了利用树莓派搭建AP，那么有了AP之后，由于小编是一名在校的学生，将我的树莓派和我宿舍的路由器连接上网之后，我的树莓派就拥有了全球唯一可访问的地址了，这样的话就可以为所欲为了. 说到为什么搭建邮件服务器，为什么要使用树莓派呢？为什么不使用VPS呢？ 有所不知，现在VPS（国外的）是严格要求的，不允许在他们的服务器上搭建邮件服务的!这让小编很慌啊，上次搭建了一次，可以发但是不可以接受邮件，这让我很受伤，因此我要在我树莓派上下功夫了，功夫不负有心人呢，我在下面po下我的教程，教程大部分来自该处^[https://pimylifeup.com/raspberry-pi-email-server/]。 安装 Citadel 邮件服务器 更新软件包 1sudo apt-get update 将我们的软件包升级到最新版本. 1sudo apt-get upgrade 安装Citadel 邮件服务器 1sudo apt-get install citadel-suite echo=FALSE, fig.cap="leave the field set to 0.0.0.0 as this allows Citadel to listen on all incoming addresses. ",fig.height=6,fig.width=9.5, fig.margin=TRUE, warning=FALSE,eval=TRUE,background="#f5f5d5", cache=FALSE, fig.align='center'&#125;123456library(png)par(bg = &quot;#f5f5d5&quot;)ima &lt;- readPNG(&quot;C:\\Users\\Shine\\Desktop\\readailib\\themes\\hugo-lithium-theme\\static\\images\\01-Configuring-citadel-server-.png&quot;)grid::grid.raster(ima) echo=FALSE, fig.cap="Now for the user authentication mode we’re going to keep this set to internal. ",fig.height=6,fig.width=9.5, fig.margin=TRUE, warning=FALSE,eval=TRUE,background="#f5f5d5", cache=FALSE, fig.align='center'&#125;123456library(png)par(bg = &quot;#f5f5d5&quot;)ima &lt;- readPNG(&quot;C:\\Users\\Shine\\Desktop\\readailib\\themes\\hugo-lithium-theme\\static\\images\\02-Select-authentication-mode.png&quot;)grid::grid.raster(ima) echo=FALSE, fig.cap="Select admin username",fig.height=6,fig.width=9.5, fig.margin=TRUE, warning=FALSE,eval=TRUE,background="#f5f5d5", cache=FALSE, fig.align='center'&#125;123456library(png)par(bg = &quot;#f5f5d5&quot;)ima &lt;- readPNG(&quot;C:\\Users\\Shine\\Desktop\\readailib\\themes\\hugo-lithium-theme\\static\\images\\03-Select-admin-username.png&quot;)grid::grid.raster(ima) echo=FALSE, fig.cap="Select admin password",fig.height=6,fig.width=9.5, fig.margin=TRUE, warning=FALSE,eval=TRUE,background="#f5f5d5", cache=FALSE, fig.align='center'&#125;123456library(png)par(bg = &quot;#f5f5d5&quot;)ima &lt;- readPNG(&quot;C:\\Users\\Shine\\Desktop\\readailib\\themes\\hugo-lithium-theme\\static\\images\\04-Select-admin-password.png&quot;)grid::grid.raster(ima) echo=FALSE, fig.cap="Select Web Server",fig.height=6,fig.width=9.5, fig.margin=TRUE, warning=FALSE,eval=TRUE,background="#f5f5d5", cache=FALSE, fig.align='center'&#125;123456library(png)par(bg = &quot;#f5f5d5&quot;)ima &lt;- readPNG(&quot;C:\\Users\\Shine\\Desktop\\readailib\\themes\\hugo-lithium-theme\\static\\images\\05-Select-Web-Server.png&quot;)grid::grid.raster(ima) echo=FALSE, fig.cap="Select HTTP Port ",fig.height=6,fig.width=9.5, fig.margin=TRUE, warning=FALSE,eval=TRUE,background="#f5f5d5", cache=FALSE, fig.align='center'&#125;123456library(png)par(bg = &quot;#f5f5d5&quot;)ima &lt;- readPNG(&quot;C:\\Users\\Shine\\Desktop\\readailib\\themes\\hugo-lithium-theme\\static\\images\\06-Select-HTTP-Port.png&quot;)grid::grid.raster(ima) echo=FALSE, fig.cap="Select HTTPs Port ",fig.height=6,fig.width=9.5, fig.margin=TRUE, warning=FALSE,eval=TRUE,background="#f5f5d5", cache=FALSE, fig.align='center'&#125;123456library(png)par(bg = &quot;#f5f5d5&quot;)ima &lt;- readPNG(&quot;C:\\Users\\Shine\\Desktop\\readailib\\themes\\hugo-lithium-theme\\static\\images\\07-Select-HTTPS-Port.png&quot;)grid::grid.raster(ima) echo=FALSE, fig.cap="Select Language ",fig.height=6,fig.width=9.5, fig.margin=TRUE, warning=FALSE,eval=TRUE,background="#f5f5d5", cache=FALSE, fig.align='center'&#125;123456library(png)par(bg = &quot;#f5f5d5&quot;)ima &lt;- readPNG(&quot;C:\\Users\\Shine\\Desktop\\readailib\\themes\\hugo-lithium-theme\\static\\images\\08-Select-Language.png&quot;)grid::grid.raster(ima) Extra Steps \Sometimes the steps above will throw errors and not create the admin account we need to setup the email server correctly. If this is the case with you then you will need to do a few extra steps.\ First we need to create the netconfigs folder and set the owner and group to citadel.sudo mkdir /etc/citadel/netconfigssudo chown citadel:citadel /etc/citadel/netconfigs\ Next we need to restart Citadel so the previous changes are applied correctly. We also want to run setup again so that we can setup the admin account if it wasn’t created correctly the first time.sudo service citadel restartsudo /usr/lib/citadel-server/setup\ When you run the setup it will take you through a series of questions with the first being the name of admin. Set this to the username you wish to have for your admin account. \ Next it will ask you to set a password for the administrator account. Set this to something secure so you’re not easily hacked. \5 You can now skip through the rest of the questions. Simply press enter to skip the questions and not change anything. 配置 Citadel 邮件服务器由于已经安装完成，并且安装了一些Web服务器，那么现在打开一个浏览器，输入http://hostname 或者http://localhost 就可以看到web界面下的Citadel服务器 如果你不知道你的hostname是什么，你可以通过下面的命令进行查询 hostname -i echo=FALSE, fig.cap="登陆界面 ",fig.height=6,fig.width=9.5, fig.margin=TRUE, warning=FALSE,eval=TRUE,background="#f5f5d5", cache=FALSE, fig.align='center'&#125;123456library(png)par(bg = &quot;#f5f5d5&quot;)ima &lt;- readPNG(&quot;C:\\Users\\Shine\\Desktop\\readailib\\themes\\hugo-lithium-theme\\static\\images\\09-Citadel-Login.png&quot;)grid::grid.raster(ima) 使用上面安装时的用户名和密码 admin 123456 登陆进去之后，你可以看到Citadel的仪器盘，可以通过选中相关的term进行详细的配置. echo=FALSE, fig.cap="Citadel的仪器",fig.height=6,fig.width=9.5, fig.margin=TRUE, warning=FALSE,eval=TRUE,background="#f5f5d5", cache=FALSE, fig.align='center'&#125;123456library(png)par(bg = &quot;#f5f5d5&quot;)ima &lt;- readPNG(&quot;C:\\Users\\Shine\\Desktop\\readailib\\themes\\hugo-lithium-theme\\static\\images\\10-Citadel-Dashboard.png&quot;)grid::grid.raster(ima) 此时进入administrator进行管理员配置,注意只有管理员权限的用户才可以使用该选项，对于一般网络用户是不可见的. echo=FALSE, fig.cap="进入管理员界面",fig.height=6,fig.width=9.5, fig.margin=TRUE, warning=FALSE,eval=TRUE,background="#f5f5d5", cache=FALSE, fig.align='center'&#125;123456library(png)par(bg = &quot;#f5f5d5&quot;)ima &lt;- readPNG(&quot;C:\\Users\\Shine\\Desktop\\readailib\\themes\\hugo-lithium-theme\\static\\images\\11-Citadel-Admin-menu.png&quot;)grid::grid.raster(ima) echo=FALSE, fig.cap="将主机名设置为DNS解析后的全球域名",fig.height=6,fig.width=9.5, fig.margin=TRUE, warning=FALSE,eval=TRUE,background="#f5f5d5", cache=FALSE, fig.align='center'&#125;123456library(png)par(bg = &quot;#f5f5d5&quot;)ima &lt;- readPNG(&quot;C:\\Users\\Shine\\Desktop\\readailib\\themes\\hugo-lithium-theme\\static\\images\\12-Citadel-Site-config-general.png&quot;)grid::grid.raster(ima) 编辑SMTP服务器的参数 echo=FALSE, fig.cap="SMTP服务配置",fig.height=6,fig.width=9.5, fig.margin=TRUE, warning=FALSE,eval=TRUE,background="#f5f5d5", cache=FALSE, fig.align='center'&#125;123456library(png)par(bg = &quot;#f5f5d5&quot;)ima &lt;- readPNG(&quot;C:\\Users\\Shine\\Desktop\\readailib\\themes\\hugo-lithium-theme\\static\\images\\13-SMTP-config.png&quot;)grid::grid.raster(ima) 然后进入系统级别的配置，包括更改域名和相关的反垃圾，反病毒设置。 echo=FALSE, fig.cap="进入系统配置",fig.height=6,fig.width=9.5, fig.margin=TRUE, warning=FALSE,eval=TRUE,background="#f5f5d5", cache=FALSE, fig.align='center'&#125;123456library(png)par(bg = &quot;#f5f5d5&quot;)ima &lt;- readPNG(&quot;C:\\Users\\Shine\\Desktop\\readailib\\themes\\hugo-lithium-theme\\static\\images\\11b-Citadel-Admin-menu.png&quot;)grid::grid.raster(ima) echo=FALSE, fig.cap="添加本地的主机名别名",fig.height=6,fig.width=9.5, fig.margin=TRUE, warning=FALSE,eval=TRUE,background="#f5f5d5", cache=FALSE, fig.align='center'&#125;123456library(png)par(bg = &quot;#f5f5d5&quot;)ima &lt;- readPNG(&quot;C:\\Users\\Shine\\Desktop\\readailib\\themes\\hugo-lithium-theme\\static\\images\\11c-Citadel-Admin-menu.png&quot;)grid::grid.raster(ima) echo=FALSE, fig.cap="完成上面的配置后，重启服务器",fig.height=6,fig.width=9.5, fig.margin=TRUE, warning=FALSE,eval=TRUE,background="#f5f5d5", cache=FALSE, fig.align='center'&#125;123456library(png)par(bg = &quot;#f5f5d5&quot;)ima &lt;- readPNG(&quot;C:\\Users\\Shine\\Desktop\\readailib\\themes\\hugo-lithium-theme\\static\\images\\14-Local-host-aliases.png&quot;)grid::grid.raster(ima) 一般情况下，重启之后，就可以正常使用了，但是我们忘记了一个很重要的步骤，就是设置DNS记录，一般情况下，需要设置A记录，MX记录即可。 图1 这是我的DNS解析 结语配置很简单，相比较vps来说，并且很稳定，拥有一个属于自己的邮箱，是一件很cool的事情，关于反垃圾，反病毒的设置可以参考我下面给出的参考链接。 说实话，我感觉反垃圾什么的并没什么卵用！上面主要作学习用，因为快速并且稳定的配置会使得我们的工作效率大大提高的！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Display Image Using R]]></title>
      <url>%2F2017%2F12%2F19%2F2017-12-19-example%2F</url>
      <content type="text"><![CDATA[123456789&#123;r fig-margin, echo=FALSE, fig.cap="这是一个神经网络的图。", fig.height=3.5, fig.margin=TRUE, warning=FALSE, background="#f5f5d5", cache=FALSE&#125;# need png packagelibrary(png)#Replace the directory and file information with your infoima &lt;- readPNG("C:\\Users\\Shine\\Desktop\\readailib\\themes\\hugo-lithium-theme\\static\\images\\logo.png")grid::grid.raster(ima) fig-margin, echo=FALSE, fig.cap="这是一个神经网络的图。", fig.height=3.5, fig.margin=TRUE, warning=FALSE,eval=TRUE,background="#f5f5d5", cache=FALSE&#125;123456library(png)par(bg = &quot;#f5f5d5&quot;)ima &lt;- readPNG(&quot;C:\\Users\\Shine\\Desktop\\readailib\\themes\\hugo-lithium-theme\\static\\images\\logo.png&quot;)grid::grid.raster(ima)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tufte样式]]></title>
      <url>%2F2017%2F12%2F15%2F2017-12-15-tufte-template-for-blog%2F</url>
      <content type="text"><![CDATA[title: “Tufte样式”subtitle: “一个R Markdown实现”author: “JJ Allaire，谢益辉”date: “r Sys.Date()“output: tufte::tufte_html: default tufte::tufte_book: citation_package: natbib latex_engine: xelatex tufte::tufte_handout: citation_package: natbib latex_engine: xelatexctex: yesbiblio-title: 参考文献bibliography: skeleton.bib link-citations: yessetup, include=FALSE&#125;12345library(tufte)# tufte版本变化之后更新knitr缓存knitr::opts_chunk$set(tidy = FALSE, cache.extra = packageVersion(&apos;tufte&apos;))options(htmltools.dir.version = FALSE) 引言Tufte样式在Edward Tufte的书以及物理学家费曼的教科书很常见，它的一个显著特点就是边栏的使用。例如脚注和边栏注解，以及放在边栏里的小型插图。Tufte样式在LaTeX和HTML/CSS中都有实现^[参见Github库tufte-latex和 tufte-css]。我们将这两种实现都纳入了tufte包。若需要LaTeX/PDF输出，使用输出格式tufte_handout即可，类似地，tufte_book可以用来输出PDF书，tufte_html生成HTML网页。这些输出格式可以在YAML元数据中指定，或者传给rmarkdown::render()函数。若对rmarkdown包不熟悉，可参见 @R-rmarkdown。 123456789---title: "一个Tufte样式示例"author: "张三"ctex: yesoutput: tufte::tufte_handout: latex_engine: xelatex tufte::tufte_html: default--- 章节标题Tufte样式不主张太深的章节目录，一般仅仅使用一级标题（Markdown中用一个井号#）和二级标题（两个井号）。 插图边栏插图插图在Tufte的书中非常常见，我们可以使用三种插图：边栏图、全宽图、主栏图。先说边栏图：使用knitr代码段选项fig.margin = TRUE即可将图形放置在边栏中，如： fig-margin, fig.margin = TRUE, fig.cap = "MPG与horsepower两个变量的散点图；颜色代表自动挡或手动挡。", fig.width=3.5, fig.height=3.5, cache=TRUE&#125;123456789library(ggplot2)par(bg = &quot;#f5f5d5&quot;)mtcars2 &lt;- mtcarsmtcars2$am &lt;- factor( mtcars$am, labels = c(&apos;automatic&apos;, &apos;manual&apos;))ggplot(mtcars2, aes(hp, mpg, color = am)) + geom_point() + geom_smooth() + theme(legend.position = &apos;bottom&apos;)+ theme(panel.background = element_rect(fill = &apos;#f5f5d5&apos;, colour = &apos;#f5f5d5&apos;)) 注意我们使用代码段选项fig.cap设定了图的标题。当然我们也可以设置图的长宽。 任意数学公式对于数学公式，$\LaTeX$的支持，可以使用(inline: `$ $` ; display style: `$$ $$` )。例如下面有一个微积分第一基本定理。 根据微积分第一基本定理我们知道，对$x \in [a, b]$有$$\frac{d}{dx}\left( \int_{a}^{x} f(u)\,du\right)=f(x).$$ 为了文本内容的可移植性（同样的内容可以生成HTML和LaTeX文档）。 全宽插图代码段选项fig.fullwidth = TRUE可以使得一幅图占用全部页宽，例如： fig-fullwidth, fig.width = 10, fig.height = 2, fig.fullwidth = TRUE, fig.cap = "一幅全宽图形。", warning=FALSE, cache=TRUE&#125;123par(bg = &quot;#f5f5d5&quot;)ggplot(diamonds, aes(carat, price)) + geom_smooth() + facet_grid(~ cut) + theme(panel.background = element_rect(fill = &apos;#f5f5d5&apos;, colour = &apos;#f5f5d5&apos;)) 其它和图形有关的代码段选项仍然可以使用，一般情况下，全款图形的fig.width选项会较大，而fig.height相对较小。上图的尺寸是 $10 \times 2$ 英寸. 主栏插图默认情况下，R代码段生成的图形放置在主栏里，其标题放在边栏中，例如： fig-main, fig.cap = "一幅主栏插图。", cache=TRUE&#125;1ggplot(diamonds, aes(cut, price)) + geom_boxplot() + theme(panel.background = element_rect(fill = &apos;#f5f5d5&apos;, colour = &apos;#f5f5d5&apos;)) 边栏附注Tufte样式的文档中，脚注会被自动转换为边栏附注^[这里本来是一个脚注]。脚注是带编号的，另一种边栏附注是不带编号的，这种附注需要用tufte包中的R函数margin_note()在knitr行内代码中生成。 r margin_note(&quot;这是一个边栏附注，它没有编号。&quot;)与边栏插图一样，边栏附注中我们也不建议写太复杂的内容，通常只是一句简单的文字。 参考文献HTML输出中，参考文献默认也放在边栏中。例如这里我们可以引用[@R-base]。这个功能需要在YAML元数据中设置link-citations: yes，而且pandoc-citeproc程序的版本应该至少是0.7.2。若这两个条件不满足，参考文献会被放在文档末尾。 表格我们可以用knitr包中的kable()函数生成简单的表格。HTML输出中表格的标题也会被放在边栏中。 123knitr::kable( mtcars[1:6, 1:6], caption = &apos;mtcars数据的前几行。&apos;) 引文Markdown语法使用&gt;来生成引文，如果需要在引文下面用行内代码以及quote_footer()函数加上一句引文来源，例如： “多亏了我的律师，要不然我现在还在牢里。两个人一起挖确实比一个人快很多啊。” r tufte::quote_footer(&#39;--- Joe Martin&#39;) 如果不用这个函数的话，引文底部的话只是一个普通段落： “伟人论道，凡人论事，小人论酒。” r tufte::quote_footer(&#39;--- Fran Lebowitz&#39;) 响应式页面这个包生成的HTML页面是响应式的：如果页宽小于760像素，边栏内容会自动隐藏。此时我们可以点击脚注的序号显示它，其它边栏附注则可以通过点击圆圈加号的符号显示。 结语希望诸位喜欢R Markdown的超级简洁性，同时我们感谢Tufte-CSS和Tufte-LaTeX项目的作者们，没有他们的辛勤劳动，就没有这个tufte包。这份文档的R Markdown源文档可以在Github上找到，或者直接使用RStudio菜单File -&gt; New File -&gt; R Markdown -&gt; From Template新建一个文档，或直接从R里面打开这个Rmd文件： eval=FALSE&#125;12345file.edit( tufte:::template_resources( &apos;tufte_ctex&apos;, &apos;..&apos;, &apos;skeleton&apos;, &apos;skeleton.Rmd&apos; )) bib, include=FALSE&#125;12# create a bib file for the R packages used in this documentknitr::write_bib(c(&apos;base&apos;, &apos;rmarkdown&apos;), file = &apos;skeleton.bib&apos;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CTeX样式]]></title>
      <url>%2F2017%2F12%2F15%2F2017-12-15-ctex-template-for-rstudio%2F</url>
      <content type="text"><![CDATA[title: “在R Markdown文档中使用中文”author: 谢益辉 邱怡轩 于淼documentclass: ctexartoutput:rticles::ctex:fig_caption: yesnumber_sections: yestoc: yesclassoption: “hyperref,” 引言中文LaTeX文档并非难题。当然这句话得站在巨人 CTeX 的肩膀上才能说，它让我们只需要一句 1\documentclass&#123;ctexart&#125; % 或者ctexrep/ctexbook 或者 1\usepackage&#123;ctex&#125; 就轻松搞定中文LaTeX排版问题。跨平台通用的LaTeX编译却是个小难题，主要是没有一种跨平台通用且免费的中文字体。好吧，你们Windows用户永远有宋体黑体，你们Mac用户有华文字体，而我们苦逼Linux用户在编译LaTeX文档就没那么简单了^[切，傲娇的Linux用户怎么会干出找你们复制字体的事情]，是啊，我们有文泉驿，但我们要是用了文泉驿之后把文档发给你们八成不能编译，因为你们没有安装文泉驿。 字体和选项LaTeX包ctex支持若干种字体选项，如果你是ctex老用户，请注意这里我们要求的最低版本是2.2，你可能需要升级你的LaTeX包。从版本2.0开始，ctex支持根据不同操作系统自动选择中文字体，简直是为人类进步作出了巨大贡献，我们再也不必费尽口舌向用户解释“啊，你用Windows啊，那么你该使用什么字体；啊，你用Mac啊，又该如何如何”。 下面的YAML元数据应该能满足多数用户的需求，主要设置两项参数：文档类为ctexart（当然也可以是别的类），输出格式为rticles::ctex，其默认LaTeX引擎为XeLaTeX（真的，别纠结你的旧爱PDFLaTeX了）。 1234---documentclass: ctexartoutput: rticles::ctex--- rticles::ctex的参数都是普通的pdf_document参数，参见文档rmarkdown包的文档，这里就不赘述了。 Windows和Mac用户应该都已经有自带的中文字体了。Linux用户可以另外下载 Fandol字体^[http://ctan.org/tex-archive/fonts/fandol]，它号称是免费的，不过我们也没太搞清楚它的来头。把那些.otf字体文件下载下来保存到`~/.fonts`文件夹下，然后命令行切换到那里，运行`fc-cache -fv`。 R代码段R代码用R Markdown的语法嵌入，即三个反引号开始一段代码```&#123;r&#125; ````和三个反引号```` ``` ```` 结束一段代码：1234567```&#123;r&#125;par(bg = &quot;#f5f5d5&quot;)options(digits = 4)fit = lm(dist ~ speed, data = cars)coef(summary(fit))b = coef(fit) 上面回归方程中的斜率是r b[2]，完整的回归方程为：$$ Y = r b[1] + r b[2]x$$ 画图当然也是木有问题的啦，想画就说嘛，不说我怎么知道你想画呢？ scatter, fig.cap='cars数据散点图以及回归直线。'&#125;1234par(bg = &quot;#f5f5d5&quot;)par(mar = c(4, 4, .1, .1), las = 1)plot(cars, pch = 19)abline(fit, col = &apos;red&apos;) 请不要问我为什么图浮动到下一页去了，这么初级的LaTeX问题问出来信不信我扁你。 源代码控这里提供的rticles模板可能由于种种原因不能满足客官的要求，LaTeX用户就是这样永无止境地调格式（唉，跟Word用户到底有啥区别呢）。若真是需要调整，你可以复制一份默认模板去改，如前面所说，本文档的模板是rticles::ctex_template()，它是一个文本文件。若熟悉LaTeX的话一看就明白，只不过里面有些Pandoc变量而已；若不熟悉LaTeX我们在这里说了也白说，花几天时间好好啃一啃LaTeX入门手册吧。 本文档所用的模板是从Pandoc默认LaTeX模板基础上做了少许改动而来的：https://github.com/yihui/pandoc-templates/blob/ctex/default.latex 具体改动从GIT提交消息日志中可以看到，主要就是去掉了mathspec包和hyperref包。 小结事实证明我们可以理直气壮地通过XeLaTeX将中文R Markdown转化为PDF文档，麻麻再也不用担心我的论文满屏幕都是反斜杠，朕养完小白鼠之后终于不必先折腾三个小时LaTeX再开始写实验报告了：打开RStudio，菜单File &gt; New File &gt; R Markdown，然后从模板中选择CTeX Documents，搞定。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用python从头实现矩阵分解算法]]></title>
      <url>%2F2017%2F12%2F15%2F2017-12-15-%E5%88%A9%E7%94%A8python%E4%BB%8E%E5%A4%B4%E5%AE%9E%E7%8E%B0%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[该程序主要是我的《矩阵分析与应用》课程的大作业的解决方案及程序说明。大作业的要求为： 要求完成课堂上讲的关于矩阵分解的LU、QR（Gram-Schmidt）、Orthogonal Reduction (Householder reduction 和Givens reduction)程序实现，要求如下： 一个综合程序，根据选择参数的不同，实现不同的矩阵分解；\ 可以用matlab等编写程序，需附上简单的程序说明，比如参数代表什么意思，输入什么，输出什么等等；\ 一定是可执行文件，例如.m文件等,不能是word或者txt文档。附上源代码，不能为直接调用matlab等函数库. 程序说明项目的地址为https://github.com/rh01/matrix-decomposition 12- factorization.py- utils.py utils.py共有两个源文件组成，其中utils文件主要是一些实现好的工具函数，有 123456789101112131415def mult_matrix(M, N): &quot;&quot;&quot;Multiply square matrices of same dimension M and N&quot;&quot;&quot;def pivot_matrix(M): &quot;&quot;&quot;Returns the pivoting matrix for M, used in Doolittle&apos;s method.&quot;&quot;&quot;def trans_matrix(M): &quot;&quot;&quot;Take the transpose of a matrix.&quot;&quot;&quot; def norm(x): &quot;&quot;&quot;Return the Euclidean norm of the vector x.&quot;&quot;&quot;def Q_i(Q_min, i, j, k): &quot;&quot;&quot;Construct the Q_t matrix by left-top padding the matrix Q with elements from the identity matrix.&quot;&quot;&quot; 由于实现的为矩阵运算，并且未使用到高级的矩阵运算工具软件numpy，因此程序里面的数据结构为python的基本数据结构list，所以说整个工程相对来说计算比较复杂。所以我们提前写好了简化计算的函数工具. factorization.py这个是主函数实现部分，基本上所有的算法都在这个文件中实现，将函数的结构列在下面: 12345678910111213141516171819def LU_decomposition(A, verbose=False): """Performs an LU Decomposition of A (which must be square) into PA = LU. The function returns P, L and U.""" def Gram_Schimidt(A,verbose=False): """Performs a Gram Schimidt based QR Decomposition of the matrix A. The function returns Q, an orthogonal matrix and R, an upper triangular matrix such that A = QR."""def householder_reduction(A, verbose=False): """Performs a Householder Reflections based QR Decomposition of the matrix A. The function returns Q, an orthogonal matrix and R, an upper triangular matrix such that A = QR.""" def Givens_reduction(A,verbose=False): """Performs a Givens Reflections based QR Decomposition of the matrix A. The function returns Q, an orthogonal matrix and R, an upper triangular matrix such that A = QR.""" 测试部分PLU_decomposition123456789101112the A matrix is:[[12, -51, 4], [6, 167, -68], [-4, 24, -41]]please choose the way to decompose A . Press '1' to realize the PLU_decomposition of A. Press '2' to realize the Gram_Schimidt of A.Press '3' to realize the householder_reduction of A.Press '4' to realize the Givens_reduction of A.please choose the mode:1The L matrix is[[1.0, 0.0, 0.0], [0.5, 1.0, 0.0], [-0.3333333333333333, 0.03636363636363636, 1.0]]The U matrix is[[12.0, -51.0, 4.0], [0.0, 192.5, -70.0], [0.0, 0.0, -37.121212121212125]] Gram_Schimidt1234567891011121314the A matrix is:[[12, -51, 4], [6, 167, -68], [-4, 24, -41]]please choose the way to decompose A . Press '1' to realize the PLU_decomposition of A. Press '2' to realize the Gram_Schimidt of A.Press '3' to realize the householder_reduction of A.Press '4' to realize the Givens_reduction of A.please choose the mode:2QR decomposition in numpy is (array([[-0.85714286, 0.39428571, 0.33142857], [-0.42857143, -0.90285714, -0.03428571], [ 0.28571429, -0.17142857, 0.94285714]]), array([[ -14., -21., 14.], [ 0., -175., 70.], [ 0., 0., -35.]]))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Rmarkdown模板]]></title>
      <url>%2F2017%2F12%2F15%2F2017-12-15-template-of-rmarkdown%2F</url>
      <content type="text"><![CDATA[setup, include=FALSE&#125;1knitr::opts_chunk$set(echo = TRUE) GitHub DocumentsThis is an R Markdown format used for publishing markdown documents to GitHub. When you click the Knit button all R code chunks are run and a markdown file (.md) suitable for publishing to GitHub is generated. Including CodeYou can include R code in the document as follows: cars&#125;1summary(cars) Including PlotsYou can also embed plots, for example: pressure, echo=FALSE&#125;1plot(pressure) Note that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[为我的博客安装评论插件]]></title>
      <url>%2F2017%2F12%2F14%2F2017-12-14-add-comment-to-your-blog%2F</url>
      <content type="text"><![CDATA[今天尝试了一下不同得评论系统，现在将我设置评论系统的安装方法以及设置步骤总结出来，分享给大家. 1.Disqusdisqus是一个支持多社交账号和自家的账号的评论插件，是一个广泛使用的评论插件，主要依赖于你必须要在disqus进行设置。但是墙内的用户无法使用，这是比较不方便的地方。 首先需要创建并设置disqus，进入管理界面，按照图1进行填写. 图1 填写要求 填写完成之后，点击Create Site按钮，就可以进行下一步配置. 图2 配置要求说明 填写完成后，就可以点击Complete Setup，完成配置，但是重要的一点不要忘记是，必须要记住disqusShortname，那你可以通过下面的方式进行查询，比如 图3 disqusShortname查看方式 完成之后，就可以在blogdown里面的config.toml中进行配置了， 1disqusShortname = &quot;readailib&quot; 然后就可以启用了.效果如下 图4 disqus效果 2.gitment首先Register a new OAuth application，填写要求 图5 Register a new OAuth application Principle 注册完成之后会返回下面的画面，记住client_id 和 client_secret就行了。 图6 记住client_id 和 client_secret 然后在 themes\hugo-lithium-theme\layouts\partials文件中添加一个新的文件gitment.html，文件内容如下 123456789101112131415&lt;div id="container"&gt;&lt;/div&gt;&lt;link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"&gt;&lt;script src="https://imsun.github.io/gitment/dist/gitment.browser.js"&gt;&lt;/script&gt;&lt;script&gt;var gitment = new Gitment(&#123; id: 'location.href', // owner: 'rh01', repo: 'readailib', oauth: &#123; client_id: '3724d1f38c45d652612b', client_secret: 'cc24fc9ed88bf9eddd44f1319a7056e5d8690d12', &#125;,&#125;)gitment.render('container')&lt;/script&gt; Note：上面配置需要注意的是repo是指owner的github仓库，必须要存在！ 然后对\themes\hugo-lithium-theme\layouts\_default\single.html进行修改，注释掉引用disqus.html模板的语句，即如下所示. 12&lt;!-- &#123;&#123; partial "disqus.html" .&#125;&#125; --&gt;&#123;&#123; partial "gitment.html" .&#125;&#125; 设置完成之后，需要提交到你的gitpage上面进行渲染，然后才可以使用.可能需要首次授权之后才可以使用，最后完成之后是这样的. 图7 gitment完成之后的样子 3.gitalk首先Register a new OAuth application，填写要求 图8 Register a new OAuth application Principle 注册完成之后会返回下面的画面，记住client_id 和 client_secret就行了。 图9 记住client_id 和 client_secret 然后在 themes\hugo-lithium-theme\layouts\partials文件中添加一个新的文件gitalk.html，文件内容如下 123456789101112131415&lt;div id="gitalk-container"&gt;&lt;/div&gt;&lt;/div&gt;&lt;link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"&gt;&lt;script src="https://unpkg.com/gitalk/dist/gitalk.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var gitalk = new Gitalk(&#123; clientID: 'a98bac7d9ab86f4813de', clientSecret: '307c20444af8207286b5f78f7a5ed941786edad0', repo: 'readailib', owner: 'rh01', admin: ['rh01'], body: location.href, &#125;); gitalk.render('gitalk-container'); &lt;/script&gt; Note：上面配置需要注意的是repo是指owner的github仓库，必须要存在！ 然后对\themes\hugo-lithium-theme\layouts\_default\single.html进行修改，注释掉引用disqus.html模板和gitment.html的语句，即如下所示. 123&lt;!-- &#123;&#123; partial "disqus.html" .&#125;&#125; --&gt;&lt;!-- &#123;&#123; partial "gitment.html" .&#125;&#125; --&gt;&#123;&#123; partial "gitalk.html" .&#125;&#125; 设置完成之后，需要提交到你的gitpage上面进行渲染，然后才可以使用.可能需要首次授权之后才可以使用，最后完成之后是这样的. 图10 gitalk完成之后的样子 4.Conclusion本文主要介绍了完整配置，介绍比较匆匆，如果有什么问题可以在下面留言.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Welcome to ReadAILib]]></title>
      <url>%2F2017%2F12%2F14%2F2017-12-14-welcome-to-readailib%2F</url>
      <content type="text"><![CDATA[Hello Everyone, Welcome to ReadAILib. 大家好，本网站主要是由blogdown和Hugo生成的静态网站，为了方便起见，这里傻瓜式地照搬了yihui的模板（默认），这些都不是关键，本网站不是营利性网站，是一个学习交流性质的网站，主要方向为AI，虚拟化，集群，容器，DevOps，分布式，物联网等技术。 我会尽力将我所做过的和正在做的整理出来，以供学习和交流，广交有共同兴趣的朋友，如果你对我未来的设想或者我的博客内容有什么建议的，可以直接向我提供您有价值的建议，或者直接留言. 总之一句话，接受批评，接受建议!如果你未来期望与我合作，很期待你与我联系.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MNIST机器学习入门]]></title>
      <url>%2F2017%2F03%2F01%2FMNIST%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[MNIST 机器学习入门本教程的目标读者是对机器学习和TensorFlow 都不太了解的新手．如果你已经了解 MNIST 和 softmax 回归(softmax regression) 的相关知识，你可以阅读这个快速上手教程．当我们开始学习编程的时候，第一件事往往是学习打印“HelloWorld”．就好比编程入门有HelloWorld，机器学习入门有MNIST． MNIST 是一个入门级的计算机视觉数据集，它包含各种手写数字图片： 它也包含每一张图片对应的标签，告诉我们这个是数字几．比如，上面这四张图片的标签分别是5,0,4,1． 在此教程中，我们将训练一个机器学习模型用于预测图片里面的数字．我们的目的不是要设计一个世界一流的复杂模型—尽管我们会在之后给你源代码去实现一流的预测模型—而是要介绍下如何使用TensorFlow．所以，我们这里会从一个很简单的数学模型开始，它叫做 Softmax Regression. The MNIST Data |MNIST 数据集准备数据 123456789101112131415161718192021222324252627282930# file:input_data.py# Copyright 2015 Google Inc. All Rights Reserved.## Licensed under the Apache License, Version 2.0 (the "License");# you may not use this file except in compliance with the License.# You may obtain a copy of the License at## http://www.apache.org/licenses/LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an "AS IS" BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.# =============================================================================="""Functions for downloading and reading MNIST data."""from __future__ import absolute_importfrom __future__ import divisionfrom __future__ import print_functionimport gzipimport osimport tempfileimport numpyfrom six.moves import urllibfrom six.moves import xrange # pylint: disable=redefined-builtinimport tensorflow as tffrom tensorflow.contrib.learn.python.learn.datasets.mnist import read_data_sets 1minist = read_data_sets("MNIST_data/train-images-idx3-ubyte.gz/", one_hot=True) Extracting MNIST_data/train-images-idx3-ubyte.gz/train-images-idx3-ubyte.gz Extracting MNIST_data/train-images-idx3-ubyte.gz/train-labels-idx1-ubyte.gz Extracting MNIST_data/train-images-idx3-ubyte.gz/t10k-images-idx3-ubyte.gz Extracting MNIST_data/train-images-idx3-ubyte.gz/t10k-labels-idx1-ubyte.gz 1# print(minist) Datasets(train=&lt;tensorflow.contrib.learn.python.learn.datasets.mnist.DataSet object at 0x000001E562A14D30&gt;, validation=&lt;tensorflow.contrib.learn.python.learn.datasets.mnist.DataSet object at 0x000001E562A14630&gt;, test=&lt;tensorflow.contrib.learn.python.learn.datasets.mnist.DataSet object at 0x000001E562A14588&gt;) 下载下来的数据集可被分为三部分：55000 行训练用点数据集（mnist.train），10000 行测试数据集(mnist.test)，以及 5000 行验证数据集（mnist.validation）．这样的切分很重要：在机器学习模型设计时必须有一个单独的测试数据集不用于训练而是用来评估这个模型的性能，从而更加容易把设计的模型推广到其他数据集上（泛化）． 每一张图片包含28x28 像素．我们可以用一个数字数组来表示这张图片： 把这个数组展开成一个向量，长度是 28x28 = 784．如何展开这个数组（数字间的顺序）不重要，只要保持各个图片采用相同的方式展开．从这个角度来看，MNIST数据集的图片就是在 784 维向量空间里面的点, 并且拥有比较复杂的结构(注意: 此类数据的可视化是计算密集型的)． 展平图片的数字数组会丢失图片的二维结构信息．这显然是不理想的，最优秀的计算机视觉方法会挖掘并利用这些结构信息，会在后续教程中介绍．但是在这个教程中我们忽略这些结构，所介绍的简单数学模型，softmax 回归 (softmax regression)，不会利用这些结构信息． 因此，在MNIST 训练数据集中，minist.train.images 是一个形状为 [55000, 784] 的张量，第一个维度数字用来索引图片，第二个维度数字用来索引每张图片中的像素点．在此张量里的每一个元素，都表示某张图片里的某个像素的强度值，值介于 0 和 1 之间 相对应的MNIST 数据集的标签是介于0 到9 数字．为了用于这个教程，我们使标签数据是 “one-hot vectors”．一个 one-hot 向量除了某一位的数字是 1 其余各维度数字都是 0．所以在此教程中，数字n 将表示成一个只有在第 n 维度（从0 开始）数字为 1 的 10 维向量．比如，标签 0 将表示成 ([1,0,0,0,0,0,0,0,0,0,0])．因此，labels 是一个[55000, 10] 的数字矩阵． Softmax 回归介绍我们知道 MNIST 数据集的每一张图片都表示一个( 0 到 9 的) 数字．那么，如果模型若能看到一张图就能知道它属于各个数字的对应概率就好了。比如，我们的模型可能看到一张数字 “9” 的图片，就判断出它是数字 “9” 的概率为 80%，而有 5% 的概率属于数字 “8”（因为 8 和 9 都有上半部分的小圆），同时给予其他数字对应的小概率（因为该图像代表它们的可能性微乎其微）． 这是能够体现softmax 回归自然简约的一个典型案例．softmax 模型可以用来给不同的对象分配概率．在后文，我们训练更加复杂的模型时，最后一步也往往需要用softmax 来分配概率． softmax 回归（softmax regression）分两步：首先对输入被分类对象属于某个类的“证据”相加求和，然后将这个“证据”的和转化为概率. 我们使用加权的方法来累积计算一张图片是否属于某类的“证据”。如果图片的像素强有力的体现该图不属于某个类，则权重为负数，相反如果这个像素拥有有利的证据支持这张图片属于这个类，那么权值为正． 我们也需要引入额外的“证据”，可称之为偏置量(bias）。总的来说，我们希望它代表了与所输入向无关的判断证据．因此对于给定的输入图片x 代表某数字i 的总体证据可以表示为: $$ evidence_i = \sumj{W{i,j} x_j + b_i}$$ 其中，$W_i$ 代表权重，$b_i$ 代表第 i 类的偏置量，j 代表给定图片x 的像素索引用于像素求和．然后用 softmax 函数可以把这些证据转换成概率y: $$y = softmax(evidence)$$ 这里的softmax 可以看成是一个激励（activation）函数或是链接（link）函数，把我们定义的线性函数的输出转换成我们想要的格式，也就是关于10 个数字类的概率分布．因此，给定一张图片，它对于每一个数字的吻合度可以被softmax 函数转换成为一个概率值．softmax 函数可以定义为： $$softmax(x)i = normalize(exp(x))$$ 展开等式右边的子式，可以得到：$$softmax(x)_i = \frac{exp(x_i)}{\sum_j {exp(x)}}$$ 但是更多的时候把 softmax 模型函数定义为第一种形式：把输入值当成幂指数求值，再正则化这些结果值．这个幂运算表示，更大的证据对应更大的假设模型（hypothesis）里面的乘数权重值．反之，拥有更少的证据意味着在假设模型里面拥有更小的乘数系数．假设模型里的权值不可以是0 值或者负值．Softmax 然后会正则化这些权重值，使它们的总和等于 1，以此构造一个有效的概率分布．（更多的关于Softmax 函数的信息，可以参考 Michael Nieslen 的书里面的这个部分，其中有关于softmax 的可交互式的可视化解释．） 对于softmax 回归模型可以用下面的图解释，对于输入的xs 加权求和，再分别加上一个偏置量，最后再输入到 softmax 函数中： 更进一步，可以写成更加紧凑的方式：$$y = softmax(W_x + b)$$ 实现回归模型为了在 python 中高效的进行数值计算，我们通常会调用（如NumPy）外部函数库，把类似矩阵乘法这样的复杂运算使用其他外部语言实现．不幸的是，从外部计算切换回 Python 的每一个操作，仍然是一个很大的开销．如果你用GPU 来进行外部计算，这样的开销会更大．用分布式的计算方式，也会花费更多的资源用来传输数据. TensorFlow 也把复杂的计算放在python 之外完成，但是为了避免前面说的那些开销，它做了进一步完善．TensorFlow 不单独地运行单一的复杂计算，而是让我们可以先用图描述一系列可交互的计算操作，然后全部一起在Python 之外运行．（这样类似的运行方式，可以在不少的机器学习库中看到．） 使用TensorFlow 之前，首先导入它：1import tensorflw as tf 1import tensorflow as tf 我们通过操作符号变量来描述这些可交互的操作单元，可以用下面的方式创建一个：1x = tf.placeholder("float", [None, 784]) 1x = tf.placeholder('float',[None, 784]) x 不是一个特定的值，而是一个占位符 placeholder，我们在 TensorFlow 运行计算时输入这个值．我们希望能够输入任意数量(在图像，每一张图展平成784 维的向量．我们用2 维的浮点数张量来表示这些图，这个张量的形状是[None，784]．（这里的None表示此张量的第一个维度可以是任何长度的)123456我们的模型也需要权重值和偏置量，当然我们可以把它们当做是另外的输入（使用占位符，但TensorFlow 有一个更好的方法来表示它们：``Variable``．一个Variable 代表一个```可修改```的张量，存在在 ```TensorFlow``` 的用于描述交互性操作的图中．它们可以用于计算输入值，也可以在计算中被修改．对于各种机器学习应用，一般都会有模型参数，可以用 `Variable` 表示.```pythonW = tf.Variable(tf.zeros([784,10]))b = tf.Variable(tf.zeros([10])) 12W = tf.Variable(tf.zeros([784, 10])) # because output 784*10b = tf.Variable(tf.zeros([10])) 我们赋予tf.Variable 不同的初值来创建不同的 Variable：在这里，我们都用全为零的张量来初始化 W 和 b．因为我们要学习 W 和 b的值，它们的初值可以随意设置. 注意，W 的维度是[784，10]，因为我们想要用 784 维的图片向量乘以它以得到一个 10 维的证据值向量，每一位对应不同数字类．b 的形状是[10]，所以我们可以直接把它加到输出上面． 现在，可以实现我们的模型了，只需以下一行代码： 1y = tf.nn.softmax(tf.matmul(x,W) + b) 1y = tf.nn.softmax(tf.matmul(x, W) + b) 首先，我们用 tf.matmul(X，W)表示 $x$ 乘以$W$，对应之前等式里面的 $W_x$，这里 x 是一个 2 维张量拥有多个输入．然后再加上 $b$，把和输入到tf.nn.softmax函数里面. 至此，我们先用了几行简短的代码来设置变量，然后只用了一行代码来定义我们的模型．TensorFlow 不仅仅可以使 softmax 回归模型计算变得特别简单，它也用这种非常灵活的方式来描述其他各种数值计算，从机器学习模型对物理学模拟仿真模型．一旦被定义好之后，我们的模型就可以在不同的设备上运行：计算机的CPU，GPU，甚至是手机！ 训练模型为了训练我们的模型，我们首先需要定义一个指标来评估这个模型是好的．其实，在机器学习，我们通常定义指标来表示一个模型是坏的，这个指标称为成本（cost）或 损失（loss），然后尽量最小化这个指标．但是，这两种方式是相同的. 一个非常常见的，非常漂亮的成本函数是“交叉熵”(cross-entropy)．交叉熵产生于信息论里面的信息压缩编码技术，但是它后来演变成为从博弈论到机器学习等其他领域里的重要技术手段．它的定义如下： $$H_y’(y) = - \sum_i{y’_i log(y_i)}$$ $y$ 是我们预测的概率分布, $y’$ 是实际的分布（我们输入的one-hot vector)．比较粗糙的理解是，交叉熵是用来衡量我们的预测用于描述真相的低效性. 为了计算交叉熵，我们首先需要添加一个新的占位符用于输入正确值：1y_ = tf.placeholder("float", [None,10]) 1y_ = tf.placeholder('float',[None,10]) 然后我们可以用 $-\sum{y’ log (y)}$ 计算交叉熵:1cross_entropy = -tf.reduce_sum(y_*tf.log(y)) 首先，用 tf.log 计算 y 的每个元素的对数．接下来，我们把 y\_ 的每一个元素和 tf.log(y_) 的对应元素相乘．最后，用 tf.reduce_sum 计算张量的所有元素的总和. 值得注意的是，这里的交叉熵不仅仅用来衡量单一的一对预测和真实值，而是所有 100 幅图片的交叉熵的总和．对于 100 个数据点的预测表现比单一数据点的表现能更好地描述我们的模型的性能． 现在我们知道我们需要我们的模型做什么啦，用TensorFlow 来训练它是非常容易的．因为TensorFlow 拥有一张描述你各个计算单元的图，它可以自动地使用反向传播算法( backpropagation algorithm )来有效地确定你的变量是如何影响你想要最小化的那个成本值的．然后，TensorFlow 会用你选择的优化算法来不断地修改变量以降低成本. 1train_step = tf.train.GradientDescentOptimizer(0.01).minimize(cross_entropy) 在这里，我们要求TensorFlow 用梯度下降算法（gradient descent algorithm）以 0.01 的学习速率最小化交叉熵．梯度下降算法（gradient descent algorithm）是一个简单的学习过程，TensorFlow 只需将每个变量一点点地往使成本不断降低的方向移动．当然 TensorFlow 也提供了 其他许多优化算法：只要简单地调整一行代码就可以使用其他的算法. 12cross_entropy = - tf.reduce_sum(y_ * tf.log(y))train_step = tf.train.GradientDescentOptimizer(0.01).minimize(cross_entropy) TensorFlow 在这里实际上所做的是，它会在后台给描述你的计算的那张图里面增加一系列新的计算操作单元用于实现反向传播算法和梯度下降算法．然后，它返回给你的只是一个单一的操作，当运行这个操作时，它用梯度下降算法训练你的模型，微调你的变量，不断减少成本. 现在，我们已经设置好了我们的模型．在运行计算之前，我们需要添加一个操作来初始化我们创建的变量：1init = tf.global_variables_initializer() 现在我们可以在一个Session 里面启动我们的模型，并且初始化变量：12sess = tf.Session()sess.run(init) 然后开始训练模型，这里我们让模型循环训练1000 次！123for i in range(1000): batch_xs, batch_ys = mnist.train.next_batch(100) sess.run(train_step, feed_dict=&#123;x: batch_xs, y_: batch_ys&#125;) 该循环的每个步骤中，我们都会随机抓取训练数据中的 100 个批处理数据点，然后我们用这些数据点作为参数替换之前的占位符来运行 train_step. 使用一小部分的随机数据来进行训练被称为随机训练(stochastic training)—在这里更确切的说是随机梯度下降训练．理想情况下，我们希望用我们所有的数据来进行每一步的训练，因为这能给我们更好的训练结果，但显然这需要很大的计算开销．所以，每一次训练我们可以使用不同的数据子集，这样做既可以减少计算开销，又可以最大化地学习到数据集的总体特性． 12345678init = tf.global_variables_initializer()sess = tf.Session()sess.run(init)for i in range(1000): batch_xs, batch_ys = minist.train.next_batch(100) sess.run(train_step, feed_dict=&#123;x: batch_xs, y_: batch_ys&#125;) 评估我们的模型首先让我们找出那些预测正确的标签．tf.argmax() 是一个非常有用的函数，它能给你在一个张量里沿着某条轴的最高条目的索引值．比如，tf.argmax(y,1)是模型认为每个输入最有可能对应的那些标签，而 tf.argmax(y_,1) 代表正确的标签．我们可以用 tf.equal来检测我们的预测是否真实标签匹配．1correct_prediction = tf.equal(tf.argmax(y,1), tf.argmax(y_,1)) 这行代码会给我们一组布尔值．为了确定正确预测项的比例，我们可以把布尔值转换成浮点数，然后取平均值．例如，[True, False, True, True] 会变成 [1,0,1,1]，取平均值后得到 0.75.1accuracy = tf.reduce_mean(tf.cast(correct_prediction , "float")) 最后，我们计算所学习到的模型在测试数据集上面的正确率.1print sess.run(accuracy, feed_dict=&#123;x: mnist.test.images, y_: mnist.test.labels&#125;) 最终结果值应该大约是 91%. 这个结果好吗？嗯，并不太好．事实上，这个结果是很差的．这是因为我们仅仅使用了一个非常简单的模型．不过，做一些小小的改进，我们就可以得到97% 的正确率．最好的模型甚至可以获得超过 99.7% 的准确率！ 比结果更重要的是，我们从这个模型中学习到的设计思想．不过，如果你仍然对这里的结果有点失望，可以查看下个教程，在那里你将学到如何用 FensorFlow 构建更加复杂的模型以获得更好的性能！ 1234correct_porediction = tf.equal(tf.arg_max(y, 1), tf.arg_max(y_, 1))accuracy = tf.reduce_mean(tf.cast(correct_porediction,"float"))print(sess.run(accuracy, feed_dict=&#123;x: mnist.test.images, y_: mnist.test.labels&#125;)) 0.8996]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[tensorflow Tutotial:Start]]></title>
      <url>%2F2017%2F03%2F01%2FTensorFlow%20Tutotial-Start%2F</url>
      <content type="text"><![CDATA[使用图(graphs) 来表示计算. 在会话(Session) 中执行图. 使用张量(tensors) 来代表数据. 通过变量(Variables) 维护状态. 使用供给(feeds) 和取回(fetches) 将数据传入或传出任何操作. TensorFlow是一个以图(graphs) 来表示计算的编程系统, 图中的节点被称之为op (operation的缩写). 一个op 获得零或多个张量(tensors) 执行计算, 产生零或多个张量。 TensorFlow 的图是一种对计算的抽象描述。在计算开始前, 图必须在会话(Session()) 中被启动. 会话将图的op 分发到如CPU 或GPU 之类的设备(Devices()) 上, 同时提供执行op 的方法。这些方法执行后, 将产生的张量(tensor) 返回。 通常，TensorFlow 编程可按两个阶段组织起来: 构建阶段和执行阶段; 前者用于组织计算图，而后者利用session 中执行计算图中的op 操作。 123456789101112131415161718# 使用"with"句块开始一个会话，该会话将在"with"句块结束时自动关闭import tensorflow as tf from tfdot import tfdotwith tf.name_scope('inputs'): mat1 = tf.constant([[1,2]],name='mat1') mat2 = tf.constant([[1],[2]],name='mat2')with tf.name_scope('output'): result = tf.matmul(mat1, mat2,name='result') with tf.Session() as sess: print(sess.run(result)) tf.summary.FileWriter('logs/',sess.graph)tfdot() [[5]] TensorFlow 事实上通过一个“翻译”过程，将定义的图转化为不同的可用计算资源间实现分布计算的操作，如CPU 或是显卡GPU。通常不需要用户指定具体使用的CPU或GPU，TensorFlow 能自动检测并尽可能的充分利用找到的第一个GPU 进行运算。如果你的设备上有不止一个GPU，你需要明确指定op 操作到不同的运算设备以调用它们。使用with…Device语句明确指定哪个CPU 或GPU 将被调用:以下是例子 “/cpu:0”：计算机的CPU； “/gpu:0”：计算机的第一个GPU，如果可用； “/gpu:1”：计算机的第二个GPU，以此类推。 123456with tf.Session() as sess: with tf.device("/gpu:0"): mat1 = tf.constant([[3., 3.]]) mat2 = tf.constant([[2.],[2.]]) product = tf.matmul(mat1, mat2)# sess.run(product) 考虑到如IPython这样的交互式Python 环境的易用, 可以使用InteractiveSession 代替Session类, 使用Tensor.eval()和Operation.run() 方法代替Session.run(). 这样可以避免使用一个变量来持有会话. 1234567891011121314151617# Enter an interactive TensorFlow Session.import tensorflow as tfsess = tf.InteractiveSession()x = tf.Variable([1.0, 2.0])a = tf.constant([3.0, 3.0])# Initialize 'x' using the run() method of its initializer op.x.initializer.run()# Add an op to subtract 'a' from 'x'. Run it and print the resultsub = tf.subtract(x, a)print(sub.eval())# ==&gt; [¡2. ¡1.]# Close the Session when we're done.sess.close() [-2. -1.] 1from tfdot import tfdot 1tfdot() Variables | 变量变量维持了图执行过程中的状态信息 代码中assign()操作是图所描绘的表达式的一部分, 正如add()操作一样. 所以在调用run()执行表达式之前, 它并不会真正执行赋值操作. 12345678910111213141516171819202122# 建立一个变量， 用0初始化它的值state = tf.Variable(0, name='counter')# 创建加法运算单元One，并加到stateone = tf.constant(1)new_value = tf.add(state, one)update = tf.assign(state, new_value)# Variables must be initialized by running an `init` Op after having 12# launched the graph. We first have to add the `init` Op to the graph.init = tf.global_variables_initializer()# init_op = tf.initialize_all_variables() # 已废除# Launch the graph and run the ops.with tf.Session() as sess: sess.run(init) # print the value of 'state' print(sess.run(update)) # run the op that updates 'state and print 'state' for _ in range(3): sess.run(update) print(sess.run(state)) 1 2 3 4 Fetches | 取回为了取回操作的输出内容, 可以在使用Session 对象的run() 调用执行图时, 传入一些tensor, 这些tensor 会帮助你取回结果. 在之前的例子里, 我们只取回了单个节点state,但是你也可以取回多个tensor: Feeds | 供给feed 使用一个tensor 值临时替换一个操作的输出结果. 你可以提供feed 数据作为run() 调用的参数.feed 只在调用它的方法内有效, 方法结束, feed 就会消失. 最常见的用例是将某些特殊的操作指定为”feed” 操作, 标记的方法是使用1tf.placeholder() 为这些操作创建占位符 . 123456input1 = tf.placeholder(tf.float32)input2 = tf.placeholder(tf.float32)output = tf.multiply(input1, input2)with tf.Session() as sess: print(sess.run(output, feed_dict=&#123;input1:[7.], input2:[3.]&#125;)) [ 21.] 12with tf.Session() as sess: print(sess.run(output, feed_dict=&#123;*:*,*:*&#125; 占位符，传入的参数格式是字典]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[matplotlib tutorial - 1]]></title>
      <url>%2F2017%2F02%2F22%2Fmatplotlib%20tutorial%20-%201%2F</url>
      <content type="text"><![CDATA[matplotlib 教程（未更新完….） 12%matplotlib inlineimport matplotlib.pyplot as plt 12# 3 coordinates according to these lists: 1,5 2,7 and 3,4.plt.plot([1, 2, 3],[5, 7, 4]) [&lt;matplotlib.lines.Line2D at 0x7bfa278&gt;] 1234# 坐标（1，1），（1，2）import matplotlib.pyplot as pltplt.plot([1,1],[1,2])plt.show() 12345678910111213141516# Legends, Titles, and Labels with Matplotlibimport matplotlib.pyplot as pltx = [1,2,3]y = [5,7,4]x2 = [1,2,3]y2 = [10,14,12]plt.plot(x, y, label="First Line")plt.plot(x2, y2, label="Second Line")plt.xlabel('Plot Number')plt.ylabel('Important var')plt.title('Interesting Graph\nCheck it out')plt.legend() # 将label依附在图上plt.show() 123456789101112# Bar Charts # 条形图绘制import matplotlib.pyplot as pltplt.bar([1, 3, 5, 7, 9],[5, 2, 7, 8, 2], label="Example one")plt.bar([2, 4, 6, 8, 10],[8, 6, 2, 5, 6], label="Example two", color='g')plt.legend()plt.xlabel('bar number')plt.ylabel('bar height')plt.title('Epic Graph\nAnother Line! Whoa')plt.show() 123456789101112131415# Histograms with Matplotlib# 直方图绘制import matplotlib.pyplot as pltpopulation_ages = [22,55,62,45,21,22,34,42,42,4,99,102,110,120,121,122,130,111,115,112,80,75,65,54,44,43,42,48]# bins = [0,10,20,30,40,50,60,70,80,90,100,110,120,130]bins = [i*10 for i in xrange(14)] # 与上面同样的效果plt.hist(population_ages, bins, histtype='bar', rwidth=0.8)plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show() 1234567891011121314151617181920212223# Scatter Plots with Matplotlib# 散点图绘制# The plt.scatter allows us to not only plot on x and y, # but it also lets us decide on the color, size, # and type of marker we use. # There are a bunch of marker options, # see the Matplotlib Marker Documentation for all of your choices.# http://matplotlib.org/api/markers_api.htmlimport matplotlib.pyplot as pltx = [1,2,3,4,5,6,7,8]y = [5,2,4,2,1,4,5,2]# color='k' -&gt;black# s = 25 -&gt; size = 25p# maker -&gt; 标记 o -&gt; 实心原点plt.scatter(x,y, label='skitscat', color='k', s=25, marker="o")plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show() 1234567891011121314151617181920212223# Stack Plots with Matplotlib# 堆叠图绘制# The idea of stack plots is to show "parts to the whole" over time. # A stack plot is basically like a pie-chart, only over time.# consider a situation where we have 24 hours in a day, # and we'd like to see how we're spending out time. # We'll divide our activities into: Sleeping, eating, working, and playing.import matplotlib.pyplot as pltdays = [1,2,3,4,5]sleeping = [7,8,6,11,7]eating = [2,3,4,3,2]working = [7,8,7,2,2]playing = [8,5,7,8,13]plt.stackplot(days, sleeping,eating,working,playing, colors=['m','c','r','k'])plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.show() 12345678910111213141516171819202122232425262728293031# 上面的图形改进# 补充，color属性：# b: blue# g: green# r: red# c: cyan# m: magenta# y: yellow# k: black# w: whiteimport matplotlib.pyplot as pltdays = [1,2,3,4,5]sleeping = [7,8,6,11,7]eating = [2,3,4,3,2]working = [7,8,7,2,2]playing = [8,5,7,8,13]plt.plot([],[],color='m', label='Sleeping', linewidth=5)plt.plot([],[],color='c', label='Eating', linewidth=5)plt.plot([],[],color='r', label='Working', linewidth=5)plt.plot([],[],color='k', label='Playing', linewidth=5)plt.stackplot(days, sleeping,eating,working,playing, colors=['m','c','r','k'])plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show() 1234567891011121314151617# Pie Charts with Matplotlib# 饼状图import matplotlib.pyplot as pltslices = [7,2,2,13]activities = ['sleeping','eating','working','playing']cols = ['c','m','r','b']plt.pie(slices, labels=activities, colors=cols, startangle=90, shadow= True, explode=(0,0.1,0,0), autopct='%1.1f%%')plt.title('Interesting Graph\nCheck it out')plt.show() Note:在plt.pie函数中，我们指定“slices”-&gt;”切片”，这是指定每个部分的相应所占的比例大小。然后，我们指定相应切片的”color”列表。接下来，我们可以选择指定图形的“起始角度”。在我们的例子中，我们为饼图选择了一个90度角，这意味着第一个分割将是一个垂直线。接下来，我们可以选择添加一个阴影到一个字符的情节，然后我们甚至可以使用“explode”拉出一个切片。我们有四个总切片和一个拉出的切片，如果我们不想拉出任何切片，我们将做（0,0,0,0）。如果我们想要拉出第一个切片，我们将做（0.1,0,0,0）。最后，我们使用autopct选项来选择将百分比覆盖到图表本身。 12345678910111213141516171819# Loading Data from Files for Matplotlib# Step1: 准备数据data = '''1,52,33,44,75,46,37,58,79,410,4'''with open('example.txt','wb') as f: f.write(data) with open('example.txt','rb') as f: for line in f: print(line.strip()) 1,5 2,3 3,4 4,7 5,4 6,3 7,5 8,7 9,4 10,4 1234567891011121314151617181920# 从指定文件中获取数据并展示import matplotlib.pyplot as pltimport csvx = []y = []with open('example.txt','rb') as csvfile: plots = csv.reader(csvfile, delimiter=',') for row in plots:# print row x.append(int(row[0])) y.append(int(row[1]))plt.plot(x,y, label='Loaded from file!')plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show() 笔记：使用csv模块读取数据。 csv阅读器自动按行分割文件，然后通过指定选择在文件中的数据的分隔符。在这个例子中，这是一个,。注意：“csv”模块和csv.reader不需要文件在字面上是一个.csv文件。它可以是任何只包含分隔数据的文本文件。 1234567891011import matplotlib.pyplot as pltimport numpy as npx, y = np.loadtxt('example.txt', delimiter=',', unpack=True)plt.plot(x,y, label='Loaded from file!')plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# Data from the Internet for Matplotlibimport matplotlib.pyplot as pltimport numpy as npimport requestsimport matplotlib.dates as mdatesdef graph_data(stock): stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv' source_code = requests.get(stock_price_url).text.decode() stock_data = [] split_source = source_code.split('\n') for line in split_source: split_line = line.split(',') if len(split_line) == 6: if 'values' not in line: stock_data.append(line) date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data, delimiter=',', unpack=True, # %Y = full year. 2015 # %y = partial year 15 # %m = number month # %d = number day # %H = hours # %M = minutes # %S = seconds # 12-06-2014 # %m-%d-%Y converters=&#123;0: bytespdate2num('%Y%m%d')&#125;)# plt.plot_date(date, lowp,'-',color='r', label='Price') plt.plot_date(date, closep,'-', label='Price') plt.xlabel('x') plt.ylabel('y') plt.title('Interesting Graph\nCheck it out') plt.legend() plt.show()def bytespdate2num(fmt, encoding='utf-8'): strconverter = mdates.strpdate2num(fmt) def bytesconverter(b): s = b.decode(encoding) return strconverter(s) return bytesconverter graph_data('TSLA') 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# Basic customization with Matplotlibimport matplotlib.pyplot as pltimport numpy as npimport requestsimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'): strconverter = mdates.strpdate2num(fmt) def bytesconverter(b): s = b.decode(encoding) return strconverter(s) return bytesconverter def graph_data(stock): fig = plt.figure() ax1 = plt.subplot2grid((1,1), (0,0)) #(1,1)表示这是一个1×1网格。(0,0)是这个子图的“起点”将为(0,0)。 stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv' source_code = requests.get(stock_price_url).text.decode() stock_data = [] split_source = source_code.split('\n') for line in split_source: split_line = line.split(',') if len(split_line) == 6: if 'values' not in line and 'labels' not in line: stock_data.append(line) date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data, delimiter=',', unpack=True, converters=&#123;0: bytespdate2num('%Y%m%d')&#125;) ax1.plot_date(date, closep,'-', label='Price') for label in ax1.xaxis.get_ticklabels(): label.set_rotation(45) ax1.grid(True, color='0.75', linestyle='-', linewidth=0.5) # 添加网格 plt.xlabel('Date') plt.ylabel('Price') plt.title('Interesting Graph\nCheck it out') plt.legend() plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0) plt.show()graph_data('fb') 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# Basic customization with Matplotlibimport matplotlib.pyplot as pltimport numpy as npimport requestsimport datetime as dtimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'): strconverter = mdates.strpdate2num(fmt) def bytesconverter(b): s = b.decode(encoding) return strconverter(s) return bytesconverter def graph_data(stock): fig = plt.figure() ax1 = plt.subplot2grid((1,1), (0,0)) #(1,1)表示这是一个1×1网格。(0,0)是这个子图的“起点”将为(0,0)。 stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv' source_code = requests.get(stock_price_url).text.decode() stock_data = [] split_source = source_code.split('\n') for line in split_source: split_line = line.split(',') if len(split_line) == 6: if 'values' not in line and 'labels' not in line: stock_data.append(line) date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data, delimiter=',', unpack=True) dateconv = np.vectorize(dt.datetime.fromtimestamp) date = dateconv(date)# date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,# delimiter=',',# unpack=True,# converters=&#123;0: bytespdate2num('%Y%m%d')&#125;) ax1.plot_date(date, closep,'-', label='Price') for label in ax1.xaxis.get_ticklabels(): label.set_rotation(45) ax1.grid(True, color='0.75', linestyle='-', linewidth=0.5) # 添加网格 plt.xlabel('Date') plt.ylabel('Price') plt.title('Interesting Graph\nCheck it out') plt.legend() plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0) plt.show()graph_data('fb') 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# Colors and Fills with Matplotlibimport matplotlib.pyplot as pltimport numpy as npimport requestsimport datetime as dtimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'): strconverter = mdates.strpdate2num(fmt) def bytesconverter(b): s = b.decode(encoding) return strconverter(s) return bytesconverter def graph_data(stock): fig = plt.figure() ax1 = plt.subplot2grid((1,1), (0,0)) stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv' source_code = requests.get(stock_price_url).text.decode() stock_data = [] split_source = source_code.split('\n') for line in split_source: split_line = line.split(',') if len(split_line) == 6: if 'values' not in line and 'labels' not in line: stock_data.append(line) date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data, delimiter=',', unpack=True, converters=&#123;0: bytespdate2num('%Y%m%d')&#125;) ax1.fill_between(date, 0, closep) for label in ax1.xaxis.get_ticklabels(): label.set_rotation(45) ax1.grid(True)#, color='g', linestyle='-', linewidth=5) ax1.fill_between(date, 0, closep) ax1.xaxis.label.set_color('c') ax1.yaxis.label.set_color('r') ax1.set_yticks([0,25,50,75]) plt.xlabel('Date') plt.ylabel('Price') plt.title(stock) plt.legend() plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0) plt.show()graph_data('EBAY') C:\Users\Administrator\Anaconda2\lib\site-packages\matplotlib\axes\_axes.py:519: UserWarning: No labelled objects found. Use label=&apos;...&apos; kwarg on individual plots. warnings.warn(&quot;No labelled objects found. &quot; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import matplotlib.pyplot as pltimport numpy as npimport requestsimport datetime as dtimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'): strconverter = mdates.strpdate2num(fmt) def bytesconverter(b): s = b.decode(encoding) return strconverter(s) return bytesconverter def graph_data(stock): fig = plt.figure() ax1 = plt.subplot2grid((1,1), (0,0)) stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv' source_code = requests.get(stock_price_url).text.decode() stock_data = [] split_source = source_code.split('\n') for line in split_source: split_line = line.split(',') if len(split_line) == 6: if 'values' not in line and 'labels' not in line: stock_data.append(line) date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data, delimiter=',', unpack=True, converters=&#123;0: bytespdate2num('%Y%m%d')&#125;) ax1.plot_date(date, closep,'-', label='Price') ax1.plot([],[],linewidth=5, label='loss', color='r',alpha=0.5) ax1.plot([],[],linewidth=5, label='gain', color='g',alpha=0.5) ax1.fill_between(date, closep, closep[0],where=(closep &gt; closep[0]), facecolor='g', alpha=0.5) ax1.fill_between(date, closep, closep[0],where=(closep &lt; closep[0]), facecolor='r', alpha=0.5) for label in ax1.xaxis.get_ticklabels(): label.set_rotation(45) ax1.grid(True)#, color='g', linestyle='-', linewidth=5) ax1.xaxis.label.set_color('c') ax1.yaxis.label.set_color('r') ax1.set_yticks([0,25,50,75]) plt.xlabel('Date') plt.ylabel('Price') plt.title(stock) plt.legend() plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0) plt.show()graph_data('EBAY') 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# Spines and Horizontal Lines with Matplotlib# 脊和水平线import matplotlib.pyplot as pltimport numpy as npimport requestsimport datetime as dtimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'): strconverter = mdates.strpdate2num(fmt) def bytesconverter(b): s = b.decode(encoding) return strconverter(s) return bytesconverter def graph_data(stock): fig = plt.figure() ax1 = plt.subplot2grid((1,1), (0,0)) stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv' source_code = requests.get(stock_price_url).text.decode() stock_data = [] split_source = source_code.split('\n') for line in split_source: split_line = line.split(',') if len(split_line) == 6: if 'values' not in line and 'labels' not in line: stock_data.append(line) date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data, delimiter=',', unpack=True, converters=&#123;0: bytespdate2num('%Y%m%d')&#125;) ax1.plot_date(date, closep,'-', label='Price') ax1.plot([],[],linewidth=5, label='loss', color='r',alpha=0.5) ax1.plot([],[],linewidth=5, label='gain', color='g',alpha=0.5) ax1.axhline(closep[0], color='k', linewidth=5) ax1.fill_between(date, closep, closep[0],where=(closep &gt; closep[0]), facecolor='g', alpha=0.5) ax1.fill_between(date, closep, closep[0],where=(closep &lt; closep[0]), facecolor='r', alpha=0.5) for label in ax1.xaxis.get_ticklabels(): label.set_rotation(45) ax1.grid(True) #ax1.xaxis.label.set_color('c') #ax1.yaxis.label.set_color('r') ax1.set_yticks([0,25,50,75]) ax1.spines['left'].set_color('c') ax1.spines['right'].set_visible(False) ax1.spines['top'].set_visible(False) ax1.spines['left'].set_linewidth(5) ax1.tick_params(axis='x', colors='#f06215') plt.xlabel('Date') plt.ylabel('Price') plt.title(stock) plt.legend() plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0) plt.show()graph_data('ebay') 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# Candlestick OHLC graphs with Matplotlibimport matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcimport numpy as npimport requestsimport datetime as dtdef bytespdate2num(fmt, encoding='utf-8'): strconverter = mdates.strpdate2num(fmt) def bytesconverter(b): s = b.decode(encoding) return strconverter(s) return bytesconverter def graph_data(stock): fig = plt.figure() ax1 = plt.subplot2grid((1,1), (0,0)) stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1m/csv' source_code = requests.get(stock_price_url).text.decode() stock_data = [] split_source = source_code.split('\n') for line in split_source: split_line = line.split(',') if len(split_line) == 6: if 'values' not in line and 'labels' not in line: stock_data.append(line) date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data, delimiter=',', unpack=True, converters=&#123;0: bytespdate2num('%Y%m%d')&#125;) x = 0 y = len(date) ohlc = [] while x &lt; y: append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x] ohlc.append(append_me) x+=1 candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f') for label in ax1.xaxis.get_ticklabels(): label.set_rotation(45) ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) ax1.xaxis.set_major_locator(mticker.MaxNLocator(10)) ax1.grid(True) plt.xlabel('Date') plt.ylabel('Price') plt.title(stock) plt.legend() plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0) plt.show()graph_data('EBAY') 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# Styles with Matplotlibfrom matplotlib import styleimport matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcimport numpy as npimport requestsimport datetime as dtstyle.use('ggplot')def bytespdate2num(fmt, encoding='utf-8'): strconverter = mdates.strpdate2num(fmt) def bytesconverter(b): s = b.decode(encoding) return strconverter(s) return bytesconverter def graph_data(stock): fig = plt.figure() ax1 = plt.subplot2grid((1,1), (0,0)) stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1m/csv' source_code = requests.get(stock_price_url).text.decode() stock_data = [] split_source = source_code.split('\n') for line in split_source: split_line = line.split(',') if len(split_line) == 6: if 'values' not in line and 'labels' not in line: stock_data.append(line) date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data, delimiter=',', unpack=True, converters=&#123;0: bytespdate2num('%Y%m%d')&#125;) x = 0 y = len(date) ohlc = [] while x &lt; y: append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x] ohlc.append(append_me) x+=1 candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f') for label in ax1.xaxis.get_ticklabels(): label.set_rotation(45) ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) ax1.xaxis.set_major_locator(mticker.MaxNLocator(10)) ax1.grid(True) plt.xlabel('Date') plt.ylabel('Price') plt.title(stock) plt.legend() plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0) plt.show()graph_data('EBAY') 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from matplotlib import styleimport matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcimport numpy as npimport requestsimport datetime as dtdef bytespdate2num(fmt, encoding='utf-8'): strconverter = mdates.strpdate2num(fmt) def bytesconverter(b): s = b.decode(encoding) return strconverter(s) return bytesconverter def graph_data(stock,sty): style.use(sty) fig = plt.figure() ax1 = plt.subplot2grid((1,1), (0,0)) stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1m/csv' source_code = requests.get(stock_price_url).text.decode() stock_data = [] split_source = source_code.split('\n') for line in split_source: split_line = line.split(',') if len(split_line) == 6: if 'values' not in line and 'labels' not in line: stock_data.append(line) date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data, delimiter=',', unpack=True, converters=&#123;0: bytespdate2num('%Y%m%d')&#125;) x = 0 y = len(date) ohlc = [] while x &lt; y: append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x] ohlc.append(append_me) x+=1 # candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f') ax1.plot(date,closep) ax1.plot(date,openp) for label in ax1.xaxis.get_ticklabels(): label.set_rotation(45) ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) ax1.xaxis.set_major_locator(mticker.MaxNLocator(10)) ax1.grid(True) plt.xlabel('Date') plt.ylabel('Price') plt.title(stock) plt.legend() plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0) plt.show()graph_data('EBAY','fivethirtyeight')graph_data('EBAY','dark_background') 1234567891011121314151617181920212223242526# Live Graphs with Matplotlib%matplotlib inlineimport matplotlib.pyplot as pltimport matplotlib.animation as animationfrom matplotlib import stylestyle.use('fivethirtyeight')fig = plt.figure()ax1 = fig.add_subplot(1,1,1)def animate(i): graph_data = open('example.txt','r').read() lines = graph_data.split('\n') xs = [] ys = [] for line in lines: if len(line) &gt; 1: x, y = line.split(',') xs.append(x) ys.append(y) ax1.clear() ax1.plot(xs, ys) ani = animation.FuncAnimation(fig, animate, interval=1000)plt.show()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[爬虫实战第二节课笔记及相关代码]]></title>
      <url>%2F2017%2F02%2F19%2F%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E8%8A%82%E8%AF%BE%E7%AC%94%E8%AE%B0%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81%2F</url>
      <content type="text"><![CDATA[网络爬虫更新第二节课笔记 代码格式 强制缩进！Python开发者有意让违反了缩进规则的程序不能通过编译，以此来强制程序员养成良好的编程习惯。并且Python语言利用缩进表示语句块的开始和退出（Off-side规则），而非使用花括号或者某种关键字。增加缩进表示语句块的开始，而减少缩进则表示语句块的退出。缩进成为了语法的一部分。 根据PEP的规定，必须使用4个空格来表示每级缩进 我建议可以参考Google内部的python书写规范 基本语法 弱类型 变量必须先赋值再使用 小心引用！ 2和3的常见差异 xrange print 数据类型统一，取消unicode和long utf8: 3.x代码默认utf-8 12345# syntax.pya = 1234print(a)a = 'abcd'print(a) 1234 abcd 1234try: print(b)except Exception as e: print(e) name &apos;b&apos; is not defined 123456a = [1, 2, 3, 4]def fun(a): a[0] = 2fun(a)print a [2, 2, 3, 4] 12for i in xrange(10): print i, 0 1 2 3 4 5 6 7 8 9 12345try: # python 2.X支持 print 100, 200, 300, 400except Exception as e: print e 100 200 300 400 1234567891011import copya = [1, 2, 3, 4]def func(a): a[0] = 2fun(copy.deepcopy(a))print type(copy.deepcopy(a))print copy.copy(a)print a &lt;type &apos;list&apos;&gt; [1, 2, 3, 4] [1, 2, 3, 4] 关键字 常量 True False None 对象与容器 class import from del 逻辑操作 and or not 函数 def return 判断与循环控制 if elif else is in assert for while continue break 异常 raise try except finally with as 作用域 global nonlocal 匿名函数与协程 yield lambda 1234567# keywordassert(1 == 1)try: assert( 1 != 1)except Exception as e: print(e) 循环判断 注意加“:”！！！ 没有do-while循环 没有switch break是中断整个循环 continue是结束本次迭代进入下一个 1234567891011# loopscore = 80if score &gt; 90: print("A")elif score &gt; 80: print('B')elif score &gt; 70: print('C')else: print('不及格') C 1234total = 1while total != 10: print total, total += 3 # 没有++/-- 1 4 7 123456789101112131415161718# for 循环之作用于容器# 没有这种写法：# for(i = 0; i&lt; 100; i++)# #TODO# 上面这种循环只能用于while实现i = 0j = 0while i &lt; 3: j = 0 while j &lt; 3: if j == 2: j += 1 print(i, j), continue print(i, j), j += 1 i += 1 (0, 0) (0, 1) (0, 3) (1, 0) (1, 1) (1, 3) (2, 0) (2, 1) (2, 3) 函数 def定义函数 默认参数 名字参数 函数也是对象！！！ 函数式编程简介：map/reduce/lambda 12345678# fun.pydef hello(who='shenheng'): # print('hello ' + who ) print('hello %s'% who)hello('xiaoming')hello('sea')hello() hello xiaoming hello sea hello shenheng 1234567891011# f(x) = x * 5 + 100# g(x) = x * 5; f(x) = g(x) + 100# =&gt;f(g(x)) = x * 5def g(x): return x*5def f(g, x): return g(x) + 100print(f(g, 100))print(f(lambda x: x * 5, 100)) 600 600 1234567def g(x, y): return(x + y)def f(g, x, y): return g(x, y) + 100print(f(lambda x, y: x * y, 5, 5)) 125 容器 list：数组 tuple：只读数组 set：没有重复元素的数组 dict：字典（哈希表） 数组切片 字符串与数组的关系!!! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475## list# 遍历数组listlist_ = [1, 2, 3, 4]for i in list_: print(i)print '============*******=================' for i in range(1, 10, 2): print(i)print '============*******=================' # 按照下标索引访问数组print(list_[0])print '============*******================='# 向数组添加元素# append方法list_.append(1)list_.append(2)list_.append(3)list_.append(['abc','abcd'])list_.append([4, 5, 6])print list_print '============*******================='# 向数组添加元素（按照元素添加）li = [1, 2]li_a = [3, 4, 5]li.extend(li_a)print(li)print '============*******================='# 删除数组的元素li.pop() # 默认删除最后一个元素print(li)li.pop(2) #索引print(li)print '============*******================='# 排序li_b = [5, 8, 7, 6, 4]li_b.sort()print(li_b)print '============*******================='# lambda帮助排序# http://stackoverflow.com/questions/3766633/how-to-sort-with-lambda-in-pythonli = [[5, 2], [3, 8], [2, 11], [7, 6]]li.sort(key = lambda x:x[0]) # 一定要加上key =, sorted也可以的print(li)print '============*******================='li = [[5, 2], [3, 8], [2, 11], [7, 6]]def item_key(x): return x[0]li = sorted(li, key = item_key)print(li)print '==============End===================' 1 2 3 4 ============*******================= 1 3 5 7 9 ============*******================= 1 ============*******================= [1, 2, 3, 4, 1, 2, 3, [&apos;abc&apos;, &apos;abcd&apos;], [4, 5, 6]] ============*******================= [1, 2, 3, 4, 5] ============*******================= [1, 2, 3, 4] [1, 2, 4] ============*******================= [4, 5, 6, 7, 8] ============*******================= [[2, 11], [3, 8], [5, 2], [7, 6]] ============*******================= [[2, 11], [3, 8], [5, 2], [7, 6]] ==============End=================== 12345678# tuple# 可以理解为只读的数组,不可修改tp = (1, 2, 3)try: tp[0] = 100except Exception as e: print(e) &apos;tuple&apos; object does not support item assignment 123456# sets = set([1, 2, 3, 4, 5, 6, 7])print(s)s = set((1, 2, 3, 4, 5, 6, 7))print(s) set([1, 2, 3, 4, 5, 6, 7]) set([1, 2, 3, 4, 5, 6, 7]) 1234567891011121314# dict字典# 哈希表# key&lt;-&gt;value对应的哈希表di = &#123;'k1':'v1', 'k2':'v2'&#125;di['k3'] = 'v3'di['k4'] = 'v4'print '============Method1================='for k in di: print(di[k])print '============Method2=================' for i,j in di.items(): print(i, j) ============Method1================= v3 v2 v1 v4 ============Method2================= (&apos;k3&apos;, &apos;v3&apos;) (&apos;k2&apos;, &apos;v2&apos;) (&apos;k1&apos;, &apos;v1&apos;) (&apos;k4&apos;, &apos;v4&apos;) 12345678910111213141516171819# 数组切片# ex:[1 , 2, 3, 4, 5, 6] -&gt; [3, 4, 5]li = [1 , 2, 3, 4, 5]li_0_2 = li[0:3] # 0&lt;= ? &lt;3# 等价于li[:3]print li_0_2# [start, end, step] =&gt; [start, start + stgep, ...,&lt; end]# 默认是0， end默认是-1，step默认1li_0_3 = li[-1: -4: -1] # # print li_0_3# 直接利用切片反转数组print(li[::-1])print(li[-2::-1])# 切片是复制li_0_2[-1] = 100print li_0_2 [1, 2, 3] [5, 4, 3, 2, 1] [4, 3, 2, 1] [1, 2, 100] 1234567891011121314151617181920212223242526# 字符串str = 'abcdefg'try: str[0] = 'x'except Exception as e: print(e) # 修改字符串li = list(str)# print(li)s = ''.join(li)print sprint(type(s))s = '-'.join(li)print(s)# 切割s = 'abc,def,ghi'p1, p2, p3 = s.split(',')print( p1, p2, p3)# 下标访问和切割print(s[1])print(s[1:4]) &apos;str&apos; object does not support item assignment abcdefg &lt;type &apos;str&apos;&gt; a-b-c-d-e-f-g (&apos;abc&apos;, &apos;def&apos;, &apos;ghi&apos;) b bc, 面向对象 一切皆对象 获取对象信息：type和dir class声明对象 重要的self！！！ 继承与多态（什么是鸭子类型？） 12345# 用type查看对象类型print(type([1, 2, 4, 6]))print(type((1, 2, 4, 6)))print(type('strrr'))print(type(&#123;'1':'2'&#125;)) &lt;type &apos;list&apos;&gt; &lt;type &apos;tuple&apos;&gt; &lt;type &apos;str&apos;&gt; &lt;type &apos;dict&apos;&gt; 12# 用dir查看属性和方法print(dir(list)) [&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;, &apos;__delattr__&apos;, &apos;__delitem__&apos;, &apos;__delslice__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__getslice__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__iadd__&apos;, &apos;__imul__&apos;, &apos;__init__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__reversed__&apos;, &apos;__rmul__&apos;, &apos;__setattr__&apos;, &apos;__setitem__&apos;, &apos;__setslice__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;append&apos;, &apos;count&apos;, &apos;extend&apos;, &apos;index&apos;, &apos;insert&apos;, &apos;pop&apos;, &apos;remove&apos;, &apos;reverse&apos;, &apos;sort&apos;] 123456789101112class Clazz(object): # self参考C++中的this指针 def __init__(self, x, y): self.x = x self.y = y # 声明成员函数的时候，第一个参数一定时self def display(self): print(self.x, self.y)print(type(Clazz))clz = Clazz(100, 200)clz.display() # 等价于display(clzz) &lt;type &apos;type&apos;&gt; (100, 200) 123456789101112# 继承class Base: def run(self): print('Base::run')class Tom: def run(self): print('tom::run')t = Tom()# 判断是否是基类型t.run() tom::run 1234567891011121314def run(runner): runner.run() class R1: def run(self): print('R1::run') class R2: def run(self): print('R2::run')run(R1())run(R2()) R1::run R2::run 文件读写 文本文件读写 二进制文件读写 string与bytes 文件和目录操作 1234567# 文本文件的读写f = open('text.txt','r')# print(f.read())# while f.readline()!=for i in f.readlines(): # print i, print(i.strip()) 1234 abcd edfg 12345# 另一种常用方法with open('text.txt') as f: print(dir(f)) for line in f.readlines(): print line, [&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__doc__&apos;, &apos;__enter__&apos;, &apos;__exit__&apos;, &apos;__format__&apos;, &apos;__getattribute__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__iter__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;close&apos;, &apos;closed&apos;, &apos;encoding&apos;, &apos;errors&apos;, &apos;fileno&apos;, &apos;flush&apos;, &apos;isatty&apos;, &apos;mode&apos;, &apos;name&apos;, &apos;newlines&apos;, &apos;next&apos;, &apos;read&apos;, &apos;readinto&apos;, &apos;readline&apos;, &apos;readlines&apos;, &apos;seek&apos;, &apos;softspace&apos;, &apos;tell&apos;, &apos;truncate&apos;, &apos;write&apos;, &apos;writelines&apos;, &apos;xreadlines&apos;] 1234 abcd edfg 模式 描述 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 w 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写 12345678# with open('text.txt','rb') as f:# print(f.read())# mode s = 'abcdef'b = bytes(s)print(b)with open('text.txt','a') as f: f.write('\n'+s) abcdef 123with open('text.txt','r') as f: for i in f.readlines(): print i, 1234 abcd edfg abcdef abcdef 多线程 多线程 多进程 线程同步 多线程编程经验 123456789101112131415#多线程import threadingdef thread_func(x): print('%d'% (x * 100))threads = []for i in range(5): threads.append(threading.Thread(target= thread_func,args=(100,)))# 一定加逗号100，for thread in threads: thread.start() for thread in threads: thread.join() 10000 10000 10000 10000 10000 错误和异常处理 为什么要使用异常？ 如何自定义异常 logging库使用 123456789101112131415161718# 错误处理import logging'''作业：自己实现将不同的等级的信息写到不同的日志文件logging.info(...)logging.debug(...)'''try: r = 10 / 0except ZeroDivisionError as e: print(type(e)) print(e)finally: # 主要防止资源泄露！ print('Always come here.') &lt;type &apos;exceptions.ZeroDivisionError&apos;&gt; integer division or modulo by zero Always come here.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[爬虫实战第一节课笔记及相关代码]]></title>
      <url>%2F2017%2F02%2F18%2F%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE%E7%AC%94%E8%AE%B0%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81%2F</url>
      <content type="text"><![CDATA[网络爬虫更新第一节课笔记 什么是网络爬虫 定义 网络爬虫（又称为网页蜘蛛，网络机器人，在FOAF社区之间更经常地称为网页追随者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。 由于专门用于信息检索的“机器人程序”像蜘蛛一样在网络之间爬来爬去，因此，搜索引擎的“机器人”程序就被称为“蜘蛛”程序 历史 1990年，蒙特利尔大学学生Alan Emtage发明的Archie，用于搜索分散的FTP主机上的资源。 1993年，内华达大学受启发开发了类似工具，但是开始支持网页搜索。 Martin Koster于1993年10月创建了ALIWEB，它是Archie的HTTP版本。ALIWEB不使用“机器人”程序，而是靠网站主动提交信息来建立自己的链接索引，类似于现在我们熟知的Yahoo。 Yahoo, Google, Baidu, Bing… 使用Python写爬虫的好处 上手容易！！！ 免费开源，使用不受限制。 解释执行，跨平台不受限制。 面向对象 框架和库支持丰富，有大量的历史积累。 Python开发环境搭建和简介 Python简介 官网：https://www.python.org/ 作者：Guido van Rossum 名字来源：Monty Python’s Flying Circus（和蟒蛇无关啊！） 作者为什么发明Python：平衡C和Shell 版本选择：2.7和3.5，更低版本不推荐使用。2.x和3.x的区别暂时不用关心。 Python环境搭建 Windows可去官网下载安装包：2.7.12或3.5.2 Mac 系统自带 通过homebrew和pyenv安装并维护多个Python版本，参考链接。 Linux系统自带，或参考上面链接使用pyenv安装并维护多个Python版本 使用pip安装第三方包，命令为pip install package（注：Mac下需要打开sudo，参考链接。） 新版本Mac系统可能因为SIP，需要在命令行后增加–user参数 遇到GFW可以使用国内源（推荐豆瓣），命令行为pip install package -i –trusted-host http://pypi.douban.com/simple/ HTTP简介 HTTP = HyperText Transfer Protocol URI = Uniform Resource Identifier URL = Uniform Resource Locator URI和URL的区别：URI强调的是资源，而URL强调的是资源的位置。 常用请求类型 OPTIONS: 返回服务器针对特定资源所支持的http请求方法。 HEAD: 向服务器索要与get请求相一致的响应，只不过响应体将不会被返回。 GET: 向特定资源发出请求 PUT: 向指定资源位置上传其最新内容 POST: 向指定资源提交数据进行处理请求 DELETE: 请求服务器删除指定URI所标识的资源 PATCH: 用来将局部修改应用于某一资源 HTML (Hypertext Markup Language) 推荐教程：HTML HTML不是编程语言，而是一种标记语言。即HTML使用标记标签来描述网页。 标签和元素 DOM文档模型 1234567891011121314151617&lt;标签 属性="属性的值"&gt;&lt;/标签&gt;比如：&lt;a href="www.baidu.com"&gt;&lt;a&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;/h1&gt;....DOM文档模型：文本&lt;body&gt; - 段落1 &lt;p&gt;...&lt;/p&gt; - 列表 &lt;ul&gt;...&lt;/ul&gt; - 图片 &lt;img src=""&gt; &lt;/img&gt; - 文本 -段落2 - 列表 - ... XML (eXtensible Markup Language) 推荐教程：XML 树结构 12345678910ROOT - E1 - G1 - G1 -&gt; 属性/值 - E2 - E3 &lt;node attr=value&gt;...&lt;/node&gt;[ROOT][E1][G1].text[ROOT][E2][G1].text Json (JavaScript Object Notation) 推荐教程：Json 语法类似XML，但是更小、更快、更容易解析。对JavaScript特别友好。 MySQL Windows: 下载免费社区版mysql server。 客户端操作可以使用MySQLWorkbench。 Linux（以debian为例） 1.apt-get install mysql-server mysql-client 2.登陆mysql: mysql -p hostname -u username -p，然后使用use dbname指定需要操作的数据库 3.安装phpmyadmin方便在浏览器操作数据库 MySQL常用命令 show databases: 显示当前服务器上的数据库 create database dbname: 创建一个新数据库 use dbname: 使用指定的数据库 show tables: 显示当前数据库的所有表 desc tbname: 显示表结构 SQLite Windows直接去下载可执行文件即可使用，Linux下apt-get install sqlite3即可完成安装。 相比mysql更加轻便好用。 大数据情况下效率变差，适合单机小程序。 爬虫框架介绍工作流程 将种子URL放入队列 从队列中获取URL，抓取内容。 解析抓取内容，将需要进一步抓取的URL放入工作队列，存储解析后的内容 抓取策略 深度优先 广度优先 PageRank 大站优先策略 如何去重 Hash表 bloom过滤器 123456789101112131415161718192021222324252627282930313233343536373839404142news.sina.com.cn1.sina.com.cn2.sina.com.cnnews.sina.com.cn - 专题1 - news11 - news12 - news13 - 专题2 - news21 - news22 - news23DFS（深度）:working专题1111213working专题2212223BFS（广度）：working专题1专题2111213212223PageRank:给网页打值 Robots规范与原则Robots规范 Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。Robots协议的本质是网站和搜索引擎爬虫的沟通方式，用来指导搜索引擎更好地抓取网站内容，而不是作为搜索引擎之间互相限制和不正当竞争的工具。 详情：http://baike.so.com/doc/4854891-5072162.html 爬虫质量标准 分布式 可伸缩性 性能和有效性 质量 新鲜性 更新 可扩展性 扯得远点 Map/Reduce背后 例子1目标：获取某一个省的邮编区号目标网站： www.ip138.com/post/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestsimport xml.etree.ElementTree as ETfrom xml.parsers.expat import ParserCreateclass DefaultSaxHandler(object): def __init__(self, provinces): self.provinces = provinces # 处理标签开始 def start_element(self, name, attrs): if name != 'map': name = attrs['title'] number = attrs['href'] self.provinces.append((name, number)) # 处理标签结束 def end_element(self, name): pass # 文本处理 def char_data(self, text): pass def get_province_entry(url): # 获取文本，并用gb2312解码 content = requests.get(url).content.decode('gb2312') # 确定要查找字符串的开始结束位置，并用切片获取内容。 start = content.find('&lt;map name=\"map_86\" id=\"map_86\"&gt;') end = content.find('&lt;/map&gt;') content = content[start:end + len('&lt;/map&gt;')].strip().encode('utf8') provinces = [] # 生成Sax处理器 handler = DefaultSaxHandler(provinces) # 初始化分析器 parser = ParserCreate() parser.StartElementHandler = handler.start_element parser.EndElementHandler = handler.end_element parser.CharacterDataHandler = handler.char_data # 解析数据 parser.Parse(content) # 结果字典为每一页的入口代码 return provincesprovinces = get_province_entry('http://www.ip138.com/post')for i in provinces: print(i[0],i[1]) 新疆 /83/ 西藏 /85/ 青海 /81/ 甘肃 /73/ 四川 /61/ 云南 /65/ 宁夏 /75/ 内蒙古 /01/ 黑龙江 /15/ 吉林 /13/ 辽宁 /11/ 河北 /50/ 北京 /10/ 天津 /30/ 陕西 /71/ 山西 /03/ 山东 /25/ 河南 /45/ 重庆 /40/ 湖北 /43/ 安徽 /23/ 江苏 /21/ 上海 /20/ 贵州 /55/ 广西 /53/ 湖南 /41/ 江西 /33/ 浙江 /31/ 福建 /35/ 广东 /51/ 海南 /57/ 台湾 /taiwang/ 澳门 /aomen/ 香港 /xianggang/ 例子2抓取股票信息 1234567891011121314151617181920212223242526272829303132333435import requestsimport threadingdef display_info(code): url = 'http://hq.sinajs.cn/list=' + code response = requests.get(url).text print(response) def single_thread(codes): for code in codes: code = code.strip() display_info(code)def multi_thread(tasks): # 用列表推导生成线程，注意codes后面的‘，’! threads = [threading.Thread(target = single_thread, args = (codes,)) for codes in tasks] # 启动线程 for t in threads: t.start() # 等待线程结束 for t in threads: t.join()# 注意main函数的形式if __name__ == '__main__': codes = ['sh600001', 'sh600002', 'sh600003', 'sh600004', 'sh600005', 'sh600006'] # 计算每个线程要做多少工作 thread_len = int(len(codes) / 4) t1 = codes[0: thread_len] t2 = codes[thread_len: thread_len * 2] t3 = codes[thread_len * 2: thread_len * 3] t4 = codes[thread_len * 3:] # 多线程启动 multi_thread([t1, t2, t3, t4]) var hq_str_sh600001=&quot;&quot;; var hq_str_sh600002=&quot;&quot;; var hq_str_sh600003=&quot;&quot;; var hq_str_sh600004=&quot;白云机场,14.480,14.480,14.330,14.510,14.320,14.320,14.330,4926788,70978480.000,35700,14.320,30700,14.310,60300,14.300,52400,14.290,20400,14.280,4200,14.330,20300,14.340,14100,14.350,2500,14.360,5702,14.370,2017-02-17,15:00:00,00&quot;; var hq_str_sh600005=&quot;武钢股份,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0,0.000,0,0.000,0,0.000,0,0.000,0,0.000,0,0.000,0,0.000,0,0.000,0,0.000,0,0.000,0,0.000,2017-02-17,09:14:18,00&quot;; var hq_str_sh600006=&quot;东风汽车,7.000,7.020,7.160,7.350,6.940,7.150,7.160,34238293,243779395.000,41100,7.150,160200,7.140,81600,7.130,289391,7.120,81200,7.110,150971,7.160,235900,7.170,235000,7.180,228890,7.190,403400,7.200,2017-02-17,15:00:00,00&quot;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[申请Coursera助学金-干货]]></title>
      <url>%2F2017%2F02%2F16%2F%E7%94%B3%E8%AF%B7Coursera%E5%8A%A9%E5%AD%A6%E9%87%91-%E5%B9%B2%E8%B4%A7%2F</url>
      <content type="text"><![CDATA[对于没有钱的学生党来说，Coursera的课程太贵，没有办法，只能通过申请助学金来实现正规的学习，过去Coursera还支持旁听，现在没有了，无奈的我们只能通过Apply Finitial Aid来学习了，想想都痛苦 申请助学金在哪申请？？恐怕很多童鞋们都找不到如何申请助学金的链接，不过没关系，哥哥告诉你，哈哈，:) 具体操作步骤：1. 打开你想申请的课程网站比如，莱斯大学著名的IIPP课程（已完成），课程网站为An Introduction to Interactive Programming in Python(Part 1) IIPP课程已经更新了他原来的界面，我个人感觉这种界面还是很不错的.这门课是隶属莱斯大学计算机基础的专项课程的第一门课，But这只是Part1，尼玛，还有Part2吗，恭喜你，答对了，由于照顾到部分同学的学习的压力，所以将IIPP划分为两门课来上，另外Part1和Part2的差距对我来说，难度跨越有点大，所以希望大家继续努力，。。。。跑偏主题了，快回来。。。 点击右边的注册按钮，同学们会发现下面的这种情况 OK，你们会看到有旁听选项，我个人认为仅旁听激不起你学习的的动力，另外这门课成绩必须在规定的时间（1 week）完成，如果过期，那么不好意思，请移步下一期课程，但是再看看前面的两个选项，尼玛，这也太贵了吧，59刀。。。 2. 寻找申请助学金链接 你看看这弄得也忒隐蔽了吧，还好我眼睛比较尖锐，哈哈，Andrew Ng是不是故意的,呵呵~ 3. 言归正传,开始申请吧点击链接,我们会转到申请助学金的页面, 不错,就是它,如果你们看到这了,会产生两个疑问,中文写还是英文?? 当然英文了,对于英文弱的要死要死的我们,肿么办?? 4. 干货来了要注意的是： 首先按照自个儿的经济情况书写，国家不要填错！ 下面是一超链接，大家都懂得！干货，别说我没告诉你！ 5. 终于完工了具体的页面如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RStudio在使用Github时出现的问题的解决方案]]></title>
      <url>%2F2017%2F02%2F16%2FRStudio%E5%9C%A8%E4%BD%BF%E7%94%A8Github%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
      <content type="text"><![CDATA[在使用Github时，往往出现这种情况，我在使用Github client时，比如 Android Studio，Github Desktop，Rstudio，PyCharm 等等时，我为了工程项目更好的同步到我的github 上，往往使用客户端的 Git Push 比较迅速，但是在配置方面，很麻烦，所以在我配置的时候出现了这样一则错误， unable to read askpass response from… ,结合网上资源，将解决方案放出！ 当我尝试着从RStudio IDE中push到github的时候，遇到了以下的错误信息. 123error: unable to read askpass response from &apos;rpostback-askpass&apos;fatal: could not read Username for &apos;https://github.com&apos;: No such device or address RStduio也有我的源 1https://github.com/rh01/calendar.git RStudio 不允许我改变版本控制系统的源（主要在这里灰色显示），如下图所示： 我尝试了很多方法去解决该问题，在 stackoverflow 收到启发，根据我的情况，作出了以下的方案解决上述问题 我根据之前的经验，看到我之前已经正常工作的RProject的configuration 于是我在本地计算机中删除了本地clone的repo.然后重新克隆github中源 然后我在RStudio中 click New Project -&gt; Existing Directory OKay,It’s Works.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈latex]]></title>
      <url>%2F2017%2F02%2F16%2F%E6%B5%85%E8%B0%88latex%2F</url>
      <content type="text"><![CDATA[LaTeX是在克努特老先生（注：他的著作有TeX系统，计算机程序设计艺术）发明出来TeX系统的基础之上完善的。刚开始主要适用于文章和数学公式的排版。他是我最喜欢的排版技术之一。TeX系统是在1982年发布的。目前的TeX系统的版本不断修正，们目前的版本号不断接近 $\pi$. LaTeXLaTeX是一个宏包，目的是使作者能够利用一个预先定义好的专业页面设置，从而得以高质量的排版个打印他们的作品。 LaTeX基础作者图书设计者和排版者出版的第一步是将他们的手稿交给出版公司，然后图书设计者来决定这个本书的版面形式（包括栏宽、字体、标题前后的间距······）。图书设计者会把他的排版说明写进手稿里，一起交给排版者，排版者左后根据这些说明完成这本书的排版工作。 一个图书设计者要试图理解作者写作时意图他要根据手稿的内容和他自己的职业知识决定章节标题，文献引用、例子、公式等等。 在LaTeX环境下，LaTeX代替了图书设计者的角色，TEX则是他的排版者，但是LaTeX“仅仅”是一个计算机程序，他需要更多的指导。作者必须在他的作品中提供附加信息，用于描述作品的逻辑结构。这些信息是通过“LaTeX命令”写入文章中的。 在使用LaTeX的时候，一般来说是不能在输入文章的同时看到组中的效果的（对比~WYSIWYG）。但是在屏幕上预览最终的输出效果的，因此在真正打印文档之前是可以对其进行修改的。 版面设计如果排印好的文档从艺术角度看来不错，就说明设计是成功的。 优势与不足MSWord和LaTeX的对比 优势 提供专业级的排版设计，使你的文档看起来如同印刷好的一样。 可以更方便的盘版数学公式。 用户仅仅需要掌握少数容易理解的，用来说明文档之逻辑结构的命令，无需对实际的页面设计做胡乱的修补。 可以很容易的神农谷成脚注、索引、目录和参考文献等复杂的结构。 有大量免费地可添加宏集，协助你完成许多基本的LaTeX为直接支持的排版任务。 LaTeX鼓励作者写作具有良好结构的文章，因为LaTeX就是哦那个过详细地说明文章的结构进行排版工作的。 TEX作为LaTeX的格式化引擎是免费软件，且具有极高的可移植性。 不足 对于出卖其灵魂的人来说，LaTeX不能很好的工作。 尽管预先定义好的版面可以调节一些参数，设计全新的版面还是很困难的，需要耗费大量的时间。 LaTeX不适合排本非结构化的，无序的文档。 参考文献[1] 一份不太简短的$LaTeX$2的介绍,Tobias Oetiker,中国CTEX用户小组，2002]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Soft修正函数]]></title>
      <url>%2F2017%2F02%2F16%2FSoft%E4%BF%AE%E6%AD%A3%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[softmax 模型和激活函数 12345678910111213141516171819"""Softmax."""scores = [3.0, 1.0, 0.2]import numpy as npdef softmax(x): """Compute softmax values for each sets of scores in x.""" pass # TODO:Compute and return softmax(x)print(softmax(scores))# Plot softmax curvesimport matplotlib.pyplot as pltx = np.arange(-2.0, 6.0, 0.1)scores = np.vstack([x, np.ones_like(x), 0.2 * np.ones_like(x)])plt.plot(x, softmax(scores).T, linewidth=2)plt.show() Softmax 模型 Note: softmax(x) 函数应该返回一个形状和x相同的NumPy array类型。 例如，当输入为一个列表或者一维矩阵（用列向量表示一个样本样本）时，比如说以下的： 1scores = [1.0, 2.0, 3.0] 应该返回一个同样长度（即3个元素）的一维矩阵： 1print softmax(scores) 1[ 0.09003057 0.24472847 0.66524096] 对于一个二维矩阵，如以下（列向量表示单个样本），例如: 1scores = np.array([[1, 2, 3, 6],[2, 4, 5, 6],[3, 8, 7, 6]]) 该函数应该返回一个同样大小(3,4)的二维矩阵，如以下: 123[[ 0.09003057 0.00242826 0.01587624 0.33333333] [ 0.24472847 0.01794253 0.11731043 0.33333333] [ 0.66524096 0.97962921 0.86681333 0.33333333]] 每个样本（列向量）中的概率加起来应当等于 1。 解决方案： 123def softmax(x): &quot;&quot;&quot;Compute softmax values for each sets of scores in x.&quot;&quot;&quot; return np.exp(x) / np.sum(np.exp(x), axis = 0) 运行结果: 1[ 0.8360188 0.11314284 0.05083836] 笔记： 两个数学函数 np.sum()： np.exp()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[笔记1-从机器学习到深度学习-两个问题]]></title>
      <url>%2F2017%2F02%2F16%2F%E7%AC%94%E8%AE%B01-%E4%BB%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%B0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[这篇笔记主要摘出一部分的问题和解决方案来谈谈我学习 Deep Learning 时的一些感想和收获。 行人检测任务问题是： 假设你在你的车上有一个摄像头拍摄前面的街道，你想检测你前面的行人在哪？保证你不撞到他们，你怎么能通过一个分类器实现呢？ Answer：（我的想法） 首先选择一些标记了正负标记的样本（Positive：行人，Negative：杂讯），用于训练行人检测分类模型，然后利用训练好的模型来检测街道是否有行人。 导师给出的答案: A typical method is to run a binary classifier over different areas of an image, and mark the areas with a positive label as detected instances. 一种把这个检测问题转化为分类问题的方法是，一个分类器将图片中的小块分成两类，行人或者非行人，你就可以对图片多次执行这个分类器，每当它的输出为行人时就告诉你你所需要的行人位置！ 用于排名的分类（有时候也成为竞价排名）问题是 网页搜索排序,假设你有一个搜索请求,你想找到在网站上所有跟请求相关的网页,你怎么使用一个分类器实现？ 解决方案： 使分类器接收成对的搜索请求和网站,输出则是两类中的其中一个 相关或者不相关当然 如果你在整个网络中运行分类器,将会有无数的网页需要查看,但是搜索引擎将会走捷径,仅尝试分类那些比较有可能的候选网站.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用机器学习实现数字识别及分类]]></title>
      <url>%2F2017%2F02%2F16%2F%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB%E5%8F%8A%E5%88%86%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[利用opencv对图像进行边缘检测，轮廓检测等等，人工构建特征和训练集，结合 Euclidean distance 来计算相似度，进而可实现0～9的数字的分类。 1%matplotlib inline 1234import matplotlib.pyplot as pltimport cv2img = cv2.imread("CaptchaImage.jpg")plt.imshow(img) &lt;matplotlib.image.AxesImage at 0x6e77e10&gt; 1234import numpy as npkernel = np.ones((4,4), np.uint8)erosion = cv2.erode(img, kernel, iterations = 1)plt.imshow(erosion) &lt;matplotlib.image.AxesImage at 0x74a64e0&gt; 123456blurred = cv2.GaussianBlur(erosion, (5, 5), 0) #高斯滤波器滤掉杂讯edged = cv2.Canny(blurred, 30, 150) # Canny算子来实现边缘检测dilation = cv2.dilate(edged, kernel, iterations = 1) # opencv膨胀算子实现填充效果,还原回来正常的效果plt.imshow(dilation) &lt;matplotlib.image.AxesImage at 0x768a5c0&gt; 1234567891011# 检测她的轮廓image, contours, hierarchy = cv2.findContours(dilation.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE) # 将资料放在cnts里cnts = sorted([(c, cv2.boundingRect(c)[0]) for c in contours], key = lambda x:x[1])ary = []for (c,_) in cnts: (x, y, w, h) = cv2.boundingRect(c)# print x, y, w, h if w &gt; 21 and h &gt; 23: ary.append((x, y, w, h)) 123456789fig = plt.figure()for id, (x, y, w, h) in enumerate(ary): roi = dilation[y:y + h, x:x + w] thresh = roi.copy() a = fig.add_subplot(1, len(ary), id + 1) res = cv2.resize(thresh, (50,50)) cv2.imwrite('%d.png'%(id), res)# plt.imshow(thresh) plt.imshow(res) 1print ary [(15, 12, 27, 31), (50, 13, 28, 32), (91, 9, 39, 33), (132, 10, 34, 33), (167, 15, 22, 31)] 123456import string d = dict.fromkeys(string.ascii_uppercase, 0)a = [i for i in d.keys()]a.sort()for i in a: print i, A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 12345678910111213141516pic0 = cv2.imread("0.png")pic1 = cv2.imread("1.png")pic2 = cv2.imread("2.png")pic3 = cv2.imread("3.png")pic4 = cv2.imread("4.png")def mse(imageA, imageB): err = np.sum((imageA.astype("float") - imageB.astype("float")) ** 2) err /= float(imageA.shape[0] * imageA.shape[1]) return errprint mse(pic0, pic3)print mse(pic1, pic3)print mse(pic2, pic3)pic5 = cv2.imread("../../alphabet/0.png")print mse(pic0, pic5) 117312.474 75051.276 36459.2136 101212.4472 123456789101112import os def getNumber(pic): min_a = 99999999 min_png = None for png in os.listdir('alphabet'): ref = cv2.imread('alphabet/' + png) if mse(ref, pic) &lt; min_a: min_a = mse(ref, pic) min_png = png return min_png, min_aprint getNumber(pic0) (&apos;Y.png&apos;, 21618.709200000001)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[系列01-利用Python爬虫来抓取银行的牌告汇率]]></title>
      <url>%2F2017%2F02%2F16%2F%E5%88%A9%E7%94%A8Python%E7%88%AC%E8%99%AB%E6%9D%A5%E6%8A%93%E5%8F%96%E9%93%B6%E8%A1%8C%E7%9A%84%E7%89%8C%E5%91%8A%E6%B1%87%E7%8E%87%2F</url>
      <content type="text"><![CDATA[python爬虫抓取台湾银行的牌告汇率,让你更加获益 台湾银行网站为 http://rate.bot.com.tw/xrt?Lang=zh-TW视频为：https://www.youtube.com/watch?v=-c5rrzjsN34简介：利用pandas爬去牌告汇率，然后生成excel文件 利用谷歌浏览器: chrome –&gt; 检查 –&gt; Network(监听器) 传统的requests爬取12345# import require moduleimport requests# Get request from indentity object websitereq = requests.get('http://rate.bot.com.tw/xrt?Lang=zh-TW')print req.text &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-TW&quot; class=&quot;no-js&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;臺灣銀行牌告匯率&lt;/title&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge, chrome=1&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;臺灣銀行匯率利率黃金牌價查詢&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, ....... h class=&quot;rate-content-sight print_hide&quot; data-hide=&quot;phone&quot;&gt; &lt;span style=&quot;width:inherit;&quot;&gt; &lt;span class=&quot;&quot;&gt;本行買入&lt;/span&gt; &lt;/span&gt; &lt;/th&gt; &lt;th class=&quot;rate-content-sight print_hide&quot; data-hide=&quot;phone&quot;&gt; &lt;span style=&quot;width:inherit;&quot;&gt; &lt;span class=&quot;&quot;&gt;本行賣出&lt;/span&gt; &lt;/span&gt; &lt;/th&gt; &lt;th class=&quot;hidden&quot;&gt;&lt;/th&gt; &lt;th class=&quot;display_none_print_show print_width&quot;&gt;&lt;span style=&quot;width:inherit;&quot;&gt;本行買入&lt;/span&gt;&lt;/th&gt; &lt;th class=&quot;display_none_print_show print_width&quot;&gt;&lt;span style=&quot;width:inherit;&quot;&gt;本行賣出&lt;/span&gt;&lt;/th&gt; &lt;th class=&quot;display_none_print_show print_width&quot;&gt;&lt;span style=&quot;width:inherit;&quot;&gt;本行買入&lt;/span&gt;&lt;/th&gt; &lt;th class=&quot;display_none_print_show print_width&quot;&gt;&lt;span style=&quot;width:inherit;&quot;&gt;本行賣出&lt;/span&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td data-table=&quot;幣別&quot; class=&quot;currency phone-small-font&quot;&gt; &lt;div&gt; &lt;div class=&quot;sp-div sp-america-div&quot;&gt; &lt;img title=&quot;幣別國旗&quot; alt=&quot;幣別國旗&quot; src=&quot;/Content/images/sprite_lateral.png&quot; class=&quot;sp-img sp-america-img&quot; /&gt; &lt;/div&gt; &lt;br class=&quot;visible-phone print_hide&quot; /&gt; &lt;div class=&quot;visible-phone print_hide&quot;&gt; 美金 (USD) &lt;/div&gt; &lt;div class=&quot;hidden-phone print_show&quot; style=&quot;text-indent:30px;&quot;&gt; 美金 (USD) &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;31.18&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;31.722&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;31.48&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;31.58&lt;/td&gt; &lt;td data-table=&quot;遠期匯率買入/賣出&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/forward/USD&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;歷史匯率&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/history/USD&quot; target=&quot;_blank&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;31.18&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;31.722&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;31.48&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;31.58&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td data-table=&quot;幣別&quot; class=&quot;currency phone-small-font&quot;&gt; &lt;div&gt; &lt;div class=&quot;sp-div sp-hong-kong-div&quot;&gt; &lt;img title=&quot;幣別國旗&quot; alt=&quot;幣別國旗&quot; src=&quot;/Content/images/sprite_lateral.png&quot; class=&quot;sp-img sp-hong-kong-img&quot; /&gt; &lt;/div&gt; &lt;br class=&quot;visible-phone print_hide&quot; /&gt; &lt;div class=&quot;visible-phone print_hide&quot;&gt; 港幣 (HKD) &lt;/div&gt; &lt;div class=&quot;hidden-phone print_show&quot; style=&quot;text-indent:30px;&quot;&gt; 港幣 (HKD) &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;3.914&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;4.109&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;4.034&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;4.094&lt;/td&gt; &lt;td data-table=&quot;遠期匯率買入/賣出&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/forward/HKD&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;歷史匯率&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/history/HKD&quot; target=&quot;_blank&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;3.914&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;4.109&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;4.034&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;4.094&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td data-table=&quot;幣別&quot; class=&quot;currency phone-small-font&quot;&gt; &lt;div&gt; &lt;div class=&quot;sp-div sp-england-div&quot;&gt; &lt;img title=&quot;幣別國旗&quot; alt=&quot;幣別國旗&quot; src=&quot;/Content/images/sprite_lateral.png&quot; class=&quot;sp-img sp-england-img&quot; /&gt; &lt;/div&gt; &lt;br class=&quot;visible-phone print_hide&quot; /&gt; &lt;div class=&quot;visible-phone print_hide&quot;&gt; 英鎊 (GBP) &lt;/div&gt; &lt;div class=&quot;hidden-phone print_show&quot; style=&quot;text-indent:30px;&quot;&gt; 英鎊 (GBP) &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;37.82&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;39.75&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;38.69&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;39.11&lt;/td&gt; &lt;td data-table=&quot;遠期匯率買入/賣出&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/forward/GBP&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;歷史匯率&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/history/GBP&quot; target=&quot;_blank&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;37.82&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;39.75&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;38.69&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;39.11&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td data-table=&quot;幣別&quot; class=&quot;currency phone-small-font&quot;&gt; &lt;div&gt; &lt;div class=&quot;sp-div sp-australia-div&quot;&gt; &lt;img title=&quot;幣別國旗&quot; alt=&quot;幣別國旗&quot; src=&quot;/Content/images/sprite_lateral.png&quot; class=&quot;sp-img sp-australia-img&quot; /&gt; &lt;/div&gt; &lt;br class=&quot;visible-phone print_hide&quot; /&gt; &lt;div class=&quot;visible-phone print_hide&quot;&gt; 澳幣 (AUD) &lt;/div&gt; &lt;div class=&quot;hidden-phone print_show&quot; style=&quot;text-indent:30px;&quot;&gt; 澳幣 (AUD) &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;23.53&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;24.19&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;23.72&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;23.95&lt;/td&gt; &lt;td data-table=&quot;遠期匯率買入/賣出&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/forward/AUD&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;歷史匯率&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/history/AUD&quot; target=&quot;_blank&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;23.53&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;24.19&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;23.72&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;23.95&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td data-table=&quot;幣別&quot; class=&quot;currency phone-small-font&quot;&gt; &lt;div&gt; &lt;div class=&quot;sp-div sp-canada-div&quot;&gt; &lt;img title=&quot;幣別國旗&quot; alt=&quot;幣別國旗&quot; src=&quot;/Content/images/sprite_lateral.png&quot; class=&quot;sp-img sp-canada-img&quot; /&gt; &lt;/div&gt; &lt;br class=&quot;visible-phone print_hide&quot; /&gt; &lt;div class=&quot;visible-phone print_hide&quot;&gt; 加拿大幣 (CAD) &lt;/div&gt; &lt;div class=&quot;hidden-phone print_show&quot; style=&quot;text-indent:30px;&quot;&gt; 加拿大幣 (CAD) &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;23.34&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;24.08&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;23.61&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;23.83&lt;/td&gt; &lt;td data-table=&quot;遠期匯率買入/賣出&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/forward/CAD&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;歷史匯率&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/history/CAD&quot; target=&quot;_blank&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;23.34&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;24.08&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;23.61&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;23.83&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td data-table=&quot;幣別&quot; class=&quot;currency phone-small-font&quot;&gt; &lt;div&gt; &lt;div class=&quot;sp-div sp-singapore-div&quot;&gt; &lt;img title=&quot;幣別國旗&quot; alt=&quot;幣別國旗&quot; src=&quot;/Content/images/sprite_lateral.png&quot; class=&quot;sp-img sp-singapore-img&quot; /&gt; &lt;/div&gt; &lt;br class=&quot;visible-phone print_hide&quot; /&gt; &lt;div class=&quot;visible-phone print_hide&quot;&gt; 新加坡幣 (SGD) &lt;/div&gt; &lt;div class=&quot;hidden-phone print_show&quot; style=&quot;text-indent:30px;&quot;&gt; 新加坡幣 (SGD) &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;21.62&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;22.4&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;22.04&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;22.22&lt;/td&gt; &lt;td data-table=&quot;遠期匯率買入/賣出&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/forward/SGD&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;歷史匯率&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/history/SGD&quot; target=&quot;_blank&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;21.62&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;22.4&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;22.04&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;22.22&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td data-table=&quot;幣別&quot; class=&quot;currency phone-small-font&quot;&gt; &lt;div&gt; &lt;div class=&quot;sp-div sp-swiss-div&quot;&gt; &lt;img title=&quot;幣別國旗&quot; alt=&quot;幣別國旗&quot; src=&quot;/Content/images/sprite_lateral.png&quot; class=&quot;sp-img sp-swiss-img&quot; /&gt; ...... $(window).load(function () { //最近一個營業日不可比較幣別，比較幣別為空時不顯示現金&amp;即期(for chrome) search_range_check($(&apos;input:radio:checked[name=&quot;search_range&quot;]&apos;)); //alert(&quot;load&quot;); }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 利用pandas库来爬取网页的数据1234# improt pandas moduleimport pandas# read html to transform html to list of pythondfs = pandas.read_html('http://rate.bot.com.tw/xrt?Lang=zh-TW') 1type(dfs) list 1len(dfs) 1 123# dfs is list# currency is DataFramecurrency = dfs[0] 1type(currency) pandas.core.frame.DataFrame 12# currency.ix[row, columnns]currency = currency.ix[:,:5] 12# 重置列标题currency.columns = [u'幣別',u'現金匯率-本行買入',u'現金匯率-本行賣出',u'即期匯率-本行買入',u'即期匯率-本行賣出'] 12# 正则表达式 提取币别currency[u'幣別'] = currency[u'幣別'].str.extract('\((\w+)\)') # \((\w+)\) C:\Users\Administrator\Anaconda2\lib\site-packages\ipykernel\__main__.py:1: FutureWarning: currently extract(expand=None) means expand=False (return Index/Series/DataFrame) but in a future version of pandas this will be changed to expand=True (return DataFrame) if __name__ == &apos;__main__&apos;: 1currency 幣別 現金匯率-本行買入 現金匯率-本行賣出 即期匯率-本行買入 即期匯率-本行賣出 0 USD 31.18 31.722 31.48 31.58 1 HKD 3.914 4.109 4.034 4.094 2 GBP 37.82 39.75 38.69 39.11 3 AUD 23.53 24.19 23.72 23.95 4 CAD 23.34 24.08 23.61 23.83 5 SGD 21.62 22.4 22.04 22.22 6 CHF 30.68 31.74 31.21 31.5 7 JPY 0.2664 0.2774 0.2728 0.2768 8 ZAR - - 2.29 2.37 9 SEK 3.14 3.65 3.48 3.58 10 NZD 22.34 22.97 22.58 22.78 11 THB 0.7886 0.9316 0.8771 0.9171 12 PHP 0.5826 0.7156 - - 13 IDR 0.00198 0.00268 - - 14 EUR 32.96 34.11 33.46 33.86 15 KRW 0.02518 0.02908 - - 16 VND 0.00102 0.00152 - - 17 MYR 6.006 7.606 - - 18 CNY 4.51 4.672 4.582 4.632 12# save currency to excel form currency.to_excel('currency.xlsx')]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用pandas实现输出漂亮的图表]]></title>
      <url>%2F2017%2F02%2F16%2F%E5%88%A9%E7%94%A8pandas%E5%AE%9E%E7%8E%B0%E8%BE%93%E5%87%BA%E6%BC%82%E4%BA%AE%E7%9A%84%E5%9B%BE%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[利用python的数据分析 pandas 库来可视化近期货币的走势，具体代码见-&gt; 12import pandasdf = pandas.read_csv('ExchangeRate@201701231600.csv') 1df.head() 1df.info() &lt;class &apos;pandas.core.frame.DataFrame&apos;&gt; Int64Index: 127 entries, 20170123 to 20160725 Data columns (total 22 columns): 数据日期 127 non-null object 币别 127 non-null object 汇率 127 non-null float64 现金 127 non-null float64 即期 127 non-null float64 远期10天 127 non-null float64 远期30天 127 non-null float64 远期60天 127 non-null float64 远期90天 127 non-null float64 远期120天 127 non-null float64 远期150天 127 non-null float64 远期180天 127 non-null object 汇率.1 127 non-null float64 现金.1 127 non-null float64 即期.1 127 non-null float64 远期10天.1 127 non-null float64 远期30天.1 127 non-null float64 远期60天.1 127 non-null float64 远期90天.1 127 non-null float64 远期120天.1 127 non-null float64 远期150天.1 127 non-null float64 远期180天.1 0 non-null float64 dtypes: float64(19), object(3) memory usage: 22.8+ KB 1? pandas.to_datetime 1df.index = pandas.to_datetime(df.index, format='%Y%m%d') 1%pylab inline Populating the interactive namespace from numpy and matplotlib 1df.plot(kind = 'line', y=['汇率', '现金']) &lt;matplotlib.axes._subplots.AxesSubplot at 0x9fad438&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[old-利用opencv实现脸部识别]]></title>
      <url>%2F2017%2F02%2F16%2Fold-%E5%88%A9%E7%94%A8opencv%E5%AE%9E%E7%8E%B0%E8%84%B8%E9%83%A8%E8%AF%86%E5%88%AB%2F</url>
      <content type="text"><![CDATA[利用很简单的OpenCV库在JuPyter上实现了一个简单的练习，人脸检测。使用了OpenCV成熟的级联分类器,又称为 分类器 haarcascade_frontalface_default.xml 12import matplotlib.pyplot as plt%matplotlib inline 12345import sys, cv2imagePath = 'goddess.jpg'image = cv2.imread(imagePath)# plt.imshow(image)plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB)) &lt;matplotlib.image.AxesImage at 0x82e7e48&gt; 1234567891011faceCascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)faces = faceCascade.detectMultiScale( gray, #灰阶图像 scaleFactor = 1.1, #缩减10个百分点的图像 minNeighbors = 5, # minSize = (30, 30), #window flags = cv2.CASCADE_SCALE_IMAGE)print faces #[[x, y, w, h]] [[280 51 194 194]] 123456import randomfont =cv2.FONT_HERSHEY_SCRIPT_SIMPLEXfor (x, y, w, h) in faces: cv2.rectangle(image, (x, y), (x + w, y + h), (14, 201, 255) , 2) #在脸上加上一个桔色的宽度为2的矩形边框 cv2.putText(image, str(random.randrange(20, 30)), (x+(w/2)-18, y-10), font, 1, (14, 201, 255), 3)plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB)) &lt;matplotlib.image.AxesImage at 0x10639860&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[爬虫实战第一天-抓取淘宝网站的名称和价格]]></title>
      <url>%2F2017%2F02%2F16%2F%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%80%E5%A4%A9-%E6%8A%93%E5%8F%96%E6%B7%98%E5%AE%9D%E7%BD%91%E7%AB%99%E7%9A%84%E5%90%8D%E7%A7%B0%E5%92%8C%E4%BB%B7%E6%A0%BC%2F</url>
      <content type="text"><![CDATA[之前在YouTube上学习过一系列的爬虫实战课程,淘宝（这里的淘宝指的是 台湾淘宝）使用AJAX 的方式填入页面内容。因此在这里便可以从XHR 以及JS 下手，找寻入口点，再使用正规表达式(re)，便可以快速的剖析出重要资讯， 123import requestsres = requests.get('https://world.taobao.com/search/json.htm?navigator=all&amp;_ksTS=1485567171915_27&amp;spm=a21bp.7806943.20151106.1&amp;json=on&amp;suggest_query=iphon&amp;cna=tmcHEBoqTyQCAbfMJrlM1vUh&amp;wq=iphon&amp;suggest=0_4&amp;_input_charset=utf-8&amp;source=suggest&amp;q=iphone6%E6%89%8B%E6%9C%BA%E5%A3%B3&amp;callback=__jsonp_cb&amp;abtest=_AB-LR517-LR854-LR895-PR517-PR854-PR895&amp;nid=&amp;type=&amp;uniqpid=')print res.text if(window.__jsonp_cb){__jsonp_cb({&quot;abtestParams&quot;:{&quot;bucket&quot;:&quot;18&quot;,&quot;biparam&quot;:&quot;_AB-LR517-LR854-LR895-PR517-PR854-PR895&quot;},&quot;autoNav&quot;:{&quot;auxCategory&quot;:[],&quot;findNum&quot;:&quot;191.41万&quot;,&quot;navCategory&quot;:[{&quot;cid&quot;:&quot;56152131&quot;,&quot;cname&quot;:&quot;3C数码配件&quot;,&quot;count&quot;:&quot;1857503&quot;,&quot;flag&quot;:&quot;qp_commend&quot;,&quot;subCids&quot;:[{&quot;cid&quot;:&quot;56152157&quot;,&quot;cname&quot;:&quot;保护套/壳&quot;,&quot;count&quot;:&quot;1844168&quot;,&quot;flag&quot;:&quot;qp_commend&quot;},{&quot;cid&quot;:&quot;56152161&quot;,&quot;cname&quot;:&quot;充电器/線&quot;,&quot;count&quot;:&quot;503&quot;,&quot;flag........ 1234import json import rem = re.search('if\(window.__jsonp_cb\)\&#123;__jsonp_cb\((.*?)\)\&#125;', res.text)m.group(1) u&apos;{&quot;abtestParams&quot;:{&quot;bucket&quot;:&quot;18&quot;,&quot;biparam&quot;:&quot;_AB-LR517-LR854-LR895-PR517-PR854-PR895&quot;},&quot;autoNav&quot;:{&quot;auxCategory&quot;:[],&quot;findNum&quot;:&quot;191.41\u4e07&quot;,&quot;navCategory&quot;:[{&quot;cid&quot;:&quot;56152131&quot;,&quot;cname&quot;:&quot;3C\u6570\u7801\u914d\u4ef6&quot;,&quot;count&quot;:&quot;1857503&quot;,&quot;flag&quot;:&quot;qp_commend&quot;,&quot;subCids&quot;:[{&quot;cid&quot;:&quot;56152157&quot;,&quot;cname&quot;:&quot;\u4fdd\u62a4\u5957/\u58f3&quot;,&quot;count&quot;:&quot;1844168&quot;,&quot;flag&quot;:&quot;qp_commend&quot;},{&quot;cid&quot;:&quot;56152161&quot;,&quot;cname&quot; 1jd = json.loads(m.group(1)) 1jd {u&apos;abtestParams&apos;: {u&apos;biparam&apos;: u&apos;_AB-LR517-LR854-LR895-PR517-PR854-PR895&apos;, u&apos;bucket&apos;: u&apos;18&apos;},......... 12with open('a.json','w') as f: f.write(json.dumps(jd)) 12for item in jd['itemList']: print item['nick'],item['price'] ibhdme数码旗舰店 29.00 晋美通讯 39.00 柯米数码专营店 35.00 凯莱德数码专营店 88.00 pehe旗舰店 48.00 法栋数码专营 98.00 coolook数码旗舰店 35.00 lunaluno数码旗舰店 29.90 亦嘉殿 28.00 驰界数码 58.00 citycase旗舰店 58.00 makorday 29.80 唯友通讯 58.00 milan9995200 68.00 伯托尔数码专营店 138.00 h_belis 26.00 梦幻文文 60.00 12import pandasdf = pandas.DataFrame(jd['itemList']) 1df]]></content>
    </entry>

    
  
  
</search>
