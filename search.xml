<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[MNIST机器学习入门]]></title>
      <url>%2F2017%2F03%2F01%2FMNIST%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[MNIST 机器学习入门本教程的目标读者是对机器学习和TensorFlow 都不太了解的新手．如果你已经了解 MNIST 和 softmax 回归(softmax regression) 的相关知识，你可以阅读这个快速上手教程．当我们开始学习编程的时候，第一件事往往是学习打印“HelloWorld”．就好比编程入门有HelloWorld，机器学习入门有MNIST． MNIST 是一个入门级的计算机视觉数据集，它包含各种手写数字图片： 它也包含每一张图片对应的标签，告诉我们这个是数字几．比如，上面这四张图片的标签分别是5,0,4,1． 在此教程中，我们将训练一个机器学习模型用于预测图片里面的数字．我们的目的不是要设计一个世界一流的复杂模型—尽管我们会在之后给你源代码去实现一流的预测模型—而是要介绍下如何使用TensorFlow．所以，我们这里会从一个很简单的数学模型开始，它叫做 Softmax Regression. The MNIST Data |MNIST 数据集准备数据 123456789101112131415161718192021222324252627282930# file:input_data.py# Copyright 2015 Google Inc. All Rights Reserved.## Licensed under the Apache License, Version 2.0 (the "License");# you may not use this file except in compliance with the License.# You may obtain a copy of the License at## http://www.apache.org/licenses/LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an "AS IS" BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.# =============================================================================="""Functions for downloading and reading MNIST data."""from __future__ import absolute_importfrom __future__ import divisionfrom __future__ import print_functionimport gzipimport osimport tempfileimport numpyfrom six.moves import urllibfrom six.moves import xrange # pylint: disable=redefined-builtinimport tensorflow as tffrom tensorflow.contrib.learn.python.learn.datasets.mnist import read_data_sets 1minist = read_data_sets("MNIST_data/train-images-idx3-ubyte.gz/", one_hot=True) Extracting MNIST_data/train-images-idx3-ubyte.gz/train-images-idx3-ubyte.gz Extracting MNIST_data/train-images-idx3-ubyte.gz/train-labels-idx1-ubyte.gz Extracting MNIST_data/train-images-idx3-ubyte.gz/t10k-images-idx3-ubyte.gz Extracting MNIST_data/train-images-idx3-ubyte.gz/t10k-labels-idx1-ubyte.gz 1# print(minist) Datasets(train=&lt;tensorflow.contrib.learn.python.learn.datasets.mnist.DataSet object at 0x000001E562A14D30&gt;, validation=&lt;tensorflow.contrib.learn.python.learn.datasets.mnist.DataSet object at 0x000001E562A14630&gt;, test=&lt;tensorflow.contrib.learn.python.learn.datasets.mnist.DataSet object at 0x000001E562A14588&gt;) 下载下来的数据集可被分为三部分：55000 行训练用点数据集（mnist.train），10000 行测试数据集(mnist.test)，以及 5000 行验证数据集（mnist.validation）．这样的切分很重要：在机器学习模型设计时必须有一个单独的测试数据集不用于训练而是用来评估这个模型的性能，从而更加容易把设计的模型推广到其他数据集上（泛化）． 正如前面提到的一样，每一个数据单元有两部分组成,含手写数字的图片和一个对应的标签．把这些图片设为 “xs”，把这些标签设为 “`xs` 和 `ys`，比如训练数据集的图片是 ```mnist.train.images``` ，训练数据集的标签是 `mnist.train.labels`．1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253每一张图片包含28x28 像素．我们可以用一个数字数组来表示这张图片：把这个数组展开成一个向量，长度是 ```28x28 = 784```．如何展开这个数组（数字间的顺序）不重要，只要保持各个图片采用相同的方式展开．从这个角度来看，MNIST数据集的图片就是在 784 维向量空间里面的点, 并且拥有比较复杂的结构(注意: 此类数据的可视化是计算密集型的)．展平图片的数字数组会丢失图片的二维结构信息．这显然是不理想的，最优秀的计算机视觉方法会挖掘并利用这些结构信息，会在后续教程中介绍．但是在这个教程中我们忽略这些结构，所介绍的简单数学模型，```softmax 回归 (softmax regression)```，不会利用这些结构信息．因此，在MNIST 训练数据集中，```mnist.train.images``` 是一个形状为 ```[55000, 784]``` 的张量，第一个维度数字用来索引图片，第二个维度数字用来索引每张图片中的像素点．在此张量里的每一个元素，都表示某张图片里的某个像素的强度值，值介于 0 和 1 之间相对应的MNIST 数据集的标签是介于0 到9 数字．为了用于这个教程，我们使标签数据是 &quot;```one-hot vectors```&quot;．一个 one-hot 向量除了某一位的数字是 1 其余各维度数字都是 0．所以在此教程中，数字n 将表示成一个只有在第 n 维度（从0 开始）数字为 1 的 10 维向量．比如，标签 0 将表示成 ```([1,0,0,0,0,0,0,0,0,0,0])```．因此，```labels``` 是一个```[55000, 10]``` 的数字矩阵．## Softmax 回归介绍我们知道 MNIST 数据集的每一张图片都表示一个( 0 到 9 的) 数字．那么，如果模型若能看到一张图就能知道它属于各个数字的对应概率就好了。比如，我们的模型可能看到一张数字 &quot;9&quot; 的图片，就判断出它是数字 &quot;9&quot; 的概率为 80%，而有 5% 的概率属于数字 &quot;8&quot;（因为 8 和 9 都有上半部分的小圆），同时给予其他数字对应的小概率（因为该图像代表它们的可能性微乎其微）．这是能够体现softmax 回归自然简约的一个典型案例．softmax 模型可以用来给不同的对象分配概率．在后文，我们训练更加复杂的模型时，最后一步也往往需要用softmax 来分配概率．softmax 回归（softmax regression）分两步：首先对输入被分类对象属于某个类的“证据”相加求和，然后将这个“证据”的和转化为概率.我们使用加权的方法来累积计算一张图片是否属于某类的“证据”。如果图片的像素强有力的体现该图不属于某个类，则权重为负数，相反如果这个像素拥有有利的证据支持这张图片属于这个类，那么权值为正．我们也需要引入额外的“证据”，可称之为偏置量(bias）。总的来说，我们希望它代表了与所输入向无关的判断证据．因此对于给定的输入图片x 代表某数字i 的总体证据可以表示为:$$evidencei=\sum_jW_&#123;i,j&#125; x_j + b_i$$其中，$W_i$ 代表权重，$b_i$ 代表第 i 类的偏置量，j 代表给定图片x 的像素索引用于像素求和．然后用 softmax 函数可以把这些证据转换成概率y:$$y = softmax(evidence)$$这里的softmax 可以看成是一个激励（activation）函数或是链接（link）函数，把我们定义的线性函数的输出转换成我们想要的格式，也就是关于10 个数字类的概率分布．因此，给定一张图片，它对于每一个数字的吻合度可以被softmax 函数转换成为一个概率值．softmax 函数可以定义为：$$softmax(x) = normalize(exp(x))$$展开等式右边的子式，可以得到：$$softmax(x)_i = \frac&#123;exp(x_i)&#125;&#123;\sum_j &#123;exp(x)&#125;&#125;$$但是更多的时候把 softmax 模型函数定义为第一种形式：把输入值当成幂指数求值，再正则化这些结果值．这个幂运算表示，更大的证据对应更大的假设模型（hypothesis）里面的乘数权重值．反之，拥有更少的证据意味着在假设模型里面拥有更小的乘数系数．假设模型里的权值不可以是0 值或者负值．Softmax 然后会正则化这些权重值，使它们的总和等于 1，以此构造一个有效的概率分布．（更多的关于Softmax 函数的信息，可以参考 [Michael Nieslen](http://neuralnetworksanddeeplearning.com/chap3.html#softmax) 的书里面的这个部分，其中有关于softmax 的可交互式的可视化解释．）对于softmax 回归模型可以用下面的图解释，对于输入的xs 加权求和，再分别加上一个偏置量，最后再输入到 softmax 函数中：更进一步，可以写成更加紧凑的方式：$$y = softmax(W_x + b)$$## 实现回归模型为了在 python 中高效的进行数值计算，我们通常会调用（如NumPy）外部函数库，把类似矩阵乘法这样的复杂运算使用其他外部语言实现．不幸的是，从外部计算切换回 Python 的每一个操作，仍然是一个很大的开销．如果你用GPU 来进行外部计算，这样的开销会更大．用分布式的计算方式，也会花费更多的资源用来传输数据.TensorFlow 也把复杂的计算放在python 之外完成，但是为了避免前面说的那些开销，它做了进一步完善．TensorFlow 不单独地运行单一的复杂计算，而是让我们可以先用图描述一系列可交互的计算操作，然后全部一起在Python 之外运行．（这样类似的运行方式，可以在不少的机器学习库中看到．）使用TensorFlow 之前，首先导入它：```pythonimport tensorflw as tf 1import tensorflow as tf 我们通过操作符号变量来描述这些可交互的操作单元，可以用下面的方式创建一个：1x = tf.placeholder("float", [None, 784]) 1x = tf.placeholder('float',[None, 784]) x 不是一个特定的值，而是一个占位符 placeholder，我们在 TensorFlow 运行计算时输入这个值．我们希望能够输入任意数量(在图像，每一张图展平成784 维的向量．我们用2 维的浮点数张量来表示这些图，这个张量的形状是[None，784]．（这里的None表示此张量的第一个维度可以是任何长度的)123456我们的模型也需要权重值和偏置量，当然我们可以把它们当做是另外的输入（使用占位符，但TensorFlow 有一个更好的方法来表示它们：``Variable``．一个Variable 代表一个```可修改```的张量，存在在 ```TensorFlow``` 的用于描述交互性操作的图中．它们可以用于计算输入值，也可以在计算中被修改．对于各种机器学习应用，一般都会有模型参数，可以用 `Variable` 表示.```pythonW = tf.Variable(tf.zeros([784,10]))b = tf.Variable(tf.zeros([10])) 12W = tf.Variable(tf.zeros([784, 10])) # because output 784*10b = tf.Variable(tf.zeros([10])) 我们赋予tf.Variable 不同的初值来创建不同的 Variable：在这里，我们都用全为零的张量来初始化 W 和 b．因为我们要学习 W 和 b的值，它们的初值可以随意设置. 注意，W 的维度是[784，10]，因为我们想要用 784 维的图片向量乘以它以得到一个 10 维的证据值向量，每一位对应不同数字类．b 的形状是[10]，所以我们可以直接把它加到输出上面． 现在，可以实现我们的模型了，只需以下一行代码： 1y = tf.nn.softmax(tf.matmul(x,W) + b) 1y = tf.nn.softmax(tf.matmul(x, W) + b) 首先，我们用 tf.matmul(X，W)表示 $x$ 乘以$W$，对应之前等式里面的 $W_x$，这里 x 是一个 2 维张量拥有多个输入．然后再加上 $b$，把和输入到tf.nn.softmax函数里面. 至此，我们先用了几行简短的代码来设置变量，然后只用了一行代码来定义我们的模型．TensorFlow 不仅仅可以使 softmax 回归模型计算变得特别简单，它也用这种非常灵活的方式来描述其他各种数值计算，从机器学习模型对物理学模拟仿真模型．一旦被定义好之后，我们的模型就可以在不同的设备上运行：计算机的CPU，GPU，甚至是手机！ 训练模型为了训练我们的模型，我们首先需要定义一个指标来评估这个模型是好的．其实，在机器学习，我们通常定义指标来表示一个模型是坏的，这个指标称为成本（cost）或 损失（loss），然后尽量最小化这个指标．但是，这两种方式是相同的. 一个非常常见的，非常漂亮的成本函数是“交叉熵”(cross-entropy)．交叉熵产生于信息论里面的信息压缩编码技术，但是它后来演变成为从博弈论到机器学习等其他领域里的重要技术手段．它的定义如下： $$H_y’(y) = - \sum_i{y’_i log(y_i)}$$ $y$ 是我们预测的概率分布, $y’$ 是实际的分布（我们输入的one-hot vector)．比较粗糙的理解是，交叉熵是用来衡量我们的预测用于描述真相的低效性. 为了计算交叉熵，我们首先需要添加一个新的占位符用于输入正确值：1y_ = tf.placeholder("float", [None,10]) 1y_ = tf.placeholder('float',[None,10]) 然后我们可以用 $-\sum{y’ log (y)}$ 计算交叉熵:1cross_entropy = -tf.reduce_sum(y_*tf.log(y)) 首先，用 tf.log 计算 y 的每个元素的对数．接下来，我们把 y\_ 的每一个元素和 tf.log(y_) 的对应元素相乘．最后，用 tf.reduce_sum 计算张量的所有元素的总和. 值得注意的是，这里的交叉熵不仅仅用来衡量单一的一对预测和真实值，而是所有 100 幅图片的交叉熵的总和．对于 100 个数据点的预测表现比单一数据点的表现能更好地描述我们的模型的性能． 现在我们知道我们需要我们的模型做什么啦，用TensorFlow 来训练它是非常容易的．因为TensorFlow 拥有一张描述你各个计算单元的图，它可以自动地使用反向传播算法( backpropagation algorithm )来有效地确定你的变量是如何影响你想要最小化的那个成本值的．然后，TensorFlow 会用你选择的优化算法来不断地修改变量以降低成本. 1train_step = tf.train.GradientDescentOptimizer(0.01).minimize(cross_entropy) 在这里，我们要求TensorFlow 用梯度下降算法（gradient descent algorithm）以 0.01 的学习速率最小化交叉熵．梯度下降算法（gradient descent algorithm）是一个简单的学习过程，TensorFlow 只需将每个变量一点点地往使成本不断降低的方向移动．当然 TensorFlow 也提供了 其他许多优化算法：只要简单地调整一行代码就可以使用其他的算法. 12cross_entropy = - tf.reduce_sum(y_ * tf.log(y))train_step = tf.train.GradientDescentOptimizer(0.01).minimize(cross_entropy) TensorFlow 在这里实际上所做的是，它会在后台给描述你的计算的那张图里面增加一系列新的计算操作单元用于实现反向传播算法和梯度下降算法．然后，它返回给你的只是一个单一的操作，当运行这个操作时，它用梯度下降算法训练你的模型，微调你的变量，不断减少成本. 现在，我们已经设置好了我们的模型．在运行计算之前，我们需要添加一个操作来初始化我们创建的变量：1init = tf.global_variables_initializer() 现在我们可以在一个Session 里面启动我们的模型，并且初始化变量：12sess = tf.Session()sess.run(init) 然后开始训练模型，这里我们让模型循环训练1000 次！123for i in range(1000): batch_xs, batch_ys = mnist.train.next_batch(100) sess.run(train_step, feed_dict=&#123;x: batch_xs, y_: batch_ys&#125;) 该循环的每个步骤中，我们都会随机抓取训练数据中的 100 个批处理数据点，然后我们用这些数据点作为参数替换之前的占位符来运行 train_step. 使用一小部分的随机数据来进行训练被称为随机训练(stochastic training)—在这里更确切的说是随机梯度下降训练．理想情况下，我们希望用我们所有的数据来进行每一步的训练，因为这能给我们更好的训练结果，但显然这需要很大的计算开销．所以，每一次训练我们可以使用不同的数据子集，这样做既可以减少计算开销，又可以最大化地学习到数据集的总体特性． 12345678init = tf.global_variables_initializer()sess = tf.Session()sess.run(init)for i in range(1000): batch_xs, batch_ys = minist.train.next_batch(100) sess.run(train_step, feed_dict=&#123;x: batch_xs, y_: batch_ys&#125;) 评估我们的模型首先让我们找出那些预测正确的标签．tf.argmax() 是一个非常有用的函数，它能给你在一个张量里沿着某条轴的最高条目的索引值．比如，tf.argmax(y,1)是模型认为每个输入最有可能对应的那些标签，而 tf.argmax(y_,1) 代表正确的标签．我们可以用 tf.equal来检测我们的预测是否真实标签匹配．1correct_prediction = tf.equal(tf.argmax(y,1), tf.argmax(y_,1)) 这行代码会给我们一组布尔值．为了确定正确预测项的比例，我们可以把布尔值转换成浮点数，然后取平均值．例如，[True, False, True, True] 会变成 [1,0,1,1]，取平均值后得到 0.75.1accuracy = tf.reduce_mean(tf.cast(correct_prediction , "float")) 最后，我们计算所学习到的模型在测试数据集上面的正确率.1print sess.run(accuracy, feed_dict=&#123;x: mnist.test.images, y_: mnist.test.labels&#125;) 最终结果值应该大约是 91%. 这个结果好吗？嗯，并不太好．事实上，这个结果是很差的．这是因为我们仅仅使用了一个非常简单的模型．不过，做一些小小的改进，我们就可以得到97% 的正确率．最好的模型甚至可以获得超过 99.7% 的准确率！ 比结果更重要的是，我们从这个模型中学习到的设计思想．不过，如果你仍然对这里的结果有点失望，可以查看下个教程，在那里你将学到如何用 FensorFlow 构建更加复杂的模型以获得更好的性能！ 1234correct_porediction = tf.equal(tf.arg_max(y, 1), tf.arg_max(y_, 1))accuracy = tf.reduce_mean(tf.cast(correct_porediction,"float"))print(sess.run(accuracy, feed_dict=&#123;x: mnist.test.images, y_: mnist.test.labels&#125;)) 0.8996]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[tensorflow Tutotial:Start]]></title>
      <url>%2F2017%2F03%2F01%2FTensorFlow%20Tutotial-Start%2F</url>
      <content type="text"><![CDATA[使用图(graphs) 来表示计算. 在会话(Session) 中执行图. 使用张量(tensors) 来代表数据. 通过变量(Variables) 维护状态. 使用供给(feeds) 和取回(fetches) 将数据传入或传出任何操作. TensorFlow是一个以图(graphs) 来表示计算的编程系统, 图中的节点被称之为op (operation的缩写). 一个op 获得零或多个张量(tensors) 执行计算, 产生零或多个张量。 TensorFlow 的图是一种对计算的抽象描述。在计算开始前, 图必须在会话(Session()) 中被启动. 会话将图的op 分发到如CPU 或GPU 之类的设备(Devices()) 上, 同时提供执行op 的方法。这些方法执行后, 将产生的张量(tensor) 返回。 通常，TensorFlow 编程可按两个阶段组织起来: 构建阶段和执行阶段; 前者用于组织计算图，而后者利用session 中执行计算图中的op 操作。 123456789101112131415161718# 使用"with"句块开始一个会话，该会话将在"with"句块结束时自动关闭import tensorflow as tf from tfdot import tfdotwith tf.name_scope('inputs'): mat1 = tf.constant([[1,2]],name='mat1') mat2 = tf.constant([[1],[2]],name='mat2')with tf.name_scope('output'): result = tf.matmul(mat1, mat2,name='result') with tf.Session() as sess: print(sess.run(result)) tf.summary.FileWriter('logs/',sess.graph)tfdot() [[5]] TensorFlow 事实上通过一个“翻译”过程，将定义的图转化为不同的可用计算资源间实现分布计算的操作，如CPU 或是显卡GPU。通常不需要用户指定具体使用的CPU或GPU，TensorFlow 能自动检测并尽可能的充分利用找到的第一个GPU 进行运算。如果你的设备上有不止一个GPU，你需要明确指定op 操作到不同的运算设备以调用它们。使用with…Device语句明确指定哪个CPU 或GPU 将被调用:以下是例子 “/cpu:0”：计算机的CPU； “/gpu:0”：计算机的第一个GPU，如果可用； “/gpu:1”：计算机的第二个GPU，以此类推。 123456with tf.Session() as sess: with tf.device("/gpu:0"): mat1 = tf.constant([[3., 3.]]) mat2 = tf.constant([[2.],[2.]]) product = tf.matmul(mat1, mat2)# sess.run(product) 考虑到如IPython这样的交互式Python 环境的易用, 可以使用InteractiveSession 代替Session类, 使用Tensor.eval()和Operation.run() 方法代替Session.run(). 这样可以避免使用一个变量来持有会话. 1234567891011121314151617# Enter an interactive TensorFlow Session.import tensorflow as tfsess = tf.InteractiveSession()x = tf.Variable([1.0, 2.0])a = tf.constant([3.0, 3.0])# Initialize 'x' using the run() method of its initializer op.x.initializer.run()# Add an op to subtract 'a' from 'x'. Run it and print the resultsub = tf.subtract(x, a)print(sub.eval())# ==&gt; [¡2. ¡1.]# Close the Session when we're done.sess.close() [-2. -1.] 1from tfdot import tfdot 1tfdot() Variables | 变量变量维持了图执行过程中的状态信息 代码中assign()操作是图所描绘的表达式的一部分, 正如add()操作一样. 所以在调用run()执行表达式之前, 它并不会真正执行赋值操作. 12345678910111213141516171819202122# 建立一个变量， 用0初始化它的值state = tf.Variable(0, name='counter')# 创建加法运算单元One，并加到stateone = tf.constant(1)new_value = tf.add(state, one)update = tf.assign(state, new_value)# Variables must be initialized by running an `init` Op after having 12# launched the graph. We first have to add the `init` Op to the graph.init = tf.global_variables_initializer()# init_op = tf.initialize_all_variables() # 已废除# Launch the graph and run the ops.with tf.Session() as sess: sess.run(init) # print the value of 'state' print(sess.run(update)) # run the op that updates 'state and print 'state' for _ in range(3): sess.run(update) print(sess.run(state)) 1 2 3 4 Fetches | 取回为了取回操作的输出内容, 可以在使用Session 对象的run() 调用执行图时, 传入一些tensor, 这些tensor 会帮助你取回结果. 在之前的例子里, 我们只取回了单个节点state,但是你也可以取回多个tensor: Feeds | 供给feed 使用一个tensor 值临时替换一个操作的输出结果. 你可以提供feed 数据作为run() 调用的参数.feed 只在调用它的方法内有效, 方法结束, feed 就会消失. 最常见的用例是将某些特殊的操作指定为”feed” 操作, 标记的方法是使用1tf.placeholder() 为这些操作创建占位符 . 123456input1 = tf.placeholder(tf.float32)input2 = tf.placeholder(tf.float32)output = tf.multiply(input1, input2)with tf.Session() as sess: print(sess.run(output, feed_dict=&#123;input1:[7.], input2:[3.]&#125;)) [ 21.] 12with tf.Session() as sess: print(sess.run(output, feed_dict=&#123;*:*,*:*&#125; 占位符，传入的参数格式是字典]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[matplotlib tutorial - 1]]></title>
      <url>%2F2017%2F02%2F22%2Fmatplotlib%20tutorial%20-%201%2F</url>
      <content type="text"><![CDATA[matplotlib 教程（未更新完….） 12%matplotlib inlineimport matplotlib.pyplot as plt 12# 3 coordinates according to these lists: 1,5 2,7 and 3,4.plt.plot([1, 2, 3],[5, 7, 4]) [&lt;matplotlib.lines.Line2D at 0x7bfa278&gt;] 1234# 坐标（1，1），（1，2）import matplotlib.pyplot as pltplt.plot([1,1],[1,2])plt.show() 12345678910111213141516# Legends, Titles, and Labels with Matplotlibimport matplotlib.pyplot as pltx = [1,2,3]y = [5,7,4]x2 = [1,2,3]y2 = [10,14,12]plt.plot(x, y, label="First Line")plt.plot(x2, y2, label="Second Line")plt.xlabel('Plot Number')plt.ylabel('Important var')plt.title('Interesting Graph\nCheck it out')plt.legend() # 将label依附在图上plt.show() 123456789101112# Bar Charts # 条形图绘制import matplotlib.pyplot as pltplt.bar([1, 3, 5, 7, 9],[5, 2, 7, 8, 2], label="Example one")plt.bar([2, 4, 6, 8, 10],[8, 6, 2, 5, 6], label="Example two", color='g')plt.legend()plt.xlabel('bar number')plt.ylabel('bar height')plt.title('Epic Graph\nAnother Line! Whoa')plt.show() 123456789101112131415# Histograms with Matplotlib# 直方图绘制import matplotlib.pyplot as pltpopulation_ages = [22,55,62,45,21,22,34,42,42,4,99,102,110,120,121,122,130,111,115,112,80,75,65,54,44,43,42,48]# bins = [0,10,20,30,40,50,60,70,80,90,100,110,120,130]bins = [i*10 for i in xrange(14)] # 与上面同样的效果plt.hist(population_ages, bins, histtype='bar', rwidth=0.8)plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show() 1234567891011121314151617181920212223# Scatter Plots with Matplotlib# 散点图绘制# The plt.scatter allows us to not only plot on x and y, # but it also lets us decide on the color, size, # and type of marker we use. # There are a bunch of marker options, # see the Matplotlib Marker Documentation for all of your choices.# http://matplotlib.org/api/markers_api.htmlimport matplotlib.pyplot as pltx = [1,2,3,4,5,6,7,8]y = [5,2,4,2,1,4,5,2]# color='k' -&gt;black# s = 25 -&gt; size = 25p# maker -&gt; 标记 o -&gt; 实心原点plt.scatter(x,y, label='skitscat', color='k', s=25, marker="o")plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show() 1234567891011121314151617181920212223# Stack Plots with Matplotlib# 堆叠图绘制# The idea of stack plots is to show "parts to the whole" over time. # A stack plot is basically like a pie-chart, only over time.# consider a situation where we have 24 hours in a day, # and we'd like to see how we're spending out time. # We'll divide our activities into: Sleeping, eating, working, and playing.import matplotlib.pyplot as pltdays = [1,2,3,4,5]sleeping = [7,8,6,11,7]eating = [2,3,4,3,2]working = [7,8,7,2,2]playing = [8,5,7,8,13]plt.stackplot(days, sleeping,eating,working,playing, colors=['m','c','r','k'])plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.show() 12345678910111213141516171819202122232425262728293031# 上面的图形改进# 补充，color属性：# b: blue# g: green# r: red# c: cyan# m: magenta# y: yellow# k: black# w: whiteimport matplotlib.pyplot as pltdays = [1,2,3,4,5]sleeping = [7,8,6,11,7]eating = [2,3,4,3,2]working = [7,8,7,2,2]playing = [8,5,7,8,13]plt.plot([],[],color='m', label='Sleeping', linewidth=5)plt.plot([],[],color='c', label='Eating', linewidth=5)plt.plot([],[],color='r', label='Working', linewidth=5)plt.plot([],[],color='k', label='Playing', linewidth=5)plt.stackplot(days, sleeping,eating,working,playing, colors=['m','c','r','k'])plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show() 1234567891011121314151617# Pie Charts with Matplotlib# 饼状图import matplotlib.pyplot as pltslices = [7,2,2,13]activities = ['sleeping','eating','working','playing']cols = ['c','m','r','b']plt.pie(slices, labels=activities, colors=cols, startangle=90, shadow= True, explode=(0,0.1,0,0), autopct='%1.1f%%')plt.title('Interesting Graph\nCheck it out')plt.show() Note:在plt.pie函数中，我们指定“slices”-&gt;”切片”，这是指定每个部分的相应所占的比例大小。然后，我们指定相应切片的”color”列表。接下来，我们可以选择指定图形的“起始角度”。在我们的例子中，我们为饼图选择了一个90度角，这意味着第一个分割将是一个垂直线。接下来，我们可以选择添加一个阴影到一个字符的情节，然后我们甚至可以使用“explode”拉出一个切片。我们有四个总切片和一个拉出的切片，如果我们不想拉出任何切片，我们将做（0,0,0,0）。如果我们想要拉出第一个切片，我们将做（0.1,0,0,0）。最后，我们使用autopct选项来选择将百分比覆盖到图表本身。 12345678910111213141516171819# Loading Data from Files for Matplotlib# Step1: 准备数据data = '''1,52,33,44,75,46,37,58,79,410,4'''with open('example.txt','wb') as f: f.write(data) with open('example.txt','rb') as f: for line in f: print(line.strip()) 1,5 2,3 3,4 4,7 5,4 6,3 7,5 8,7 9,4 10,4 1234567891011121314151617181920# 从指定文件中获取数据并展示import matplotlib.pyplot as pltimport csvx = []y = []with open('example.txt','rb') as csvfile: plots = csv.reader(csvfile, delimiter=',') for row in plots:# print row x.append(int(row[0])) y.append(int(row[1]))plt.plot(x,y, label='Loaded from file!')plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show() 笔记：使用csv模块读取数据。 csv阅读器自动按行分割文件，然后通过指定选择在文件中的数据的分隔符。在这个例子中，这是一个,。注意：“csv”模块和csv.reader不需要文件在字面上是一个.csv文件。它可以是任何只包含分隔数据的文本文件。 1234567891011import matplotlib.pyplot as pltimport numpy as npx, y = np.loadtxt('example.txt', delimiter=',', unpack=True)plt.plot(x,y, label='Loaded from file!')plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# Data from the Internet for Matplotlibimport matplotlib.pyplot as pltimport numpy as npimport requestsimport matplotlib.dates as mdatesdef graph_data(stock): stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv' source_code = requests.get(stock_price_url).text.decode() stock_data = [] split_source = source_code.split('\n') for line in split_source: split_line = line.split(',') if len(split_line) == 6: if 'values' not in line: stock_data.append(line) date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data, delimiter=',', unpack=True, # %Y = full year. 2015 # %y = partial year 15 # %m = number month # %d = number day # %H = hours # %M = minutes # %S = seconds # 12-06-2014 # %m-%d-%Y converters=&#123;0: bytespdate2num('%Y%m%d')&#125;)# plt.plot_date(date, lowp,'-',color='r', label='Price') plt.plot_date(date, closep,'-', label='Price') plt.xlabel('x') plt.ylabel('y') plt.title('Interesting Graph\nCheck it out') plt.legend() plt.show()def bytespdate2num(fmt, encoding='utf-8'): strconverter = mdates.strpdate2num(fmt) def bytesconverter(b): s = b.decode(encoding) return strconverter(s) return bytesconverter graph_data('TSLA') 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# Basic customization with Matplotlibimport matplotlib.pyplot as pltimport numpy as npimport requestsimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'): strconverter = mdates.strpdate2num(fmt) def bytesconverter(b): s = b.decode(encoding) return strconverter(s) return bytesconverter def graph_data(stock): fig = plt.figure() ax1 = plt.subplot2grid((1,1), (0,0)) #(1,1)表示这是一个1×1网格。(0,0)是这个子图的“起点”将为(0,0)。 stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv' source_code = requests.get(stock_price_url).text.decode() stock_data = [] split_source = source_code.split('\n') for line in split_source: split_line = line.split(',') if len(split_line) == 6: if 'values' not in line and 'labels' not in line: stock_data.append(line) date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data, delimiter=',', unpack=True, converters=&#123;0: bytespdate2num('%Y%m%d')&#125;) ax1.plot_date(date, closep,'-', label='Price') for label in ax1.xaxis.get_ticklabels(): label.set_rotation(45) ax1.grid(True, color='0.75', linestyle='-', linewidth=0.5) # 添加网格 plt.xlabel('Date') plt.ylabel('Price') plt.title('Interesting Graph\nCheck it out') plt.legend() plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0) plt.show()graph_data('fb') 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# Basic customization with Matplotlibimport matplotlib.pyplot as pltimport numpy as npimport requestsimport datetime as dtimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'): strconverter = mdates.strpdate2num(fmt) def bytesconverter(b): s = b.decode(encoding) return strconverter(s) return bytesconverter def graph_data(stock): fig = plt.figure() ax1 = plt.subplot2grid((1,1), (0,0)) #(1,1)表示这是一个1×1网格。(0,0)是这个子图的“起点”将为(0,0)。 stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv' source_code = requests.get(stock_price_url).text.decode() stock_data = [] split_source = source_code.split('\n') for line in split_source: split_line = line.split(',') if len(split_line) == 6: if 'values' not in line and 'labels' not in line: stock_data.append(line) date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data, delimiter=',', unpack=True) dateconv = np.vectorize(dt.datetime.fromtimestamp) date = dateconv(date)# date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,# delimiter=',',# unpack=True,# converters=&#123;0: bytespdate2num('%Y%m%d')&#125;) ax1.plot_date(date, closep,'-', label='Price') for label in ax1.xaxis.get_ticklabels(): label.set_rotation(45) ax1.grid(True, color='0.75', linestyle='-', linewidth=0.5) # 添加网格 plt.xlabel('Date') plt.ylabel('Price') plt.title('Interesting Graph\nCheck it out') plt.legend() plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0) plt.show()graph_data('fb') 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# Colors and Fills with Matplotlibimport matplotlib.pyplot as pltimport numpy as npimport requestsimport datetime as dtimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'): strconverter = mdates.strpdate2num(fmt) def bytesconverter(b): s = b.decode(encoding) return strconverter(s) return bytesconverter def graph_data(stock): fig = plt.figure() ax1 = plt.subplot2grid((1,1), (0,0)) stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv' source_code = requests.get(stock_price_url).text.decode() stock_data = [] split_source = source_code.split('\n') for line in split_source: split_line = line.split(',') if len(split_line) == 6: if 'values' not in line and 'labels' not in line: stock_data.append(line) date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data, delimiter=',', unpack=True, converters=&#123;0: bytespdate2num('%Y%m%d')&#125;) ax1.fill_between(date, 0, closep) for label in ax1.xaxis.get_ticklabels(): label.set_rotation(45) ax1.grid(True)#, color='g', linestyle='-', linewidth=5) ax1.fill_between(date, 0, closep) ax1.xaxis.label.set_color('c') ax1.yaxis.label.set_color('r') ax1.set_yticks([0,25,50,75]) plt.xlabel('Date') plt.ylabel('Price') plt.title(stock) plt.legend() plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0) plt.show()graph_data('EBAY') C:\Users\Administrator\Anaconda2\lib\site-packages\matplotlib\axes\_axes.py:519: UserWarning: No labelled objects found. Use label=&apos;...&apos; kwarg on individual plots. warnings.warn(&quot;No labelled objects found. &quot; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import matplotlib.pyplot as pltimport numpy as npimport requestsimport datetime as dtimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'): strconverter = mdates.strpdate2num(fmt) def bytesconverter(b): s = b.decode(encoding) return strconverter(s) return bytesconverter def graph_data(stock): fig = plt.figure() ax1 = plt.subplot2grid((1,1), (0,0)) stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv' source_code = requests.get(stock_price_url).text.decode() stock_data = [] split_source = source_code.split('\n') for line in split_source: split_line = line.split(',') if len(split_line) == 6: if 'values' not in line and 'labels' not in line: stock_data.append(line) date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data, delimiter=',', unpack=True, converters=&#123;0: bytespdate2num('%Y%m%d')&#125;) ax1.plot_date(date, closep,'-', label='Price') ax1.plot([],[],linewidth=5, label='loss', color='r',alpha=0.5) ax1.plot([],[],linewidth=5, label='gain', color='g',alpha=0.5) ax1.fill_between(date, closep, closep[0],where=(closep &gt; closep[0]), facecolor='g', alpha=0.5) ax1.fill_between(date, closep, closep[0],where=(closep &lt; closep[0]), facecolor='r', alpha=0.5) for label in ax1.xaxis.get_ticklabels(): label.set_rotation(45) ax1.grid(True)#, color='g', linestyle='-', linewidth=5) ax1.xaxis.label.set_color('c') ax1.yaxis.label.set_color('r') ax1.set_yticks([0,25,50,75]) plt.xlabel('Date') plt.ylabel('Price') plt.title(stock) plt.legend() plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0) plt.show()graph_data('EBAY') 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# Spines and Horizontal Lines with Matplotlib# 脊和水平线import matplotlib.pyplot as pltimport numpy as npimport requestsimport datetime as dtimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'): strconverter = mdates.strpdate2num(fmt) def bytesconverter(b): s = b.decode(encoding) return strconverter(s) return bytesconverter def graph_data(stock): fig = plt.figure() ax1 = plt.subplot2grid((1,1), (0,0)) stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv' source_code = requests.get(stock_price_url).text.decode() stock_data = [] split_source = source_code.split('\n') for line in split_source: split_line = line.split(',') if len(split_line) == 6: if 'values' not in line and 'labels' not in line: stock_data.append(line) date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data, delimiter=',', unpack=True, converters=&#123;0: bytespdate2num('%Y%m%d')&#125;) ax1.plot_date(date, closep,'-', label='Price') ax1.plot([],[],linewidth=5, label='loss', color='r',alpha=0.5) ax1.plot([],[],linewidth=5, label='gain', color='g',alpha=0.5) ax1.axhline(closep[0], color='k', linewidth=5) ax1.fill_between(date, closep, closep[0],where=(closep &gt; closep[0]), facecolor='g', alpha=0.5) ax1.fill_between(date, closep, closep[0],where=(closep &lt; closep[0]), facecolor='r', alpha=0.5) for label in ax1.xaxis.get_ticklabels(): label.set_rotation(45) ax1.grid(True) #ax1.xaxis.label.set_color('c') #ax1.yaxis.label.set_color('r') ax1.set_yticks([0,25,50,75]) ax1.spines['left'].set_color('c') ax1.spines['right'].set_visible(False) ax1.spines['top'].set_visible(False) ax1.spines['left'].set_linewidth(5) ax1.tick_params(axis='x', colors='#f06215') plt.xlabel('Date') plt.ylabel('Price') plt.title(stock) plt.legend() plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0) plt.show()graph_data('ebay') 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# Candlestick OHLC graphs with Matplotlibimport matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcimport numpy as npimport requestsimport datetime as dtdef bytespdate2num(fmt, encoding='utf-8'): strconverter = mdates.strpdate2num(fmt) def bytesconverter(b): s = b.decode(encoding) return strconverter(s) return bytesconverter def graph_data(stock): fig = plt.figure() ax1 = plt.subplot2grid((1,1), (0,0)) stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1m/csv' source_code = requests.get(stock_price_url).text.decode() stock_data = [] split_source = source_code.split('\n') for line in split_source: split_line = line.split(',') if len(split_line) == 6: if 'values' not in line and 'labels' not in line: stock_data.append(line) date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data, delimiter=',', unpack=True, converters=&#123;0: bytespdate2num('%Y%m%d')&#125;) x = 0 y = len(date) ohlc = [] while x &lt; y: append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x] ohlc.append(append_me) x+=1 candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f') for label in ax1.xaxis.get_ticklabels(): label.set_rotation(45) ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) ax1.xaxis.set_major_locator(mticker.MaxNLocator(10)) ax1.grid(True) plt.xlabel('Date') plt.ylabel('Price') plt.title(stock) plt.legend() plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0) plt.show()graph_data('EBAY') 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# Styles with Matplotlibfrom matplotlib import styleimport matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcimport numpy as npimport requestsimport datetime as dtstyle.use('ggplot')def bytespdate2num(fmt, encoding='utf-8'): strconverter = mdates.strpdate2num(fmt) def bytesconverter(b): s = b.decode(encoding) return strconverter(s) return bytesconverter def graph_data(stock): fig = plt.figure() ax1 = plt.subplot2grid((1,1), (0,0)) stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1m/csv' source_code = requests.get(stock_price_url).text.decode() stock_data = [] split_source = source_code.split('\n') for line in split_source: split_line = line.split(',') if len(split_line) == 6: if 'values' not in line and 'labels' not in line: stock_data.append(line) date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data, delimiter=',', unpack=True, converters=&#123;0: bytespdate2num('%Y%m%d')&#125;) x = 0 y = len(date) ohlc = [] while x &lt; y: append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x] ohlc.append(append_me) x+=1 candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f') for label in ax1.xaxis.get_ticklabels(): label.set_rotation(45) ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) ax1.xaxis.set_major_locator(mticker.MaxNLocator(10)) ax1.grid(True) plt.xlabel('Date') plt.ylabel('Price') plt.title(stock) plt.legend() plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0) plt.show()graph_data('EBAY') 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from matplotlib import styleimport matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcimport numpy as npimport requestsimport datetime as dtdef bytespdate2num(fmt, encoding='utf-8'): strconverter = mdates.strpdate2num(fmt) def bytesconverter(b): s = b.decode(encoding) return strconverter(s) return bytesconverter def graph_data(stock,sty): style.use(sty) fig = plt.figure() ax1 = plt.subplot2grid((1,1), (0,0)) stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1m/csv' source_code = requests.get(stock_price_url).text.decode() stock_data = [] split_source = source_code.split('\n') for line in split_source: split_line = line.split(',') if len(split_line) == 6: if 'values' not in line and 'labels' not in line: stock_data.append(line) date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data, delimiter=',', unpack=True, converters=&#123;0: bytespdate2num('%Y%m%d')&#125;) x = 0 y = len(date) ohlc = [] while x &lt; y: append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x] ohlc.append(append_me) x+=1 # candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f') ax1.plot(date,closep) ax1.plot(date,openp) for label in ax1.xaxis.get_ticklabels(): label.set_rotation(45) ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) ax1.xaxis.set_major_locator(mticker.MaxNLocator(10)) ax1.grid(True) plt.xlabel('Date') plt.ylabel('Price') plt.title(stock) plt.legend() plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0) plt.show()graph_data('EBAY','fivethirtyeight')graph_data('EBAY','dark_background') 1234567891011121314151617181920212223242526# Live Graphs with Matplotlib%matplotlib inlineimport matplotlib.pyplot as pltimport matplotlib.animation as animationfrom matplotlib import stylestyle.use('fivethirtyeight')fig = plt.figure()ax1 = fig.add_subplot(1,1,1)def animate(i): graph_data = open('example.txt','r').read() lines = graph_data.split('\n') xs = [] ys = [] for line in lines: if len(line) &gt; 1: x, y = line.split(',') xs.append(x) ys.append(y) ax1.clear() ax1.plot(xs, ys) ani = animation.FuncAnimation(fig, animate, interval=1000)plt.show()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[爬虫实战第二节课笔记及相关代码]]></title>
      <url>%2F2017%2F02%2F19%2F%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E8%8A%82%E8%AF%BE%E7%AC%94%E8%AE%B0%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81%2F</url>
      <content type="text"><![CDATA[网络爬虫更新第二节课笔记 代码格式 强制缩进！Python开发者有意让违反了缩进规则的程序不能通过编译，以此来强制程序员养成良好的编程习惯。并且Python语言利用缩进表示语句块的开始和退出（Off-side规则），而非使用花括号或者某种关键字。增加缩进表示语句块的开始，而减少缩进则表示语句块的退出。缩进成为了语法的一部分。 根据PEP的规定，必须使用4个空格来表示每级缩进 我建议可以参考Google内部的python书写规范 基本语法 弱类型 变量必须先赋值再使用 小心引用！ 2和3的常见差异 xrange print 数据类型统一，取消unicode和long utf8: 3.x代码默认utf-8 12345# syntax.pya = 1234print(a)a = 'abcd'print(a) 1234 abcd 1234try: print(b)except Exception as e: print(e) name &apos;b&apos; is not defined 123456a = [1, 2, 3, 4]def fun(a): a[0] = 2fun(a)print a [2, 2, 3, 4] 12for i in xrange(10): print i, 0 1 2 3 4 5 6 7 8 9 12345try: # python 2.X支持 print 100, 200, 300, 400except Exception as e: print e 100 200 300 400 1234567891011import copya = [1, 2, 3, 4]def func(a): a[0] = 2fun(copy.deepcopy(a))print type(copy.deepcopy(a))print copy.copy(a)print a &lt;type &apos;list&apos;&gt; [1, 2, 3, 4] [1, 2, 3, 4] 关键字 常量 True False None 对象与容器 class import from del 逻辑操作 and or not 函数 def return 判断与循环控制 if elif else is in assert for while continue break 异常 raise try except finally with as 作用域 global nonlocal 匿名函数与协程 yield lambda 1234567# keywordassert(1 == 1)try: assert( 1 != 1)except Exception as e: print(e) 循环判断 注意加“:”！！！ 没有do-while循环 没有switch break是中断整个循环 continue是结束本次迭代进入下一个 1234567891011# loopscore = 80if score &gt; 90: print("A")elif score &gt; 80: print('B')elif score &gt; 70: print('C')else: print('不及格') C 1234total = 1while total != 10: print total, total += 3 # 没有++/-- 1 4 7 123456789101112131415161718# for 循环之作用于容器# 没有这种写法：# for(i = 0; i&lt; 100; i++)# #TODO# 上面这种循环只能用于while实现i = 0j = 0while i &lt; 3: j = 0 while j &lt; 3: if j == 2: j += 1 print(i, j), continue print(i, j), j += 1 i += 1 (0, 0) (0, 1) (0, 3) (1, 0) (1, 1) (1, 3) (2, 0) (2, 1) (2, 3) 函数 def定义函数 默认参数 名字参数 函数也是对象！！！ 函数式编程简介：map/reduce/lambda 12345678# fun.pydef hello(who='shenheng'): # print('hello ' + who ) print('hello %s'% who)hello('xiaoming')hello('sea')hello() hello xiaoming hello sea hello shenheng 1234567891011# f(x) = x * 5 + 100# g(x) = x * 5; f(x) = g(x) + 100# =&gt;f(g(x)) = x * 5def g(x): return x*5def f(g, x): return g(x) + 100print(f(g, 100))print(f(lambda x: x * 5, 100)) 600 600 1234567def g(x, y): return(x + y)def f(g, x, y): return g(x, y) + 100print(f(lambda x, y: x * y, 5, 5)) 125 容器 list：数组 tuple：只读数组 set：没有重复元素的数组 dict：字典（哈希表） 数组切片 字符串与数组的关系!!! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475## list# 遍历数组listlist_ = [1, 2, 3, 4]for i in list_: print(i)print '============*******=================' for i in range(1, 10, 2): print(i)print '============*******=================' # 按照下标索引访问数组print(list_[0])print '============*******================='# 向数组添加元素# append方法list_.append(1)list_.append(2)list_.append(3)list_.append(['abc','abcd'])list_.append([4, 5, 6])print list_print '============*******================='# 向数组添加元素（按照元素添加）li = [1, 2]li_a = [3, 4, 5]li.extend(li_a)print(li)print '============*******================='# 删除数组的元素li.pop() # 默认删除最后一个元素print(li)li.pop(2) #索引print(li)print '============*******================='# 排序li_b = [5, 8, 7, 6, 4]li_b.sort()print(li_b)print '============*******================='# lambda帮助排序# http://stackoverflow.com/questions/3766633/how-to-sort-with-lambda-in-pythonli = [[5, 2], [3, 8], [2, 11], [7, 6]]li.sort(key = lambda x:x[0]) # 一定要加上key =, sorted也可以的print(li)print '============*******================='li = [[5, 2], [3, 8], [2, 11], [7, 6]]def item_key(x): return x[0]li = sorted(li, key = item_key)print(li)print '==============End===================' 1 2 3 4 ============*******================= 1 3 5 7 9 ============*******================= 1 ============*******================= [1, 2, 3, 4, 1, 2, 3, [&apos;abc&apos;, &apos;abcd&apos;], [4, 5, 6]] ============*******================= [1, 2, 3, 4, 5] ============*******================= [1, 2, 3, 4] [1, 2, 4] ============*******================= [4, 5, 6, 7, 8] ============*******================= [[2, 11], [3, 8], [5, 2], [7, 6]] ============*******================= [[2, 11], [3, 8], [5, 2], [7, 6]] ==============End=================== 12345678# tuple# 可以理解为只读的数组,不可修改tp = (1, 2, 3)try: tp[0] = 100except Exception as e: print(e) &apos;tuple&apos; object does not support item assignment 123456# sets = set([1, 2, 3, 4, 5, 6, 7])print(s)s = set((1, 2, 3, 4, 5, 6, 7))print(s) set([1, 2, 3, 4, 5, 6, 7]) set([1, 2, 3, 4, 5, 6, 7]) 1234567891011121314# dict字典# 哈希表# key&lt;-&gt;value对应的哈希表di = &#123;'k1':'v1', 'k2':'v2'&#125;di['k3'] = 'v3'di['k4'] = 'v4'print '============Method1================='for k in di: print(di[k])print '============Method2=================' for i,j in di.items(): print(i, j) ============Method1================= v3 v2 v1 v4 ============Method2================= (&apos;k3&apos;, &apos;v3&apos;) (&apos;k2&apos;, &apos;v2&apos;) (&apos;k1&apos;, &apos;v1&apos;) (&apos;k4&apos;, &apos;v4&apos;) 12345678910111213141516171819# 数组切片# ex:[1 , 2, 3, 4, 5, 6] -&gt; [3, 4, 5]li = [1 , 2, 3, 4, 5]li_0_2 = li[0:3] # 0&lt;= ? &lt;3# 等价于li[:3]print li_0_2# [start, end, step] =&gt; [start, start + stgep, ...,&lt; end]# 默认是0， end默认是-1，step默认1li_0_3 = li[-1: -4: -1] # # print li_0_3# 直接利用切片反转数组print(li[::-1])print(li[-2::-1])# 切片是复制li_0_2[-1] = 100print li_0_2 [1, 2, 3] [5, 4, 3, 2, 1] [4, 3, 2, 1] [1, 2, 100] 1234567891011121314151617181920212223242526# 字符串str = 'abcdefg'try: str[0] = 'x'except Exception as e: print(e) # 修改字符串li = list(str)# print(li)s = ''.join(li)print sprint(type(s))s = '-'.join(li)print(s)# 切割s = 'abc,def,ghi'p1, p2, p3 = s.split(',')print( p1, p2, p3)# 下标访问和切割print(s[1])print(s[1:4]) &apos;str&apos; object does not support item assignment abcdefg &lt;type &apos;str&apos;&gt; a-b-c-d-e-f-g (&apos;abc&apos;, &apos;def&apos;, &apos;ghi&apos;) b bc, 面向对象 一切皆对象 获取对象信息：type和dir class声明对象 重要的self！！！ 继承与多态（什么是鸭子类型？） 12345# 用type查看对象类型print(type([1, 2, 4, 6]))print(type((1, 2, 4, 6)))print(type('strrr'))print(type(&#123;'1':'2'&#125;)) &lt;type &apos;list&apos;&gt; &lt;type &apos;tuple&apos;&gt; &lt;type &apos;str&apos;&gt; &lt;type &apos;dict&apos;&gt; 12# 用dir查看属性和方法print(dir(list)) [&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;, &apos;__delattr__&apos;, &apos;__delitem__&apos;, &apos;__delslice__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__getslice__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__iadd__&apos;, &apos;__imul__&apos;, &apos;__init__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__reversed__&apos;, &apos;__rmul__&apos;, &apos;__setattr__&apos;, &apos;__setitem__&apos;, &apos;__setslice__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;append&apos;, &apos;count&apos;, &apos;extend&apos;, &apos;index&apos;, &apos;insert&apos;, &apos;pop&apos;, &apos;remove&apos;, &apos;reverse&apos;, &apos;sort&apos;] 123456789101112class Clazz(object): # self参考C++中的this指针 def __init__(self, x, y): self.x = x self.y = y # 声明成员函数的时候，第一个参数一定时self def display(self): print(self.x, self.y)print(type(Clazz))clz = Clazz(100, 200)clz.display() # 等价于display(clzz) &lt;type &apos;type&apos;&gt; (100, 200) 123456789101112# 继承class Base: def run(self): print('Base::run')class Tom: def run(self): print('tom::run')t = Tom()# 判断是否是基类型t.run() tom::run 1234567891011121314def run(runner): runner.run() class R1: def run(self): print('R1::run') class R2: def run(self): print('R2::run')run(R1())run(R2()) R1::run R2::run 文件读写 文本文件读写 二进制文件读写 string与bytes 文件和目录操作 1234567# 文本文件的读写f = open('text.txt','r')# print(f.read())# while f.readline()!=for i in f.readlines(): # print i, print(i.strip()) 1234 abcd edfg 12345# 另一种常用方法with open('text.txt') as f: print(dir(f)) for line in f.readlines(): print line, [&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__doc__&apos;, &apos;__enter__&apos;, &apos;__exit__&apos;, &apos;__format__&apos;, &apos;__getattribute__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__iter__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;close&apos;, &apos;closed&apos;, &apos;encoding&apos;, &apos;errors&apos;, &apos;fileno&apos;, &apos;flush&apos;, &apos;isatty&apos;, &apos;mode&apos;, &apos;name&apos;, &apos;newlines&apos;, &apos;next&apos;, &apos;read&apos;, &apos;readinto&apos;, &apos;readline&apos;, &apos;readlines&apos;, &apos;seek&apos;, &apos;softspace&apos;, &apos;tell&apos;, &apos;truncate&apos;, &apos;write&apos;, &apos;writelines&apos;, &apos;xreadlines&apos;] 1234 abcd edfg 模式 描述 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 w 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写 12345678# with open('text.txt','rb') as f:# print(f.read())# mode s = 'abcdef'b = bytes(s)print(b)with open('text.txt','a') as f: f.write('\n'+s) abcdef 123with open('text.txt','r') as f: for i in f.readlines(): print i, 1234 abcd edfg abcdef abcdef 多线程 多线程 多进程 线程同步 多线程编程经验 123456789101112131415#多线程import threadingdef thread_func(x): print('%d'% (x * 100))threads = []for i in range(5): threads.append(threading.Thread(target= thread_func,args=(100,)))# 一定加逗号100，for thread in threads: thread.start() for thread in threads: thread.join() 10000 10000 10000 10000 10000 错误和异常处理 为什么要使用异常？ 如何自定义异常 logging库使用 123456789101112131415161718# 错误处理import logging'''作业：自己实现将不同的等级的信息写到不同的日志文件logging.info(...)logging.debug(...)'''try: r = 10 / 0except ZeroDivisionError as e: print(type(e)) print(e)finally: # 主要防止资源泄露！ print('Always come here.') &lt;type &apos;exceptions.ZeroDivisionError&apos;&gt; integer division or modulo by zero Always come here.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[爬虫实战第一节课笔记及相关代码]]></title>
      <url>%2F2017%2F02%2F18%2F%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE%E7%AC%94%E8%AE%B0%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81%2F</url>
      <content type="text"><![CDATA[网络爬虫更新第一节课笔记 什么是网络爬虫 定义 网络爬虫（又称为网页蜘蛛，网络机器人，在FOAF社区之间更经常地称为网页追随者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。 由于专门用于信息检索的“机器人程序”像蜘蛛一样在网络之间爬来爬去，因此，搜索引擎的“机器人”程序就被称为“蜘蛛”程序 历史 1990年，蒙特利尔大学学生Alan Emtage发明的Archie，用于搜索分散的FTP主机上的资源。 1993年，内华达大学受启发开发了类似工具，但是开始支持网页搜索。 Martin Koster于1993年10月创建了ALIWEB，它是Archie的HTTP版本。ALIWEB不使用“机器人”程序，而是靠网站主动提交信息来建立自己的链接索引，类似于现在我们熟知的Yahoo。 Yahoo, Google, Baidu, Bing… 使用Python写爬虫的好处 上手容易！！！ 免费开源，使用不受限制。 解释执行，跨平台不受限制。 面向对象 框架和库支持丰富，有大量的历史积累。 Python开发环境搭建和简介 Python简介 官网：https://www.python.org/ 作者：Guido van Rossum 名字来源：Monty Python’s Flying Circus（和蟒蛇无关啊！） 作者为什么发明Python：平衡C和Shell 版本选择：2.7和3.5，更低版本不推荐使用。2.x和3.x的区别暂时不用关心。 Python环境搭建 Windows可去官网下载安装包：2.7.12或3.5.2 Mac 系统自带 通过homebrew和pyenv安装并维护多个Python版本，参考链接。 Linux系统自带，或参考上面链接使用pyenv安装并维护多个Python版本 使用pip安装第三方包，命令为pip install package（注：Mac下需要打开sudo，参考链接。） 新版本Mac系统可能因为SIP，需要在命令行后增加–user参数 遇到GFW可以使用国内源（推荐豆瓣），命令行为pip install package -i –trusted-host http://pypi.douban.com/simple/ HTTP简介 HTTP = HyperText Transfer Protocol URI = Uniform Resource Identifier URL = Uniform Resource Locator URI和URL的区别：URI强调的是资源，而URL强调的是资源的位置。 常用请求类型 OPTIONS: 返回服务器针对特定资源所支持的http请求方法。 HEAD: 向服务器索要与get请求相一致的响应，只不过响应体将不会被返回。 GET: 向特定资源发出请求 PUT: 向指定资源位置上传其最新内容 POST: 向指定资源提交数据进行处理请求 DELETE: 请求服务器删除指定URI所标识的资源 PATCH: 用来将局部修改应用于某一资源 HTML (Hypertext Markup Language) 推荐教程：HTML HTML不是编程语言，而是一种标记语言。即HTML使用标记标签来描述网页。 标签和元素 DOM文档模型 1234567891011121314151617&lt;标签 属性="属性的值"&gt;&lt;/标签&gt;比如：&lt;a href="www.baidu.com"&gt;&lt;a&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;/h1&gt;....DOM文档模型：文本&lt;body&gt; - 段落1 &lt;p&gt;...&lt;/p&gt; - 列表 &lt;ul&gt;...&lt;/ul&gt; - 图片 &lt;img src=""&gt; &lt;/img&gt; - 文本 -段落2 - 列表 - ... XML (eXtensible Markup Language) 推荐教程：XML 树结构 12345678910ROOT - E1 - G1 - G1 -&gt; 属性/值 - E2 - E3 &lt;node attr=value&gt;...&lt;/node&gt;[ROOT][E1][G1].text[ROOT][E2][G1].text Json (JavaScript Object Notation) 推荐教程：Json 语法类似XML，但是更小、更快、更容易解析。对JavaScript特别友好。 MySQL Windows: 下载免费社区版mysql server。 客户端操作可以使用MySQLWorkbench。 Linux（以debian为例） 1.apt-get install mysql-server mysql-client 2.登陆mysql: mysql -p hostname -u username -p，然后使用use dbname指定需要操作的数据库 3.安装phpmyadmin方便在浏览器操作数据库 MySQL常用命令 show databases: 显示当前服务器上的数据库 create database dbname: 创建一个新数据库 use dbname: 使用指定的数据库 show tables: 显示当前数据库的所有表 desc tbname: 显示表结构 SQLite Windows直接去下载可执行文件即可使用，Linux下apt-get install sqlite3即可完成安装。 相比mysql更加轻便好用。 大数据情况下效率变差，适合单机小程序。 爬虫框架介绍工作流程 将种子URL放入队列 从队列中获取URL，抓取内容。 解析抓取内容，将需要进一步抓取的URL放入工作队列，存储解析后的内容 抓取策略 深度优先 广度优先 PageRank 大站优先策略 如何去重 Hash表 bloom过滤器 123456789101112131415161718192021222324252627282930313233343536373839404142news.sina.com.cn1.sina.com.cn2.sina.com.cnnews.sina.com.cn - 专题1 - news11 - news12 - news13 - 专题2 - news21 - news22 - news23DFS（深度）:working专题1111213working专题2212223BFS（广度）：working专题1专题2111213212223PageRank:给网页打值 Robots规范与原则Robots规范 Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。Robots协议的本质是网站和搜索引擎爬虫的沟通方式，用来指导搜索引擎更好地抓取网站内容，而不是作为搜索引擎之间互相限制和不正当竞争的工具。 详情：http://baike.so.com/doc/4854891-5072162.html 爬虫质量标准 分布式 可伸缩性 性能和有效性 质量 新鲜性 更新 可扩展性 扯得远点 Map/Reduce背后 例子1目标：获取某一个省的邮编区号目标网站： www.ip138.com/post/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestsimport xml.etree.ElementTree as ETfrom xml.parsers.expat import ParserCreateclass DefaultSaxHandler(object): def __init__(self, provinces): self.provinces = provinces # 处理标签开始 def start_element(self, name, attrs): if name != 'map': name = attrs['title'] number = attrs['href'] self.provinces.append((name, number)) # 处理标签结束 def end_element(self, name): pass # 文本处理 def char_data(self, text): pass def get_province_entry(url): # 获取文本，并用gb2312解码 content = requests.get(url).content.decode('gb2312') # 确定要查找字符串的开始结束位置，并用切片获取内容。 start = content.find('&lt;map name=\"map_86\" id=\"map_86\"&gt;') end = content.find('&lt;/map&gt;') content = content[start:end + len('&lt;/map&gt;')].strip().encode('utf8') provinces = [] # 生成Sax处理器 handler = DefaultSaxHandler(provinces) # 初始化分析器 parser = ParserCreate() parser.StartElementHandler = handler.start_element parser.EndElementHandler = handler.end_element parser.CharacterDataHandler = handler.char_data # 解析数据 parser.Parse(content) # 结果字典为每一页的入口代码 return provincesprovinces = get_province_entry('http://www.ip138.com/post')for i in provinces: print(i[0],i[1]) 新疆 /83/ 西藏 /85/ 青海 /81/ 甘肃 /73/ 四川 /61/ 云南 /65/ 宁夏 /75/ 内蒙古 /01/ 黑龙江 /15/ 吉林 /13/ 辽宁 /11/ 河北 /50/ 北京 /10/ 天津 /30/ 陕西 /71/ 山西 /03/ 山东 /25/ 河南 /45/ 重庆 /40/ 湖北 /43/ 安徽 /23/ 江苏 /21/ 上海 /20/ 贵州 /55/ 广西 /53/ 湖南 /41/ 江西 /33/ 浙江 /31/ 福建 /35/ 广东 /51/ 海南 /57/ 台湾 /taiwang/ 澳门 /aomen/ 香港 /xianggang/ 例子2抓取股票信息 1234567891011121314151617181920212223242526272829303132333435import requestsimport threadingdef display_info(code): url = 'http://hq.sinajs.cn/list=' + code response = requests.get(url).text print(response) def single_thread(codes): for code in codes: code = code.strip() display_info(code)def multi_thread(tasks): # 用列表推导生成线程，注意codes后面的‘，’! threads = [threading.Thread(target = single_thread, args = (codes,)) for codes in tasks] # 启动线程 for t in threads: t.start() # 等待线程结束 for t in threads: t.join()# 注意main函数的形式if __name__ == '__main__': codes = ['sh600001', 'sh600002', 'sh600003', 'sh600004', 'sh600005', 'sh600006'] # 计算每个线程要做多少工作 thread_len = int(len(codes) / 4) t1 = codes[0: thread_len] t2 = codes[thread_len: thread_len * 2] t3 = codes[thread_len * 2: thread_len * 3] t4 = codes[thread_len * 3:] # 多线程启动 multi_thread([t1, t2, t3, t4]) var hq_str_sh600001=&quot;&quot;; var hq_str_sh600002=&quot;&quot;; var hq_str_sh600003=&quot;&quot;; var hq_str_sh600004=&quot;白云机场,14.480,14.480,14.330,14.510,14.320,14.320,14.330,4926788,70978480.000,35700,14.320,30700,14.310,60300,14.300,52400,14.290,20400,14.280,4200,14.330,20300,14.340,14100,14.350,2500,14.360,5702,14.370,2017-02-17,15:00:00,00&quot;; var hq_str_sh600005=&quot;武钢股份,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0,0.000,0,0.000,0,0.000,0,0.000,0,0.000,0,0.000,0,0.000,0,0.000,0,0.000,0,0.000,0,0.000,2017-02-17,09:14:18,00&quot;; var hq_str_sh600006=&quot;东风汽车,7.000,7.020,7.160,7.350,6.940,7.150,7.160,34238293,243779395.000,41100,7.150,160200,7.140,81600,7.130,289391,7.120,81200,7.110,150971,7.160,235900,7.170,235000,7.180,228890,7.190,403400,7.200,2017-02-17,15:00:00,00&quot;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[申请Coursera助学金-干货]]></title>
      <url>%2F2017%2F02%2F16%2F%E7%94%B3%E8%AF%B7Coursera%E5%8A%A9%E5%AD%A6%E9%87%91-%E5%B9%B2%E8%B4%A7%2F</url>
      <content type="text"><![CDATA[对于没有钱的学生党来说，Coursera的课程太贵，没有办法，只能通过申请助学金来实现正规的学习，过去Coursera还支持旁听，现在没有了，无奈的我们只能通过Apply Finitial Aid来学习了，想想都痛苦 申请助学金在哪申请？？恐怕很多童鞋们都找不到如何申请助学金的链接，不过没关系，哥哥告诉你，哈哈，:) 具体操作步骤：1. 打开你想申请的课程网站比如，莱斯大学著名的IIPP课程（已完成），课程网站为An Introduction to Interactive Programming in Python(Part 1) IIPP课程已经更新了他原来的界面，我个人感觉这种界面还是很不错的.这门课是隶属莱斯大学计算机基础的专项课程的第一门课，But这只是Part1，尼玛，还有Part2吗，恭喜你，答对了，由于照顾到部分同学的学习的压力，所以将IIPP划分为两门课来上，另外Part1和Part2的差距对我来说，难度跨越有点大，所以希望大家继续努力，。。。。跑偏主题了，快回来。。。 点击右边的注册按钮，同学们会发现下面的这种情况 OK，你们会看到有旁听选项，我个人认为仅旁听激不起你学习的的动力，另外这门课成绩必须在规定的时间（1 week）完成，如果过期，那么不好意思，请移步下一期课程，但是再看看前面的两个选项，尼玛，这也太贵了吧，59刀。。。 2. 寻找申请助学金链接 你看看这弄得也忒隐蔽了吧，还好我眼睛比较尖锐，哈哈，Andrew Ng是不是故意的,呵呵~ 3. 言归正传,开始申请吧点击链接,我们会转到申请助学金的页面, 不错,就是它,如果你们看到这了,会产生两个疑问,中文写还是英文?? 当然英文了,对于英文弱的要死要死的我们,肿么办?? 4. 干货来了要注意的是： 首先按照自个儿的经济情况书写，国家不要填错！ 下面是一超链接，大家都懂得！干货，别说我没告诉你！ 5. 终于完工了具体的页面如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RStudio在使用Github时出现的问题的解决方案]]></title>
      <url>%2F2017%2F02%2F16%2FRStudio%E5%9C%A8%E4%BD%BF%E7%94%A8Github%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
      <content type="text"><![CDATA[在使用Github时，往往出现这种情况，我在使用Github client时，比如 Android Studio，Github Desktop，Rstudio，PyCharm 等等时，我为了工程项目更好的同步到我的github 上，往往使用客户端的 Git Push 比较迅速，但是在配置方面，很麻烦，所以在我配置的时候出现了这样一则错误， unable to read askpass response from… ,结合网上资源，将解决方案放出！ 当我尝试着从RStudio IDE中push到github的时候，遇到了以下的错误信息. 123error: unable to read askpass response from &apos;rpostback-askpass&apos;fatal: could not read Username for &apos;https://github.com&apos;: No such device or address RStduio也有我的源 1https://github.com/rh01/calendar.git RStudio 不允许我改变版本控制系统的源（主要在这里灰色显示），如下图所示： 我尝试了很多方法去解决该问题，在 stackoverflow 收到启发，根据我的情况，作出了以下的方案解决上述问题 我根据之前的经验，看到我之前已经正常工作的RProject的configuration 于是我在本地计算机中删除了本地clone的repo.然后重新克隆github中源 然后我在RStudio中 click New Project -&gt; Existing Directory OKay,It’s Works.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈latex]]></title>
      <url>%2F2017%2F02%2F16%2F%E6%B5%85%E8%B0%88latex%2F</url>
      <content type="text"><![CDATA[LaTeX是在克努特老先生（注：他的著作有TeX系统，计算机程序设计艺术）发明出来TeX系统的基础之上完善的。刚开始主要适用于文章和数学公式的排版。他是我最喜欢的排版技术之一。TeX系统是在1982年发布的。目前的TeX系统的版本不断修正，们目前的版本号不断接近 $\pi$. LaTeXLaTeX是一个宏包，目的是使作者能够利用一个预先定义好的专业页面设置，从而得以高质量的排版个打印他们的作品。 LaTeX基础作者图书设计者和排版者出版的第一步是将他们的手稿交给出版公司，然后图书设计者来决定这个本书的版面形式（包括栏宽、字体、标题前后的间距······）。图书设计者会把他的排版说明写进手稿里，一起交给排版者，排版者左后根据这些说明完成这本书的排版工作。 一个图书设计者要试图理解作者写作时意图他要根据手稿的内容和他自己的职业知识决定章节标题，文献引用、例子、公式等等。 在LaTeX环境下，LaTeX代替了图书设计者的角色，TEX则是他的排版者，但是LaTeX“仅仅”是一个计算机程序，他需要更多的指导。作者必须在他的作品中提供附加信息，用于描述作品的逻辑结构。这些信息是通过“LaTeX命令”写入文章中的。 在使用LaTeX的时候，一般来说是不能在输入文章的同时看到组中的效果的（对比~WYSIWYG）。但是在屏幕上预览最终的输出效果的，因此在真正打印文档之前是可以对其进行修改的。 版面设计如果排印好的文档从艺术角度看来不错，就说明设计是成功的。 优势与不足MSWord和LaTeX的对比 优势 提供专业级的排版设计，使你的文档看起来如同印刷好的一样。 可以更方便的盘版数学公式。 用户仅仅需要掌握少数容易理解的，用来说明文档之逻辑结构的命令，无需对实际的页面设计做胡乱的修补。 可以很容易的神农谷成脚注、索引、目录和参考文献等复杂的结构。 有大量免费地可添加宏集，协助你完成许多基本的LaTeX为直接支持的排版任务。 LaTeX鼓励作者写作具有良好结构的文章，因为LaTeX就是哦那个过详细地说明文章的结构进行排版工作的。 TEX作为LaTeX的格式化引擎是免费软件，且具有极高的可移植性。 不足 对于出卖其灵魂的人来说，LaTeX不能很好的工作。 尽管预先定义好的版面可以调节一些参数，设计全新的版面还是很困难的，需要耗费大量的时间。 LaTeX不适合排本非结构化的，无序的文档。 参考文献[1] 一份不太简短的$LaTeX$2的介绍,Tobias Oetiker,中国CTEX用户小组，2002]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Soft修正函数]]></title>
      <url>%2F2017%2F02%2F16%2FSoft%E4%BF%AE%E6%AD%A3%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[softmax 模型和激活函数 12345678910111213141516171819"""Softmax."""scores = [3.0, 1.0, 0.2]import numpy as npdef softmax(x): """Compute softmax values for each sets of scores in x.""" pass # TODO:Compute and return softmax(x)print(softmax(scores))# Plot softmax curvesimport matplotlib.pyplot as pltx = np.arange(-2.0, 6.0, 0.1)scores = np.vstack([x, np.ones_like(x), 0.2 * np.ones_like(x)])plt.plot(x, softmax(scores).T, linewidth=2)plt.show() Softmax 模型 Note: softmax(x) 函数应该返回一个形状和x相同的NumPy array类型。 例如，当输入为一个列表或者一维矩阵（用列向量表示一个样本样本）时，比如说以下的： 1scores = [1.0, 2.0, 3.0] 应该返回一个同样长度（即3个元素）的一维矩阵： 1print softmax(scores) 1[ 0.09003057 0.24472847 0.66524096] 对于一个二维矩阵，如以下（列向量表示单个样本），例如: 1scores = np.array([[1, 2, 3, 6],[2, 4, 5, 6],[3, 8, 7, 6]]) 该函数应该返回一个同样大小(3,4)的二维矩阵，如以下: 123[[ 0.09003057 0.00242826 0.01587624 0.33333333] [ 0.24472847 0.01794253 0.11731043 0.33333333] [ 0.66524096 0.97962921 0.86681333 0.33333333]] 每个样本（列向量）中的概率加起来应当等于 1。 解决方案： 123def softmax(x): &quot;&quot;&quot;Compute softmax values for each sets of scores in x.&quot;&quot;&quot; return np.exp(x) / np.sum(np.exp(x), axis = 0) 运行结果: 1[ 0.8360188 0.11314284 0.05083836] 笔记： 两个数学函数 np.sum()： np.exp()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[笔记1-从机器学习到深度学习-两个问题]]></title>
      <url>%2F2017%2F02%2F16%2F%E7%AC%94%E8%AE%B01-%E4%BB%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%B0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[这篇笔记主要摘出一部分的问题和解决方案来谈谈我学习 Deep Learning 时的一些感想和收获。 行人检测任务问题是： 假设你在你的车上有一个摄像头拍摄前面的街道，你想检测你前面的行人在哪？保证你不撞到他们，你怎么能通过一个分类器实现呢？ Answer：（我的想法） 首先选择一些标记了正负标记的样本（Positive：行人，Negative：杂讯），用于训练行人检测分类模型，然后利用训练好的模型来检测街道是否有行人。 导师给出的答案: A typical method is to run a binary classifier over different areas of an image, and mark the areas with a positive label as detected instances. 一种把这个检测问题转化为分类问题的方法是，一个分类器将图片中的小块分成两类，行人或者非行人，你就可以对图片多次执行这个分类器，每当它的输出为行人时就告诉你你所需要的行人位置！ 用于排名的分类（有时候也成为竞价排名）问题是 网页搜索排序,假设你有一个搜索请求,你想找到在网站上所有跟请求相关的网页,你怎么使用一个分类器实现？ 解决方案： 使分类器接收成对的搜索请求和网站,输出则是两类中的其中一个 相关或者不相关当然 如果你在整个网络中运行分类器,将会有无数的网页需要查看,但是搜索引擎将会走捷径,仅尝试分类那些比较有可能的候选网站.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用机器学习实现数字识别及分类]]></title>
      <url>%2F2017%2F02%2F16%2F%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB%E5%8F%8A%E5%88%86%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[利用opencv对图像进行边缘检测，轮廓检测等等，人工构建特征和训练集，结合 Euclidean distance 来计算相似度，进而可实现0～9的数字的分类。 1%matplotlib inline 1234import matplotlib.pyplot as pltimport cv2img = cv2.imread("CaptchaImage.jpg")plt.imshow(img) &lt;matplotlib.image.AxesImage at 0x6e77e10&gt; 1234import numpy as npkernel = np.ones((4,4), np.uint8)erosion = cv2.erode(img, kernel, iterations = 1)plt.imshow(erosion) &lt;matplotlib.image.AxesImage at 0x74a64e0&gt; 123456blurred = cv2.GaussianBlur(erosion, (5, 5), 0) #高斯滤波器滤掉杂讯edged = cv2.Canny(blurred, 30, 150) # Canny算子来实现边缘检测dilation = cv2.dilate(edged, kernel, iterations = 1) # opencv膨胀算子实现填充效果,还原回来正常的效果plt.imshow(dilation) &lt;matplotlib.image.AxesImage at 0x768a5c0&gt; 1234567891011# 检测她的轮廓image, contours, hierarchy = cv2.findContours(dilation.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE) # 将资料放在cnts里cnts = sorted([(c, cv2.boundingRect(c)[0]) for c in contours], key = lambda x:x[1])ary = []for (c,_) in cnts: (x, y, w, h) = cv2.boundingRect(c)# print x, y, w, h if w &gt; 21 and h &gt; 23: ary.append((x, y, w, h)) 123456789fig = plt.figure()for id, (x, y, w, h) in enumerate(ary): roi = dilation[y:y + h, x:x + w] thresh = roi.copy() a = fig.add_subplot(1, len(ary), id + 1) res = cv2.resize(thresh, (50,50)) cv2.imwrite('%d.png'%(id), res)# plt.imshow(thresh) plt.imshow(res) 1print ary [(15, 12, 27, 31), (50, 13, 28, 32), (91, 9, 39, 33), (132, 10, 34, 33), (167, 15, 22, 31)] 123456import string d = dict.fromkeys(string.ascii_uppercase, 0)a = [i for i in d.keys()]a.sort()for i in a: print i, A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 12345678910111213141516pic0 = cv2.imread("0.png")pic1 = cv2.imread("1.png")pic2 = cv2.imread("2.png")pic3 = cv2.imread("3.png")pic4 = cv2.imread("4.png")def mse(imageA, imageB): err = np.sum((imageA.astype("float") - imageB.astype("float")) ** 2) err /= float(imageA.shape[0] * imageA.shape[1]) return errprint mse(pic0, pic3)print mse(pic1, pic3)print mse(pic2, pic3)pic5 = cv2.imread("../../alphabet/0.png")print mse(pic0, pic5) 117312.474 75051.276 36459.2136 101212.4472 123456789101112import os def getNumber(pic): min_a = 99999999 min_png = None for png in os.listdir('alphabet'): ref = cv2.imread('alphabet/' + png) if mse(ref, pic) &lt; min_a: min_a = mse(ref, pic) min_png = png return min_png, min_aprint getNumber(pic0) (&apos;Y.png&apos;, 21618.709200000001)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[系列01-利用Python爬虫来抓取银行的牌告汇率]]></title>
      <url>%2F2017%2F02%2F16%2F%E5%88%A9%E7%94%A8Python%E7%88%AC%E8%99%AB%E6%9D%A5%E6%8A%93%E5%8F%96%E9%93%B6%E8%A1%8C%E7%9A%84%E7%89%8C%E5%91%8A%E6%B1%87%E7%8E%87%2F</url>
      <content type="text"><![CDATA[python爬虫抓取台湾银行的牌告汇率,让你更加获益 台湾银行网站为 http://rate.bot.com.tw/xrt?Lang=zh-TW视频为：https://www.youtube.com/watch?v=-c5rrzjsN34简介：利用pandas爬去牌告汇率，然后生成excel文件 利用谷歌浏览器: chrome –&gt; 检查 –&gt; Network(监听器) 传统的requests爬取12345# import require moduleimport requests# Get request from indentity object websitereq = requests.get('http://rate.bot.com.tw/xrt?Lang=zh-TW')print req.text &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-TW&quot; class=&quot;no-js&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;臺灣銀行牌告匯率&lt;/title&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge, chrome=1&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;臺灣銀行匯率利率黃金牌價查詢&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, ....... h class=&quot;rate-content-sight print_hide&quot; data-hide=&quot;phone&quot;&gt; &lt;span style=&quot;width:inherit;&quot;&gt; &lt;span class=&quot;&quot;&gt;本行買入&lt;/span&gt; &lt;/span&gt; &lt;/th&gt; &lt;th class=&quot;rate-content-sight print_hide&quot; data-hide=&quot;phone&quot;&gt; &lt;span style=&quot;width:inherit;&quot;&gt; &lt;span class=&quot;&quot;&gt;本行賣出&lt;/span&gt; &lt;/span&gt; &lt;/th&gt; &lt;th class=&quot;hidden&quot;&gt;&lt;/th&gt; &lt;th class=&quot;display_none_print_show print_width&quot;&gt;&lt;span style=&quot;width:inherit;&quot;&gt;本行買入&lt;/span&gt;&lt;/th&gt; &lt;th class=&quot;display_none_print_show print_width&quot;&gt;&lt;span style=&quot;width:inherit;&quot;&gt;本行賣出&lt;/span&gt;&lt;/th&gt; &lt;th class=&quot;display_none_print_show print_width&quot;&gt;&lt;span style=&quot;width:inherit;&quot;&gt;本行買入&lt;/span&gt;&lt;/th&gt; &lt;th class=&quot;display_none_print_show print_width&quot;&gt;&lt;span style=&quot;width:inherit;&quot;&gt;本行賣出&lt;/span&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td data-table=&quot;幣別&quot; class=&quot;currency phone-small-font&quot;&gt; &lt;div&gt; &lt;div class=&quot;sp-div sp-america-div&quot;&gt; &lt;img title=&quot;幣別國旗&quot; alt=&quot;幣別國旗&quot; src=&quot;/Content/images/sprite_lateral.png&quot; class=&quot;sp-img sp-america-img&quot; /&gt; &lt;/div&gt; &lt;br class=&quot;visible-phone print_hide&quot; /&gt; &lt;div class=&quot;visible-phone print_hide&quot;&gt; 美金 (USD) &lt;/div&gt; &lt;div class=&quot;hidden-phone print_show&quot; style=&quot;text-indent:30px;&quot;&gt; 美金 (USD) &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;31.18&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;31.722&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;31.48&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;31.58&lt;/td&gt; &lt;td data-table=&quot;遠期匯率買入/賣出&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/forward/USD&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;歷史匯率&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/history/USD&quot; target=&quot;_blank&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;31.18&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;31.722&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;31.48&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;31.58&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td data-table=&quot;幣別&quot; class=&quot;currency phone-small-font&quot;&gt; &lt;div&gt; &lt;div class=&quot;sp-div sp-hong-kong-div&quot;&gt; &lt;img title=&quot;幣別國旗&quot; alt=&quot;幣別國旗&quot; src=&quot;/Content/images/sprite_lateral.png&quot; class=&quot;sp-img sp-hong-kong-img&quot; /&gt; &lt;/div&gt; &lt;br class=&quot;visible-phone print_hide&quot; /&gt; &lt;div class=&quot;visible-phone print_hide&quot;&gt; 港幣 (HKD) &lt;/div&gt; &lt;div class=&quot;hidden-phone print_show&quot; style=&quot;text-indent:30px;&quot;&gt; 港幣 (HKD) &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;3.914&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;4.109&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;4.034&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;4.094&lt;/td&gt; &lt;td data-table=&quot;遠期匯率買入/賣出&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/forward/HKD&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;歷史匯率&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/history/HKD&quot; target=&quot;_blank&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;3.914&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;4.109&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;4.034&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;4.094&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td data-table=&quot;幣別&quot; class=&quot;currency phone-small-font&quot;&gt; &lt;div&gt; &lt;div class=&quot;sp-div sp-england-div&quot;&gt; &lt;img title=&quot;幣別國旗&quot; alt=&quot;幣別國旗&quot; src=&quot;/Content/images/sprite_lateral.png&quot; class=&quot;sp-img sp-england-img&quot; /&gt; &lt;/div&gt; &lt;br class=&quot;visible-phone print_hide&quot; /&gt; &lt;div class=&quot;visible-phone print_hide&quot;&gt; 英鎊 (GBP) &lt;/div&gt; &lt;div class=&quot;hidden-phone print_show&quot; style=&quot;text-indent:30px;&quot;&gt; 英鎊 (GBP) &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;37.82&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;39.75&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;38.69&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;39.11&lt;/td&gt; &lt;td data-table=&quot;遠期匯率買入/賣出&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/forward/GBP&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;歷史匯率&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/history/GBP&quot; target=&quot;_blank&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;37.82&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;39.75&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;38.69&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;39.11&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td data-table=&quot;幣別&quot; class=&quot;currency phone-small-font&quot;&gt; &lt;div&gt; &lt;div class=&quot;sp-div sp-australia-div&quot;&gt; &lt;img title=&quot;幣別國旗&quot; alt=&quot;幣別國旗&quot; src=&quot;/Content/images/sprite_lateral.png&quot; class=&quot;sp-img sp-australia-img&quot; /&gt; &lt;/div&gt; &lt;br class=&quot;visible-phone print_hide&quot; /&gt; &lt;div class=&quot;visible-phone print_hide&quot;&gt; 澳幣 (AUD) &lt;/div&gt; &lt;div class=&quot;hidden-phone print_show&quot; style=&quot;text-indent:30px;&quot;&gt; 澳幣 (AUD) &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;23.53&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;24.19&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;23.72&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;23.95&lt;/td&gt; &lt;td data-table=&quot;遠期匯率買入/賣出&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/forward/AUD&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;歷史匯率&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/history/AUD&quot; target=&quot;_blank&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;23.53&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;24.19&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;23.72&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;23.95&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td data-table=&quot;幣別&quot; class=&quot;currency phone-small-font&quot;&gt; &lt;div&gt; &lt;div class=&quot;sp-div sp-canada-div&quot;&gt; &lt;img title=&quot;幣別國旗&quot; alt=&quot;幣別國旗&quot; src=&quot;/Content/images/sprite_lateral.png&quot; class=&quot;sp-img sp-canada-img&quot; /&gt; &lt;/div&gt; &lt;br class=&quot;visible-phone print_hide&quot; /&gt; &lt;div class=&quot;visible-phone print_hide&quot;&gt; 加拿大幣 (CAD) &lt;/div&gt; &lt;div class=&quot;hidden-phone print_show&quot; style=&quot;text-indent:30px;&quot;&gt; 加拿大幣 (CAD) &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;23.34&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;24.08&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;23.61&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;23.83&lt;/td&gt; &lt;td data-table=&quot;遠期匯率買入/賣出&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/forward/CAD&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;歷史匯率&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/history/CAD&quot; target=&quot;_blank&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;23.34&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;24.08&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;23.61&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;23.83&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td data-table=&quot;幣別&quot; class=&quot;currency phone-small-font&quot;&gt; &lt;div&gt; &lt;div class=&quot;sp-div sp-singapore-div&quot;&gt; &lt;img title=&quot;幣別國旗&quot; alt=&quot;幣別國旗&quot; src=&quot;/Content/images/sprite_lateral.png&quot; class=&quot;sp-img sp-singapore-img&quot; /&gt; &lt;/div&gt; &lt;br class=&quot;visible-phone print_hide&quot; /&gt; &lt;div class=&quot;visible-phone print_hide&quot;&gt; 新加坡幣 (SGD) &lt;/div&gt; &lt;div class=&quot;hidden-phone print_show&quot; style=&quot;text-indent:30px;&quot;&gt; 新加坡幣 (SGD) &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;21.62&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;rate-content-cash text-right print_hide&quot;&gt;22.4&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;22.04&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;rate-content-sight text-right print_hide&quot; data-hide=&quot;phone&quot;&gt;22.22&lt;/td&gt; &lt;td data-table=&quot;遠期匯率買入/賣出&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/forward/SGD&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;歷史匯率&quot; class=&quot;text-center print_hide phone-small-font&quot;&gt;&lt;a href=&quot;/xrt/history/SGD&quot; target=&quot;_blank&quot;&gt;查詢&lt;/a&gt;&lt;/td&gt; &lt;td data-table=&quot;本行現金買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;21.62&lt;/td&gt; &lt;td data-table=&quot;本行現金賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;22.4&lt;/td&gt; &lt;td data-table=&quot;本行即期買入&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;22.04&lt;/td&gt; &lt;td data-table=&quot;本行即期賣出&quot; class=&quot;text-right display_none_print_show print_width&quot;&gt;22.22&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td data-table=&quot;幣別&quot; class=&quot;currency phone-small-font&quot;&gt; &lt;div&gt; &lt;div class=&quot;sp-div sp-swiss-div&quot;&gt; &lt;img title=&quot;幣別國旗&quot; alt=&quot;幣別國旗&quot; src=&quot;/Content/images/sprite_lateral.png&quot; class=&quot;sp-img sp-swiss-img&quot; /&gt; ...... $(window).load(function () { //最近一個營業日不可比較幣別，比較幣別為空時不顯示現金&amp;即期(for chrome) search_range_check($(&apos;input:radio:checked[name=&quot;search_range&quot;]&apos;)); //alert(&quot;load&quot;); }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 利用pandas库来爬取网页的数据1234# improt pandas moduleimport pandas# read html to transform html to list of pythondfs = pandas.read_html('http://rate.bot.com.tw/xrt?Lang=zh-TW') 1type(dfs) list 1len(dfs) 1 123# dfs is list# currency is DataFramecurrency = dfs[0] 1type(currency) pandas.core.frame.DataFrame 12# currency.ix[row, columnns]currency = currency.ix[:,:5] 12# 重置列标题currency.columns = [u'幣別',u'現金匯率-本行買入',u'現金匯率-本行賣出',u'即期匯率-本行買入',u'即期匯率-本行賣出'] 12# 正则表达式 提取币别currency[u'幣別'] = currency[u'幣別'].str.extract('\((\w+)\)') # \((\w+)\) C:\Users\Administrator\Anaconda2\lib\site-packages\ipykernel\__main__.py:1: FutureWarning: currently extract(expand=None) means expand=False (return Index/Series/DataFrame) but in a future version of pandas this will be changed to expand=True (return DataFrame) if __name__ == &apos;__main__&apos;: 1currency 幣別 現金匯率-本行買入 現金匯率-本行賣出 即期匯率-本行買入 即期匯率-本行賣出 0 USD 31.18 31.722 31.48 31.58 1 HKD 3.914 4.109 4.034 4.094 2 GBP 37.82 39.75 38.69 39.11 3 AUD 23.53 24.19 23.72 23.95 4 CAD 23.34 24.08 23.61 23.83 5 SGD 21.62 22.4 22.04 22.22 6 CHF 30.68 31.74 31.21 31.5 7 JPY 0.2664 0.2774 0.2728 0.2768 8 ZAR - - 2.29 2.37 9 SEK 3.14 3.65 3.48 3.58 10 NZD 22.34 22.97 22.58 22.78 11 THB 0.7886 0.9316 0.8771 0.9171 12 PHP 0.5826 0.7156 - - 13 IDR 0.00198 0.00268 - - 14 EUR 32.96 34.11 33.46 33.86 15 KRW 0.02518 0.02908 - - 16 VND 0.00102 0.00152 - - 17 MYR 6.006 7.606 - - 18 CNY 4.51 4.672 4.582 4.632 12# save currency to excel form currency.to_excel('currency.xlsx')]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用pandas实现输出漂亮的图表]]></title>
      <url>%2F2017%2F02%2F16%2F%E5%88%A9%E7%94%A8pandas%E5%AE%9E%E7%8E%B0%E8%BE%93%E5%87%BA%E6%BC%82%E4%BA%AE%E7%9A%84%E5%9B%BE%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[利用python的数据分析 pandas 库来可视化近期货币的走势，具体代码见-&gt; 12import pandasdf = pandas.read_csv('ExchangeRate@201701231600.csv') 1df.head() 1df.info() &lt;class &apos;pandas.core.frame.DataFrame&apos;&gt; Int64Index: 127 entries, 20170123 to 20160725 Data columns (total 22 columns): 数据日期 127 non-null object 币别 127 non-null object 汇率 127 non-null float64 现金 127 non-null float64 即期 127 non-null float64 远期10天 127 non-null float64 远期30天 127 non-null float64 远期60天 127 non-null float64 远期90天 127 non-null float64 远期120天 127 non-null float64 远期150天 127 non-null float64 远期180天 127 non-null object 汇率.1 127 non-null float64 现金.1 127 non-null float64 即期.1 127 non-null float64 远期10天.1 127 non-null float64 远期30天.1 127 non-null float64 远期60天.1 127 non-null float64 远期90天.1 127 non-null float64 远期120天.1 127 non-null float64 远期150天.1 127 non-null float64 远期180天.1 0 non-null float64 dtypes: float64(19), object(3) memory usage: 22.8+ KB 1? pandas.to_datetime 1df.index = pandas.to_datetime(df.index, format='%Y%m%d') 1%pylab inline Populating the interactive namespace from numpy and matplotlib 1df.plot(kind = 'line', y=['汇率', '现金']) &lt;matplotlib.axes._subplots.AxesSubplot at 0x9fad438&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[old-利用opencv实现脸部识别]]></title>
      <url>%2F2017%2F02%2F16%2Fold-%E5%88%A9%E7%94%A8opencv%E5%AE%9E%E7%8E%B0%E8%84%B8%E9%83%A8%E8%AF%86%E5%88%AB%2F</url>
      <content type="text"><![CDATA[利用很简单的OpenCV库在JuPyter上实现了一个简单的练习，人脸检测。使用了OpenCV成熟的级联分类器,又称为 分类器 haarcascade_frontalface_default.xml 12import matplotlib.pyplot as plt%matplotlib inline 12345import sys, cv2imagePath = 'goddess.jpg'image = cv2.imread(imagePath)# plt.imshow(image)plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB)) &lt;matplotlib.image.AxesImage at 0x82e7e48&gt; 1234567891011faceCascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)faces = faceCascade.detectMultiScale( gray, #灰阶图像 scaleFactor = 1.1, #缩减10个百分点的图像 minNeighbors = 5, # minSize = (30, 30), #window flags = cv2.CASCADE_SCALE_IMAGE)print faces #[[x, y, w, h]] [[280 51 194 194]] 123456import randomfont =cv2.FONT_HERSHEY_SCRIPT_SIMPLEXfor (x, y, w, h) in faces: cv2.rectangle(image, (x, y), (x + w, y + h), (14, 201, 255) , 2) #在脸上加上一个桔色的宽度为2的矩形边框 cv2.putText(image, str(random.randrange(20, 30)), (x+(w/2)-18, y-10), font, 1, (14, 201, 255), 3)plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB)) &lt;matplotlib.image.AxesImage at 0x10639860&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[爬虫实战第一天-抓取淘宝网站的名称和价格]]></title>
      <url>%2F2017%2F02%2F16%2F%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%80%E5%A4%A9-%E6%8A%93%E5%8F%96%E6%B7%98%E5%AE%9D%E7%BD%91%E7%AB%99%E7%9A%84%E5%90%8D%E7%A7%B0%E5%92%8C%E4%BB%B7%E6%A0%BC%2F</url>
      <content type="text"><![CDATA[之前在YouTube上学习过一系列的爬虫实战课程,淘宝（这里的淘宝指的是 台湾淘宝）使用AJAX 的方式填入页面内容。因此在这里便可以从XHR 以及JS 下手，找寻入口点，再使用正规表达式(re)，便可以快速的剖析出重要资讯， 123import requestsres = requests.get('https://world.taobao.com/search/json.htm?navigator=all&amp;_ksTS=1485567171915_27&amp;spm=a21bp.7806943.20151106.1&amp;json=on&amp;suggest_query=iphon&amp;cna=tmcHEBoqTyQCAbfMJrlM1vUh&amp;wq=iphon&amp;suggest=0_4&amp;_input_charset=utf-8&amp;source=suggest&amp;q=iphone6%E6%89%8B%E6%9C%BA%E5%A3%B3&amp;callback=__jsonp_cb&amp;abtest=_AB-LR517-LR854-LR895-PR517-PR854-PR895&amp;nid=&amp;type=&amp;uniqpid=')print res.text if(window.__jsonp_cb){__jsonp_cb({&quot;abtestParams&quot;:{&quot;bucket&quot;:&quot;18&quot;,&quot;biparam&quot;:&quot;_AB-LR517-LR854-LR895-PR517-PR854-PR895&quot;},&quot;autoNav&quot;:{&quot;auxCategory&quot;:[],&quot;findNum&quot;:&quot;191.41万&quot;,&quot;navCategory&quot;:[{&quot;cid&quot;:&quot;56152131&quot;,&quot;cname&quot;:&quot;3C数码配件&quot;,&quot;count&quot;:&quot;1857503&quot;,&quot;flag&quot;:&quot;qp_commend&quot;,&quot;subCids&quot;:[{&quot;cid&quot;:&quot;56152157&quot;,&quot;cname&quot;:&quot;保护套/壳&quot;,&quot;count&quot;:&quot;1844168&quot;,&quot;flag&quot;:&quot;qp_commend&quot;},{&quot;cid&quot;:&quot;56152161&quot;,&quot;cname&quot;:&quot;充电器/線&quot;,&quot;count&quot;:&quot;503&quot;,&quot;flag........ 1234import json import rem = re.search('if\(window.__jsonp_cb\)\&#123;__jsonp_cb\((.*?)\)\&#125;', res.text)m.group(1) u&apos;{&quot;abtestParams&quot;:{&quot;bucket&quot;:&quot;18&quot;,&quot;biparam&quot;:&quot;_AB-LR517-LR854-LR895-PR517-PR854-PR895&quot;},&quot;autoNav&quot;:{&quot;auxCategory&quot;:[],&quot;findNum&quot;:&quot;191.41\u4e07&quot;,&quot;navCategory&quot;:[{&quot;cid&quot;:&quot;56152131&quot;,&quot;cname&quot;:&quot;3C\u6570\u7801\u914d\u4ef6&quot;,&quot;count&quot;:&quot;1857503&quot;,&quot;flag&quot;:&quot;qp_commend&quot;,&quot;subCids&quot;:[{&quot;cid&quot;:&quot;56152157&quot;,&quot;cname&quot;:&quot;\u4fdd\u62a4\u5957/\u58f3&quot;,&quot;count&quot;:&quot;1844168&quot;,&quot;flag&quot;:&quot;qp_commend&quot;},{&quot;cid&quot;:&quot;56152161&quot;,&quot;cname&quot; 1jd = json.loads(m.group(1)) 1jd {u&apos;abtestParams&apos;: {u&apos;biparam&apos;: u&apos;_AB-LR517-LR854-LR895-PR517-PR854-PR895&apos;, u&apos;bucket&apos;: u&apos;18&apos;},......... 12with open('a.json','w') as f: f.write(json.dumps(jd)) 12for item in jd['itemList']: print item['nick'],item['price'] ibhdme数码旗舰店 29.00 晋美通讯 39.00 柯米数码专营店 35.00 凯莱德数码专营店 88.00 pehe旗舰店 48.00 法栋数码专营 98.00 coolook数码旗舰店 35.00 lunaluno数码旗舰店 29.90 亦嘉殿 28.00 驰界数码 58.00 citycase旗舰店 58.00 makorday 29.80 唯友通讯 58.00 milan9995200 68.00 伯托尔数码专营店 138.00 h_belis 26.00 梦幻文文 60.00 12import pandasdf = pandas.DataFrame(jd['itemList']) 1df]]></content>
    </entry>

    
  
  
</search>
